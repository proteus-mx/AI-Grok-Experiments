<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Wars</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Orbitron', sans-serif; 
            background: #000; 
        }
        canvas { display: block; }
        #welcome, #game-over, #exit-confirm, #settings-view { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            color: #fff; text-align: center; 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            font-family: 'Orbitron', sans-serif;
        }
        #welcome, #exit-confirm, #settings-view { background: rgba(0, 0, 0, 0.85); }
        #game-over { background: rgba(0, 0, 0, 0.7); }
        #game-over > div {
            background: rgba(0, 0, 0, 0.5); padding: 20px; border: 1px solid rgba(255, 255, 255, 0.3); 
            border-radius: 10px; width: 80%;
        }
        #exit-confirm, #settings-view { display: none; }
        #welcome button, #game-over button, #camera-toggle, #exit-button, #sound-toggle, #hint-toggle, #exit-yes, #exit-no, #settings-button, #settings-close, #submit-score { 
            margin: 10px; padding: 6px 12px; font-size: 12px; cursor: pointer; 
            background: #00ff00; color: #000; border: none; border-radius: 8px; 
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5); transition: transform 0.2s; touch-action: none; 
            font-family: 'Orbitron', sans-serif;
        }
        #welcome button:hover, #game-over button:hover, #camera-toggle:hover, #exit-button:hover, #sound-toggle:hover, #hint-toggle:hover, #exit-yes:hover, #exit-no:hover, #settings-button:hover, #settings-close:hover, #submit-score:hover { 
            background: #00cc00; transform: scale(1.05); 
        }
        #game-stats-container { 
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%); 
            background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px; 
            border: 1px solid rgba(255, 255, 255, 0.3); text-align: center; display: none; 
            font-family: 'Orbitron', sans-serif;
        }
        #game-title { color: #00ff00; font-size: 18px; text-shadow: 0 0 5px #000; margin: 0; }
        #game-timer { color: #fff; font-size: 14px; text-shadow: 0 0 5px #000; margin: 5px 0; }
        #turn { color: #fff; font-size: 16px; text-shadow: 0 0 5px #000; margin: 5px 0; }
        #moves { color: #fff; font-size: 14px; text-shadow: 0 0 5px #000; margin: 5px 0; }
        #games-won { color: #fff; font-size: 14px; text-shadow: 0 0 5px #000; margin: 5px 0; }
        #red-stats { 
            position: absolute; top: 120px; left: 10px; color: #ff0000; font-size: 14px; 
            text-shadow: 0 0 5px #000; background: rgba(0, 0, 0, 0.5); padding: 10px; 
            border-radius: 5px; border: 1px solid rgba(255, 0, 0, 0.3); 
            font-family: 'Orbitron', sans-serif;
        }
        #blue-stats { 
            position: absolute; top: 120px; right: 10px; color: #0000ff; font-size: 14px; 
            text-shadow: 0 0 5px #000; text-align: right; background: rgba(0, 0, 0, 0.5); 
            padding: 10px; border-radius: 5px; border: 1px solid rgba(0, 0, 255, 0.3); 
            font-family: 'Orbitron', sans-serif;
        }
        #red-stats.flash, #blue-stats.flash { animation: flash 0.5s ease-in-out 3; }
        #button-container { 
            position: absolute; bottom: 60px; right: 10px; display: none; display: flex; gap: 10px; 
        }
        #exit-button-container {
            position: absolute; bottom: 60px; left: 10px; display: none;
        }
        #camera-toggle, #exit-button, #sound-toggle, #hint-toggle { margin: 0; }
        #message { 
            position: absolute; bottom: 100px; left: 50%; transform: translate(-50%, 0); 
            font-size: 28px; display: none; text-shadow: 0 0 5px #000; padding: 10px 20px; 
            width: 80%; background: rgba(0, 0, 0, 0.5); border-radius: 5px; text-align: center; 
            font-family: 'Orbitron', sans-serif;
        }
        #points-message { 
            position: absolute; font-size: 14px; display: none; text-shadow: 0 0 5px #000; text-align: center; 
            font-family: 'Orbitron', sans-serif;
        }
        #points-message div { width: 150px; text-align: center; }
        .neutral-message { color: #ffffff; }
        .positive-message { color: #00ff00; }
        .red-message { color: #ff0000; }
        .blue-message { color: #0000ff; }
        .red-points { color: #ff0000; }
        .blue-points { color: #0000ff; }
        .red-winner { color: #ff0000; }
        .blue-winner { color: #0000ff; }
        .tie-winner { color: #ffffff; }
        .flash { animation: flash 0.5s ease-in-out 3; }
        @keyframes flash { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        #game-over { display: none; }
        #win-prob-bar { 
            position: absolute; bottom: 0; left: 0; width: 100%; height: 20px; display: none; 
            background: rgba(51, 51, 51, 0.5); font-size: 10px; color: #fff; 
            z-index: 10; display: flex; justify-content: center; align-items: center; 
            text-shadow: 0 0 2px #000; font-family: 'Orbitron', sans-serif;
        }
        #win-prob-red { background: rgba(255, 0, 0, 0.5); height: 100%; float: left; }
        #win-prob-blue { background: rgba(0, 0, 255, 0.5); height: 100%; float: left; }
        #win-prob-tie { background: rgba(153, 153, 153, 0.5); height: 100%; float: left; }
        #progress-bar { 
            position: absolute; bottom: 20px; left: 0; width: 100%; height: 20px; display: none; 
            background: transparent; font-size: 10px; color: #fff; text-align: center; 
            display: flex; justify-content: center; align-items: center; text-shadow: 0 0 2px #000; 
            font-family: 'Orbitron', sans-serif;
        }
        #progress-red { background: #ff0000; height: 100%; float: left; }
        #progress-blue { background: #0000ff; height: 100%; float: left; }
        #progress-tie { background: #666; height: 100%; float: left; }
        .red-stat { color: #ff0000; }
        .blue-stat { color: #0000ff; }
        .neutral-stat { color: #ffffff; }
        #winner-text { font-size: 36px; }
        #settings-view h2 { font-size: 24px; margin-bottom: 20px; }
        #ai-speed-slider { width: 200px; margin: 10px 0; touch-action: none; }
        #ai-speed-label { font-size: 14px; margin-bottom: 10px; }
    </style>
</head>
<body>
    <div id="welcome">
        <h1>Grid Wars</h1>
        <p>Connect adjacent dots to form glowing lines. Complete a 1x1 square to claim it with your color (Red or Blue). Players keep their turn if they form a box; otherwise, the turn switches. In 1 Player mode, a smart AI plays as Blue. In AI Mode, both players are automated.</p>
        <button id="one-player">1 Player</button>
        <button id="two-player">2 Player</button>
        <button id="ai-mode">AI Mode</button>
        <button id="settings-button">Settings</button>
    </div>
    <div id="settings-view">
        <h2>Settings</h2>
        <label id="ai-speed-label" for="ai-speed-slider">AI Speed: 1.5s</label>
        <input type="range" id="ai-speed-slider" min="0.1" max="3" step="0.1" value="1.5">
        <button id="settings-close">Close</button>
    </div>
    <div id="game-over">
        <div>
            <h1>Game Over</h1>
            <div id="winner-text"></div>
            <div id="final-stats">
                <span class="red-stat">Red: 0 (Score: 0, Time: 0s, Moves: 0)</span><br>
                <span class="blue-stat">Blue: 0 (Score: 0, Time: 0s, Moves: 0)</span><br>
                <span class="neutral-stat">Total Moves: 0</span><br>
                <span class="neutral-stat">Game Time: 0s</span><br>
                <span class="neutral-stat">Games Won - Red: 0, Blue: 0, Tie: 0</span>
            </div>
            <button id="play-again">Play Again</button>
            <button id="submit-score">Submit Score</button>
        </div>
    </div>
    <div id="exit-confirm" style="display: none;">
        <h2>Are you sure you want to exit?</h2>
        <button id="exit-yes">Yes</button>
        <button id="exit-no">No</button>
    </div>
    <div id="game-stats-container">
        <div id="game-title">Grid Wars</div>
        <div id="game-timer" style="display: none;">Game Time: 0s</div>
        <div id="turn" style="display: none;">Red's Turn</div>
        <div id="moves" style="display: none;">Moves: 0</div>
        <div id="games-won" style="display: none;">Games Won: Red 0, Blue 0, Tie 0</div>
    </div>
    <div id="red-stats" style="display: none;">Red: 0<br>Score: 0<br>Time: 0s<br>Moves: 0</div>
    <div id="blue-stats" style="display: none;">Blue: 0<br>Score: 0<br>Time: 0s<br>Moves: 0</div>
    <div id="win-prob-bar" style="display: none;">
        <div id="win-prob-red" style="width: 0%;"></div>
        <div id="win-prob-blue" style="width: 0%;"></div>
        <div id="win-prob-tie" style="width: 0%;"></div>
        <span style="position: absolute;">Winning Player Probability</span>
    </div>
    <div id="button-container">
        <button id="camera-toggle">Fly Camera</button>
        <button id="sound-toggle">Sound On</button>
        <button id="hint-toggle">Hint Off</button>
    </div>
    <div id="exit-button-container">
        <button id="exit-button">Exit Game</button>
    </div>
    <div id="message"></div>
    <div id="points-message"></div>
    <div id="progress-bar" style="display: none;">
        <div id="progress-red" style="width: 0%;"></div>
        <div id="progress-blue" style="width: 0%;"></div>
        <div id="progress-tie" style="width: 0%;"></div>
        <span>Games Won</span>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            if (!window.THREE) return;
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            const pointLight = new THREE.PointLight(0xffffff, 1, 50);
            pointLight.position.set(0, 0, 12);
            scene.add(pointLight);
            const gridSize = 5;
            const spacing = 2;
            const maxLines = gridSize * (gridSize - 1) * 2;
            const dots = [];
            const lines = [];
            const boxes = [];
            let selectedDot = null;
            let yellowOverlayDot = null;
            let previewLine = null;
            let currentPlayer = 'red';
            let scores = { red: 0, blue: 0 };
            let redScore = 0;
            let blueScore = 0;
            let moveCount = 0;
            let redMoves = 0;
            let blueMoves = 0;
            let gameMode = null;
            let gameActive = false;
            let startTime = 0;
            let redTime = 0;
            let blueTime = 0;
            let lastSwitchTime = 0;
            let lastMoveTime = 0;
            let timerInterval = null;
            let throbTime = 0;
            let flashingLines = [];
            let isFlyCamera = false;
            let cameraTime = 0;
            let audioCtx = null;
            let gameStats = { red: 0, blue: 0, tie: 0 };
            let soundEnabled = true;
            let hintEnabled = false;
            let hintLine = null;
            let bestHintMove = null;
            let isWelcomeScreen = true;
            let pointsMessages = [];
            let lastIdleReminder = 0;
            let wobbleTime = 0;
            let aiSpeed = 1500;
            const dotWobbleOffsets = [];
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true });
            const starPositions = new Float32Array(5000 * 3);
            const starOpacities = new Float32Array(5000);
            for (let i = 0; i < 5000; i++) {
                starPositions[i * 3] = (Math.random() - 0.5) * 150;
                starPositions[i * 3 + 1] = (Math.random() - 0.5) * 150;
                starPositions[i * 3 + 2] = (Math.random() - 0.5) * 150;
                starOpacities[i] = Math.random() * 0.5 + 0.5;
            }
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('opacity', new THREE.BufferAttribute(starOpacities, 1));
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
            const dotGeometry = new THREE.SphereGeometry(0.4, 64, 64);
            const dotMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00, shininess: 100, specular: 0x555555 });
            const validDotMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffff, shininess: 100, specular: 0x555555 });
            const dimDotMaterial = new THREE.MeshPhongMaterial({ color: 0x006600, shininess: 100, specular: 0x555555 });
            const yellowOverlayMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, shininess: 100, specular: 0x555555 });
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                    dot.position.set(x * spacing - (gridSize - 1) * spacing / 2, y * spacing - (gridSize - 1) * spacing / 2, 0);
                    dot.userData = { x, y, basePosition: dot.position.clone() };
                    scene.add(dot);
                    dots.push(dot);
                    dotWobbleOffsets.push({
                        x: (Math.random() - 0.5) * 0.1,
                        y: (Math.random() - 0.5) * 0.1,
                        phase: Math.random() * Math.PI * 2
                    });
                }
            }
            const redTubeMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, shininess: 100, specular: 0x555555, transparent: true });
            const blueTubeMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, shininess: 100, specular: 0x555555, transparent: true });
            const hintTubeMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, shininess: 100, specular: 0x555555, transparent: true });
            const raycaster = new THREE.Raycaster();
            raycaster.params.Points.threshold = 0.5;
            const mouse = new THREE.Vector2();
            function disposeObject(obj) {
                if (!obj) return;
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
                if (scene) scene.remove(obj);
            }
            function initAudio() {
                if (!audioCtx && (window.AudioContext || window.webkitAudioContext)) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
            }
            function playSound(frequency, duration, type = 'sine') {
                if (!soundEnabled || !audioCtx) return;
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + duration);
            }
            function toggleSound() {
                soundEnabled = !soundEnabled;
                const soundToggle = document.getElementById('sound-toggle');
                if (soundToggle) soundToggle.textContent = soundEnabled ? 'Sound On' : 'Sound Off';
            }
            function toggleHint() {
                hintEnabled = !hintEnabled;
                const hintToggle = document.getElementById('hint-toggle');
                if (hintToggle) hintToggle.textContent = hintEnabled ? 'Hint On' : 'Hint Off';
                if (hintEnabled && gameActive && (gameMode !== 'ai' && (gameMode !== '1player' || currentPlayer === 'red'))) {
                    highlightBestMove();
                } else {
                    if (hintLine) {
                        disposeObject(hintLine);
                        hintLine = null;
                    }
                    bestHintMove = null;
                }
            }
            function highlightBestMove() {
                if (!hintEnabled || !gameActive || (gameMode === 'ai' || (gameMode === '1player' && currentPlayer === 'blue'))) return;
                if (hintLine) {
                    disposeObject(hintLine);
                    hintLine = null;
                }
                const validMoves = [];
                const boxClosingMoves = [];
                const blockingMoves = [];
                dots.forEach(dot1 => {
                    dots.forEach(dot2 => {
                        if (isValidConnection(dot1, dot2)) {
                            const move = [dot1, dot2];
                            validMoves.push(move);
                            const tempLines = [...lines, {
                                start: { x: Math.min(dot1.userData.x, dot2.userData.x), y: Math.min(dot1.userData.y, dot2.userData.y) },
                                end: { x: Math.max(dot1.userData.x, dot2.userData.x), y: Math.max(dot1.userData.y, dot2.userData.y) }
                            }];
                            let closesBox = false;
                            for (let x = 0; x < gridSize - 1; x++) {
                                for (let y = 0; y < gridSize - 1; y++) {
                                    if (hasBox(x, y, tempLines) && !boxes.some(box => box.userData.x === x && box.userData.y === y)) {
                                        closesBox = true;
                                        break;
                                    }
                                }
                            }
                            if (closesBox) {
                                boxClosingMoves.push(move);
                            }
                            const opponent = currentPlayer === 'red' ? 'blue' : 'red';
                            let givesBox = false;
                            dots.forEach(d1 => {
                                dots.forEach(d2 => {
                                    if (isValidConnection(d1, d2)) {
                                        const tempLines2 = [...tempLines, {
                                            start: { x: Math.min(d1.userData.x, d2.userData.x), y: Math.min(d1.userData.y, d2.userData.y) },
                                            end: { x: Math.max(d1.userData.x, d2.userData.x), y: Math.max(d2.userData.y, d2.userData.y) }
                                        }];
                                        for (let x = 0; x < gridSize - 1; x++) {
                                            for (let y = 0; y < gridSize - 1; y++) {
                                                if (hasBox(x, y, tempLines2) && !boxes.some(box => box.userData.x === x && box.userData.y === y)) {
                                                    givesBox = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                });
                            });
                            if (!givesBox) {
                                blockingMoves.push(move);
                            }
                        }
                    });
                });
                let move;
                if (boxClosingMoves.length > 0) {
                    move = boxClosingMoves[Math.floor(Math.random() * boxClosingMoves.length)];
                } else if (blockingMoves.length > 0) {
                    move = blockingMoves[Math.floor(Math.random() * blockingMoves.length)];
                } else if (validMoves.length > 0) {
                    move = validMoves[Math.floor(Math.random() * validMoves.length)];
                }
                if (move) {
                    bestHintMove = move;
                    const [dot1, dot2] = move;
                    const path = new THREE.LineCurve3(dot1.position, dot2.position);
                    const geometry = new THREE.TubeGeometry(path, 32, 0.1, 8, false);
                    hintLine = new THREE.Mesh(geometry, hintTubeMaterial.clone());
                    hintLine.position.z = 0.04;
                    scene.add(hintLine);
                    flashingLines.push({ line: hintLine, time: 0, flashes: 0 });
                } else {
                    bestHintMove = null;
                }
            }
            function showMessage(text, isReminder = false) {
                const messageElement = document.getElementById('message');
                if (!messageElement) return;
                messageElement.textContent = text;
                messageElement.style.display = 'block';
                messageElement.classList.remove('neutral-message', 'positive-message', 'red-message', 'blue-message');
                if (text.includes('Choose an adjacent') || text.includes('Submit score')) {
                    messageElement.classList.add('neutral-message');
                } else if (isReminder) {
                    messageElement.classList.add(currentPlayer === 'red' ? 'red-message' : 'blue-message');
                } else {
                    messageElement.classList.add('positive-message');
                }
                messageElement.classList.add('flash');
                setTimeout(() => {
                    if (messageElement) {
                        messageElement.style.display = 'none';
                        messageElement.classList.remove('flash');
                    }
                }, 1500);
            }
            function showPointsMessage(points, reason, position) {
                const messageId = Date.now();
                const vector = position.clone().project(camera);
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                const clampedX = Math.max(50, Math.min(window.innerWidth - 50, x));
                const clampedY = Math.max(50, Math.min(window.innerHeight - 100, y));
                pointsMessages.push({ 
                    id: messageId, 
                    text: `+${points} ${reason}`, 
                    x: clampedX, 
                    y: clampedY, 
                    offset: pointsMessages.length * 14,
                    player: currentPlayer
                });
                updatePointsDisplay();
                setTimeout(() => {
                    pointsMessages = pointsMessages.filter(msg => msg.id !== messageId);
                    updatePointsDisplay();
                }, 1000);
            }
            function updatePointsDisplay() {
                const pointsElement = document.getElementById('points-message');
                if (!pointsElement) return;
                if (pointsMessages.length === 0) {
                    pointsElement.style.display = 'none';
                    pointsElement.innerHTML = '';
                    return;
                }
                pointsElement.style.display = 'block';
                pointsElement.innerHTML = pointsMessages.map(msg => 
                    `<div class="${msg.player}-points" style="position: absolute; width: 150px; top: ${msg.y + msg.offset}px; left: ${msg.x}px; transform: translate(-50%, 0); text-align: center;">${msg.text}</div>`
                ).join('');
                pointsElement.classList.add('flash');
            }
            function toggleCamera() {
                isFlyCamera = !isFlyCamera;
                const cameraToggle = document.getElementById('camera-toggle');
                if (cameraToggle) cameraToggle.textContent = isFlyCamera ? 'Static Camera' : 'Fly Camera';
                if (!isFlyCamera) {
                    camera.position.set(0, 0, 12);
                    camera.lookAt(0, 0, 0);
                }
            }
            function checkDotConnectivity(dot) {
                return dots.some(otherDot => isValidConnection(dot, otherDot));
            }
            function updateDotConnectivity() {
                dots.forEach(dot => {
                    if (!checkDotConnectivity(dot) && dot.material !== dimDotMaterial) {
                        dot.material = dimDotMaterial;
                    } else if (checkDotConnectivity(dot) && dot.material === dimDotMaterial) {
                        dot.material = dotMaterial;
                    }
                });
            }
            function calculateWinProbabilities() {
                const totalBoxes = (gridSize - 1) * (gridSize - 1);
                const remainingBoxes = totalBoxes - (scores.red + scores.blue);
                if (remainingBoxes <= 0) {
                    return { red: scores.red > scores.blue ? 100 : 0, blue: scores.blue > scores.red ? 100 : 0, tie: scores.red === scores.blue ? 100 : 0 };
                }
                let redPotential = scores.red;
                let bluePotential = scores.blue;
                const validMoves = [];
                const boxClosingMoves = [];
                dots.forEach(dot1 => {
                    dots.forEach(dot2 => {
                        if (isValidConnection(dot1, dot2)) {
                            const move = [dot1, dot2];
                            validMoves.push(move);
                            const tempLines = [...lines, {
                                start: { x: Math.min(dot1.userData.x, dot2.userData.x), y: Math.min(dot1.userData.y, dot2.userData.y) },
                                end: { x: Math.max(dot1.userData.x, dot2.userData.x), y: Math.max(dot1.userData.y, dot2.userData.y) }
                            }];
                            let closesBox = false;
                            for (let x = 0; x < gridSize - 1; x++) {
                                for (let y = 0; y < gridSize - 1; y++) {
                                    if (hasBox(x, y, tempLines) && !boxes.some(box => box.userData.x === x && box.userData.y === y)) {
                                        closesBox = true;
                                        break;
                                    }
                                }
                            }
                            if (closesBox) {
                                boxClosingMoves.push(move);
                            }
                        }
                    });
                });
                const boxClosingWeight = boxClosingMoves.length / (validMoves.length || 1);
                redPotential += boxClosingWeight * remainingBoxes * (currentPlayer === 'red' ? 0.6 : 0.4);
                bluePotential += boxClosingWeight * remainingBoxes * (currentPlayer === 'blue' ? 0.6 : 0.4);
                const totalPotential = redPotential + bluePotential;
                let redProb = totalPotential > 0 ? (redPotential / totalPotential) * 100 : 50;
                let blueProb = totalPotential > 0 ? (bluePotential / totalPotential) * 100 : 50;
                let tieProb = 100 - redProb - blueProb;
                if (tieProb < 0) {
                    const adjust = tieProb / 2;
                    redProb += adjust;
                    blueProb += adjust;
                    tieProb = 0;
                }
                return {
                    red: Math.max(0, Math.min(100, redProb.toFixed(1))),
                    blue: Math.max(0, Math.min(100, blueProb.toFixed(1))),
                    tie: Math.max(0, Math.min(100, tieProb.toFixed(1)))
                };
            }
            function startGame(mode) {
                initAudio();
                gameMode = mode;
                gameActive = true;
                isWelcomeScreen = false;
                isFlyCamera = false;
                const cameraToggle = document.getElementById('camera-toggle');
                if (cameraToggle) cameraToggle.textContent = 'Fly Camera';
                camera.position.set(0, 0, 12);
                camera.lookAt(0, 0, 0);
                const welcome = document.getElementById('welcome');
                if (welcome) welcome.style.display = 'none';
                const settingsView = document.getElementById('settings-view');
                if (settingsView) settingsView.style.display = 'none';
                const statsContainer = document.getElementById('game-stats-container');
                if (statsContainer) statsContainer.style.display = 'block';
                const timer = document.getElementById('game-timer');
                if (timer) timer.style.display = 'block';
                const turn = document.getElementById('turn');
                if (turn) turn.style.display = 'block';
                const moves = document.getElementById('moves');
                if (moves) moves.style.display = 'block';
                const gamesWon = document.getElementById('games-won');
                if (gamesWon) gamesWon.style.display = 'block';
                const redStats = document.getElementById('red-stats');
                if (redStats) redStats.style.display = 'block';
                const blueStats = document.getElementById('blue-stats');
                if (blueStats) blueStats.style.display = 'block';
                const winProbBar = document.getElementById('win-prob-bar');
                if (winProbBar) winProbBar.style.display = 'block';
                const progressBar = document.getElementById('progress-bar');
                if (progressBar) progressBar.style.display = 'block';
                const buttonContainer = document.getElementById('button-container');
                if (buttonContainer) buttonContainer.style.display = 'flex';
                const exitButtonContainer = document.getElementById('exit-button-container');
                if (exitButtonContainer) exitButtonContainer.style.display = 'block';
                if (mode === 'ai') {
                    const hintToggle = document.getElementById('hint-toggle');
                    if (hintToggle) hintToggle.style.display = 'none';
                } else {
                    const hintToggle = document.getElementById('hint-toggle');
                    if (hintToggle) hintToggle.style.display = 'block';
                }
                const soundToggle = document.getElementById('sound-toggle');
                if (soundToggle) soundToggle.style.display = 'block';
                const gameTitle = document.getElementById('game-title');
                if (gameTitle) gameTitle.textContent = 'Grid Wars';
                startTime = Date.now();
                lastSwitchTime = startTime;
                lastMoveTime = startTime;
                lastIdleReminder = startTime;
                redTime = 0;
                blueTime = 0;
                redMoves = 0;
                blueMoves = 0;
                timerInterval = setInterval(updateTimer, 1000);
                if (mode === 'ai') {
                    setTimeout(aiMove, aiSpeed);
                } else if (hintEnabled) {
                    highlightBestMove();
                }
            }
            function updateTimer() {
                if (!gameActive) return;
                const now = Date.now();
                const elapsed = Math.floor((now - startTime) / 1000);
                const turnTime = Math.floor((now - lastSwitchTime) / 1000);
                if (currentPlayer === 'red') {
                    redTime += turnTime;
                } else {
                    blueTime += turnTime;
                }
                lastSwitchTime = now;
                const gameTimer = document.getElementById('game-timer');
                if (gameTimer) gameTimer.textContent = `Game Time: ${elapsed}s`;
                const redStats = document.getElementById('red-stats');
                if (redStats) redStats.innerHTML = `Red: ${scores.red}<br>Score: ${redScore}<br>Time: ${redTime}s<br>Moves: ${redMoves}`;
                const blueStats = document.getElementById('blue-stats');
                if (blueStats) blueStats.innerHTML = `Blue: ${scores.blue}<br>Score: ${blueScore}<br>Time: ${blueTime}s<br>Moves: ${blueMoves}`;
            }
            function updateMoves() {
                const movesElement = document.getElementById('moves');
                if (movesElement) movesElement.textContent = `Moves: ${moveCount}`;
            }
            function updateMousePosition(event) {
                const rect = renderer.domElement.getBoundingClientRect();
                const clientX = event.clientX || (event.changedTouches && event.changedTouches[0] ? event.changedTouches[0].clientX : (event.touches && event.touches[0] ? event.touches[0].clientX : 0));
                const clientY = event.clientY || (event.changedTouches && event.changedTouches[0] ? event.changedTouches[0].clientY : (event.touches && event.touches[0] ? event.touches[0].clientY : 0));
                if (rect.width === 0 || rect.height === 0) return;
                mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            }
            function handleButtonInteraction(event, callback) {
                event.preventDefault();
                callback();
            }
            function addButtonListeners(buttonId, callback) {
                const button = document.getElementById(buttonId);
                if (!button) return;
                button.addEventListener('click', (event) => handleButtonInteraction(event, callback));
                button.addEventListener('touchstart', (event) => {
                    if (event.touches && event.touches.length === 1) {
                        handleButtonInteraction(event, callback);
                    }
                }, { passive: false });
            }
            addButtonListeners('one-player', () => startGame('1player'));
            addButtonListeners('two-player', () => startGame('2player'));
            addButtonListeners('ai-mode', () => startGame('ai'));
            addButtonListeners('play-again', () => resetGame(gameMode, false));
            addButtonListeners('exit-yes', () => resetGame(null, true, false));
            addButtonListeners('exit-no', () => {
                const exitConfirm = document.getElementById('exit-confirm');
                if (exitConfirm) exitConfirm.style.display = 'none';
            });
            addButtonListeners('camera-toggle', toggleCamera);
            addButtonListeners('exit-button', () => resetGame(null, true, true));
            addButtonListeners('sound-toggle', toggleSound);
            addButtonListeners('hint-toggle', toggleHint);
            addButtonListeners('settings-button', () => {
                const welcome = document.getElementById('welcome');
                const settingsView = document.getElementById('settings-view');
                if (welcome) welcome.style.display = 'none';
                if (settingsView) settingsView.style.display = 'flex';
            });
            addButtonListeners('settings-close', () => {
                const welcome = document.getElementById('welcome');
                const settingsView = document.getElementById('settings-view');
                if (settingsView) settingsView.style.display = 'none';
                if (welcome) welcome.style.display = 'flex';
            });
            addButtonListeners('submit-score', () => {
                showMessage('Submit score to Game Centre');
            });
            const aiSpeedSlider = document.getElementById('ai-speed-slider');
            const aiSpeedLabel = document.getElementById('ai-speed-label');
            if (aiSpeedSlider && aiSpeedLabel) {
                const updateSliderValue = (value) => {
                    aiSpeed = parseFloat(value) * 1000;
                    aiSpeedSlider.value = value;
                    aiSpeedLabel.textContent = `AI Speed: ${parseFloat(value).toFixed(1)}s`;
                };
                aiSpeedSlider.addEventListener('input', () => {
                    updateSliderValue(aiSpeedSlider.value);
                });
                aiSpeedSlider.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                }, { passive: false });
                aiSpeedSlider.addEventListener('touchmove', (event) => {
                    event.preventDefault();
                    const rect = aiSpeedSlider.getBoundingClientRect();
                    const touchX = event.touches[0].clientX;
                    const min = parseFloat(aiSpeedSlider.min);
                    const max = parseFloat(aiSpeedSlider.max);
                    const step = parseFloat(aiSpeedSlider.step);
                    const relativeX = (touchX - rect.left) / rect.width;
                    let value = min + relativeX * (max - min);
                    value = Math.round(value / step) * step;
                    value = Math.max(min, Math.min(max, value));
                    updateSliderValue(value);
                }, { passive: false });
            }
            function handleDotSelection(event, isTouch = false, isTouchRelease = false) {
                if (!gameActive || (gameMode === '1player' && currentPlayer === 'blue') || gameMode === 'ai') return;
                updateMousePosition(event);
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(dots);
                if (!selectedDot && intersects.length > 0 && !isTouchRelease) {
                    selectedDot = intersects[0].object;
                    yellowOverlayDot = new THREE.Mesh(new THREE.SphereGeometry(0.475, 64, 64), yellowOverlayMaterial);
                    yellowOverlayDot.position.copy(selectedDot.position);
                    yellowOverlayDot.position.z = 0.01;
                    scene.add(yellowOverlayDot);
                    const path = new THREE.LineCurve3(selectedDot.position, selectedDot.position);
                    const geometry = new THREE.TubeGeometry(path, 32, 0.1, 8, false);
                    const tubeMaterial = currentPlayer === 'red' ? redTubeMaterial.clone() : blueTubeMaterial.clone();
                    previewLine = new THREE.Mesh(geometry, tubeMaterial);
                    previewLine.position.z = 0.05;
                    scene.add(previewLine);
                    highlightValidDots(selectedDot);
                } else if (selectedDot && (isTouchRelease || !isTouch)) {
                    const validIntersects = intersects
                        .filter(intersect => isValidConnection(selectedDot, intersect.object))
                        .sort((a, b) => a.distance - b.distance);
                    const targetDot = validIntersects[0];
                    if (targetDot && isValidConnection(selectedDot, targetDot.object)) {
                        drawLine(selectedDot, targetDot.object);
                        const boxCount = checkForBoxes();
                        if (boxCount > 0) {
                            showMessage(`${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)} formed a box!`);
                            playSound(600, 0.3, 'sine');
                        } else {
                            playSound(400, 0.2, 'sine');
                            lastSwitchTime = Date.now();
                            lastMoveTime = Date.now();
                            lastIdleReminder = Date.now();
                        }
                        if (boxCount === 0) {
                            currentPlayer = currentPlayer === 'red' ? 'blue' : 'red';
                            updateTurnIndicator();
                            if (gameMode === '1player' && currentPlayer === 'blue') {
                                setTimeout(aiMove, aiSpeed);
                            } else if (hintEnabled) {
                                highlightBestMove();
                            }
                        } else if (hintEnabled) {
                            highlightBestMove();
                        }
                    } else {
                        showMessage('Choose an adjacent, unconnected dot.');
                        playSound(200, 0.2, 'square');
                    }
                    if (previewLine) {
                        disposeObject(previewLine);
                        previewLine = null;
                    }
                    if (yellowOverlayDot) {
                        disposeObject(yellowOverlayDot);
                        yellowOverlayDot = null;
                    }
                    resetDotColors();
                    selectedDot = null;
                }
            }
            window.addEventListener('click', (event) => handleDotSelection(event));
            window.addEventListener('touchstart', (event) => {
                if (event.touches && event.touches.length === 1) {
                    event.preventDefault();
                    handleDotSelection(event, true);
                }
            }, { passive: false });
            window.addEventListener('touchend', (event) => {
                if (event.changedTouches && event.changedTouches.length === 1) {
                    event.preventDefault();
                    handleDotSelection(event, true, true);
                }
            }, { passive: false });
            window.addEventListener('touchmove', (event) => {
                if (event.touches && event.touches.length === 1) {
                    event.preventDefault();
                    updateMousePosition(event);
                    updatePreviewLine();
                }
            }, { passive: false });
            function isValidConnection(dot1, dot2) {
                if (!dot1 || !dot2 || dot1 === dot2) return false;
                const dx = Math.abs(dot1.userData.x - dot2.userData.x);
                const dy = Math.abs(dot1.userData.y - dot2.userData.y);
                const isAdjacent = (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
                if (!isAdjacent) return false;
                const lineExists = lines.some(l => 
                    (l.start.x === Math.min(dot1.userData.x, dot2.userData.x) && 
                     l.start.y === Math.min(dot1.userData.y, dot2.userData.y) && 
                     l.end.x === Math.max(dot1.userData.x, dot2.userData.x) && 
                     l.end.y === Math.max(dot1.userData.y, dot2.userData.y))
                );
                return !lineExists;
            }
            function highlightValidDots(selected) {
                if (!selected) return;
                dots.forEach(dot => {
                    if (isValidConnection(selected, dot)) {
                        dot.material = validDotMaterial;
                        dot.scale.set(1.2, 1.2, 1.2);
                        dot.userData.isValid = true;
                    } else {
                        dot.material = checkDotConnectivity(dot) ? dotMaterial : dimDotMaterial;
                        dot.scale.set(1, 1, 1);
                        dot.userData.isValid = false;
                    }
                });
            }
            function resetDotColors() {
                dots.forEach(dot => {
                    dot.material = checkDotConnectivity(dot) ? dotMaterial : dimDotMaterial;
                    dot.scale.set(1, 1, 1);
                    dot.userData.isValid = false;
                    dot.material.opacity = 1;
                    dot.material.transparent = false;
                });
            }
            function drawLine(dot1, dot2) {
                const path = new THREE.LineCurve3(dot1.userData.basePosition, dot2.userData.basePosition);
                const geometry = new THREE.TubeGeometry(path, 32, 0.1, 8, false);
                const tubeMaterial = currentPlayer === 'red' ? redTubeMaterial.clone() : blueTubeMaterial.clone();
                const tube = new THREE.Mesh(geometry, tubeMaterial);
                tube.position.z = 0.05;
                scene.add(tube);
                const newBoxes = [];
                const lineMidpoint = new THREE.Vector3().addVectors(dot1.position, dot2.position).multiplyScalar(0.5);
                const boxCount = checkForBoxes(newBoxes);
                let points = 1;
                showPointsMessage(1, 'Line', lineMidpoint);
                if (boxCount > 0) {
                    points += 5 * boxCount;
                    const lastBox = newBoxes[newBoxes.length - 1];
                    const boxPosition = lastBox ? lastBox.position : lineMidpoint;
                    showPointsMessage(5 * boxCount, `${boxCount} Box${boxCount > 1 ? 'es' : ''}`, boxPosition);
                }
                const moveTime = Date.now();
                if (moveTime - lastMoveTime < 5000) {
                    points += 2;
                    showPointsMessage(2, 'Fast Move', lineMidpoint);
                }
                if (currentPlayer === 'red') {
                    redScore += points;
                    redMoves++;
                } else {
                    blueScore += points;
                    blueMoves++;
                }
                lines.push({ 
                    start: { x: Math.min(dot1.userData.x, dot2.userData.x), y: Math.min(dot1.userData.y, dot2.userData.y) },
                    end: { x: Math.max(dot1.userData.x, dot2.userData.x), y: Math.max(dot1.userData.y, dot2.userData.y) },
                    player: currentPlayer,
                    mesh: tube,
                    dot1: dot1,
                    dot2: dot2
                });
                flashingLines.push({ line: tube, time: 0, flashes: 0 });
                moveCount++;
                lastMoveTime = moveTime;
                lastIdleReminder = moveTime;
                updateDotConnectivity();
                updateMoves();
                updateStats();
                if (hintLine) {
                    disposeObject(hintLine);
                    hintLine = null;
                }
                bestHintMove = null;
                checkGameOver();
            }
            function aiMove() {
                if (!gameActive) return;
                const validMoves = [];
                const boxClosingMoves = [];
                const blockingMoves = [];
                dots.forEach(dot1 => {
                    dots.forEach(dot2 => {
                        if (isValidConnection(dot1, dot2)) {
                            const move = [dot1, dot2];
                            validMoves.push(move);
                            const tempLines = [...lines, {
                                start: { x: Math.min(dot1.userData.x, dot2.userData.x), y: Math.min(dot1.userData.y, dot2.userData.y) },
                                end: { x: Math.max(dot1.userData.x, dot2.userData.x), y: Math.max(dot1.userData.y, dot2.userData.y) }
                            }];
                            let closesBox = false;
                            for (let x = 0; x < gridSize - 1; x++) {
                                for (let y = 0; y < gridSize - 1; y++) {
                                    if (hasBox(x, y, tempLines) && !boxes.some(box => box.userData.x === x && box.userData.y === y)) {
                                        closesBox = true;
                                        break;
                                    }
                                }
                            }
                            if (closesBox) {
                                boxClosingMoves.push(move);
                            }
                            const opponent = currentPlayer === 'red' ? 'blue' : 'red';
                            let givesBox = false;
                            dots.forEach(d1 => {
                                dots.forEach(d2 => {
                                    if (isValidConnection(d1, d2)) {
                                        const tempLines2 = [...tempLines, {
                                            start: { x: Math.min(d1.userData.x, d2.userData.x), y: Math.min(d1.userData.y, d2.userData.y) },
                                            end: { x: Math.max(d1.userData.x, d2.userData.x), y: Math.max(d2.userData.y, d2.userData.y) }
                                        }];
                                        for (let x = 0; x < gridSize - 1; x++) {
                                            for (let y = 0; y < gridSize - 1; y++) {
                                                if (hasBox(x, y, tempLines2) && !boxes.some(box => box.userData.x === x && box.userData.y === y)) {
                                                    givesBox = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                });
                            });
                            if (!givesBox) {
                                blockingMoves.push(move);
                            }
                        }
                    });
                });
                let move;
                if (boxClosingMoves.length > 0) {
                    move = boxClosingMoves[Math.floor(Math.random() * boxClosingMoves.length)];
                } else if (blockingMoves.length > 0) {
                    move = blockingMoves[Math.floor(Math.random() * blockingMoves.length)];
                } else if (validMoves.length > 0) {
                    move = validMoves[Math.floor(Math.random() * validMoves.length)];
                }
                if (move) {
                    const [dot1, dot2] = move;
                    drawLine(dot1, dot2);
                    const boxCount = checkForBoxes();
                    if (boxCount > 0) {
                        showMessage(`${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)} formed a box!`);
                        playSound(600, 0.3, 'sine');
                    } else {
                        playSound(400, 0.2, 'sine');
                        lastSwitchTime = Date.now();
                        lastMoveTime = Date.now();
                        lastIdleReminder = Date.now();
                    }
                    if (boxCount === 0) {
                        currentPlayer = currentPlayer === 'red' ? 'blue' : 'red';
                        updateTurnIndicator();
                    }
                    if (gameMode === 'ai' || (gameMode === '1player' && currentPlayer === 'blue')) {
                        setTimeout(aiMove, aiSpeed);
                    }
                }
            }
            function checkForBoxes(newBoxes = []) {
                let boxCount = 0;
                for (let x = 0; x < gridSize - 1; x++) {
                    for (let y = 0; y < gridSize - 1; y++) {
                        if (hasBox(x, y) && !boxes.some(box => box.userData.x === x && box.userData.y === y)) {
                            const box = createBox(x, y);
                            newBoxes.push(box);
                            scores[currentPlayer]++;
                            boxCount++;
                            updateStats();
                        }
                    }
                }
                return boxCount;
            }
            function hasBox(x, y, linesToCheck = lines) {
                return linesToCheck.some(l => l.start.x === x && l.start.y === y && l.end.x === x && l.end.y === y + 1) &&
                       linesToCheck.some(l => l.start.x === x && l.start.y === y + 1 && l.end.x === x + 1 && l.end.y === y + 1) &&
                       linesToCheck.some(l => l.start.x === x + 1 && l.start.y === y && l.end.x === x + 1 && l.end.y === y + 1) &&
                       linesToCheck.some(l => l.start.x === x && l.start.y === y && l.end.x === x + 1 && l.end.y === y);
            }
            function createBox(x, y) {
                const boxGeometry = new THREE.PlaneGeometry(spacing, spacing);
                const boxMaterial = new THREE.MeshBasicMaterial({ 
                    color: currentPlayer === 'red' ? 0xff0000 : 0x0000ff, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0
                });
                const box = new THREE.Mesh(boxGeometry, boxMaterial);
                box.position.set(x * spacing - (gridSize - 1) * spacing / 2 + spacing / 2, y * spacing - (gridSize - 1) * spacing / 2 + spacing / 2, -0.1);
                box.userData = { x, y, player: currentPlayer, fadeTime: 0, ripplePhase: Math.random() * Math.PI * 2 };
                scene.add(box);
                boxes.push(box);
                return box;
            }
            function updateTurnIndicator() {
                const turnElement = document.getElementById('turn');
                if (!turnElement) return;
                turnElement.textContent = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s Turn`;
                turnElement.style.color = currentPlayer === 'red' ? '#ff0000' : '#0000ff';
                turnElement.classList.add('flash');
                setTimeout(() => turnElement.classList.remove('flash'), 1500);
            }
            function updateStats() {
                const redStats = document.getElementById('red-stats');
                if (redStats) redStats.innerHTML = `Red: ${scores.red}<br>Score: ${redScore}<br>Time: ${redTime}s<br>Moves: ${redMoves}`;
                const blueStats = document.getElementById('blue-stats');
                if (blueStats) blueStats.innerHTML = `Blue: ${scores.blue}<br>Score: ${blueScore}<br>Time: ${blueTime}s<br>Moves: ${blueMoves}`;
                const gamesWon = document.getElementById('games-won');
                if (gamesWon) gamesWon.textContent = `Games Won: Red ${gameStats.red}, Blue ${gameStats.blue}, Tie ${gameStats.tie}`;
                const totalGames = gameStats.red + gameStats.blue + gameStats.tie;
                const redPercent = totalGames > 0 ? (gameStats.red / totalGames * 100).toFixed(1) : 0;
                const bluePercent = totalGames > 0 ? (gameStats.blue / totalGames * 100).toFixed(1) : 0;
                const tiePercent = totalGames > 0 ? (gameStats.tie / totalGames * 100).toFixed(1) : 0;
                const progressRed = document.getElementById('progress-red');
                if (progressRed) progressRed.style.width = `${redPercent}%`;
                const progressBlue = document.getElementById('progress-blue');
                if (progressBlue) progressBlue.style.width = `${bluePercent}%`;
                const progressTie = document.getElementById('progress-tie');
                if (progressTie) progressTie.style.width = `${tiePercent}%`;
                const probs = calculateWinProbabilities();
                const winProbRed = document.getElementById('win-prob-red');
                if (winProbRed) winProbRed.style.width = `${probs.red}%`;
                const winProbBlue = document.getElementById('win-prob-blue');
                if (winProbBlue) winProbBlue.style.width = `${probs.blue}%`;
                const winProbTie = document.getElementById('win-prob-tie');
                if (winProbTie) winProbTie.style.width = `${probs.tie}%`;
            }
            function checkGameOver() {
                if (lines.length !== maxLines) return;
                gameActive = false;
                isFlyCamera = true;
                if (timerInterval) clearInterval(timerInterval);
                const now = Date.now();
                const elapsed = Math.floor((now - startTime) / 1000);
                const turnTime = Math.floor((now - lastSwitchTime) / 1000);
                if (currentPlayer === 'red') {
                    redTime += turnTime;
                } else {
                    blueTime += turnTime;
                }
                const winner = scores.red > scores.blue ? 'Red' : scores.blue > scores.red ? 'Blue' : 'Tie';
                gameStats[winner.toLowerCase()]++;
                const winnerElement = document.getElementById('winner-text');
                if (winnerElement) {
                    winnerElement.textContent = `Winner: ${winner}`;
                    winnerElement.classList.remove('red-winner', 'blue-winner', 'tie-winner');
                    winnerElement.classList.add(winner === 'Red' ? 'red-winner' : winner === 'Blue' ? 'blue-winner' : 'tie-winner');
                }
                const finalStats = document.getElementById('final-stats');
                if (finalStats) {
                    finalStats.innerHTML = `
                        <span class="red-stat">Red: ${scores.red} (Score: ${redScore}, Time: ${redTime}s, Moves: ${redMoves})</span><br>
                        <span class="blue-stat">Blue: ${scores.blue} (Score: ${blueScore}, Time: ${blueTime}s, Moves: ${blueMoves})</span><br>
                        <span class="neutral-stat">Total Moves: ${moveCount}</span><br>
                        <span class="neutral-stat">Game Time: ${elapsed}s</span><br>
                        <span class="neutral-stat">Games Won - Red: ${gameStats.red}, Blue: ${gameStats.blue}, Tie: ${gameStats.tie}</span>`;
                }
                const gameOver = document.getElementById('game-over');
                if (gameOver) gameOver.style.display = 'flex';
                updateStats();
            }
            function resetGame(mode, resetStats = false, showConfirm = false) {
                if (showConfirm && gameActive) {
                    const exitConfirm = document.getElementById('exit-confirm');
                    if (exitConfirm) exitConfirm.style.display = 'flex';
                    return;
                }
                gameActive = false;
                if (timerInterval) clearInterval(timerInterval);
                const gameOver = document.getElementById('game-over');
                if (gameOver) gameOver.style.display = 'none';
                const exitConfirm = document.getElementById('exit-confirm');
                if (exitConfirm) exitConfirm.style.display = 'none';
                const statsContainer = document.getElementById('game-stats-container');
                if (statsContainer) statsContainer.style.display = 'none';
                const gameTimer = document.getElementById('game-timer');
                if (gameTimer) gameTimer.style.display = 'none';
                const turn = document.getElementById('turn');
                if (turn) turn.style.display = 'none';
                const moves = document.getElementById('moves');
                if (moves) moves.style.display = 'none';
                const gamesWon = document.getElementById('games-won');
                if (gamesWon) gamesWon.style.display = 'none';
                const redStats = document.getElementById('red-stats');
                if (redStats) redStats.style.display = 'none';
                const blueStats = document.getElementById('blue-stats');
                if (blueStats) blueStats.style.display = 'none';
                const winProbBar = document.getElementById('win-prob-bar');
                if (winProbBar) winProbBar.style.display = 'none';
                const progressBar = document.getElementById('progress-bar');
                if (progressBar) progressBar.style.display = 'none';
                const buttonContainer = document.getElementById('button-container');
                if (buttonContainer) buttonContainer.style.display = 'none';
                const exitButtonContainer = document.getElementById('exit-button-container');
                if (exitButtonContainer) exitButtonContainer.style.display = 'none';
                const message = document.getElementById('message');
                if (message) message.style.display = 'none';
                const pointsMessage = document.getElementById('points-message');
                if (pointsMessage) pointsMessage.style.display = 'none';
                lines.forEach(line => disposeObject(line.mesh));
                boxes.forEach(box => disposeObject(box));
                if (yellowOverlayDot) {
                    disposeObject(yellowOverlayDot);
                    yellowOverlayDot = null;
                }
                if (hintLine) {
                    disposeObject(hintLine);
                    hintLine = null;
                }
                if (previewLine) {
                    disposeObject(previewLine);
                    previewLine = null;
                }
                lines.length = 0;
                boxes.length = 0;
                scores = { red: 0, blue: 0 };
                redScore = 0;
                blueScore = 0;
                moveCount = 0;
                redMoves = 0;
                blueMoves = 0;
                pointsMessages = [];
                currentPlayer = 'red';
                selectedDot = null;
                flashingLines = [];
                isFlyCamera = false;
                redTime = 0;
                blueTime = 0;
                lastSwitchTime = 0;
                lastMoveTime = 0;
                lastIdleReminder = 0;
                wobbleTime = 0;
                soundEnabled = true;
                hintEnabled = false;
                bestHintMove = null;
                const cameraToggle = document.getElementById('camera-toggle');
                if (cameraToggle) cameraToggle.textContent = 'Fly Camera';
                const soundToggle = document.getElementById('sound-toggle');
                if (soundToggle) soundToggle.textContent = 'Sound On';
                const hintToggle = document.getElementById('hint-toggle');
                if (hintToggle) hintToggle.textContent = 'Hint Off';
                camera.position.set(0, 0, 12);
                camera.lookAt(0, 0, 0);
                if (resetStats) {
                    gameStats = { red: 0, blue: 0, tie: 0 };
                }
                resetDotColors();
                updateStats();
                updateMoves();
                const turnElement = document.getElementById('turn');
                if (turnElement) turnElement.textContent = "Red's Turn";
                const gameTimerElement = document.getElementById('game-timer');
                if (gameTimerElement) gameTimerElement.textContent = "Game Time: 0s";
                const gameTitle = document.getElementById('game-title');
                if (gameTitle) gameTitle.textContent = 'Grid Wars';
                dots.length = 0;
                dotWobbleOffsets.length = 0;
                for (let x = 0; x < gridSize; x++) {
                    for (let y = 0; y < gridSize; y++) {
                        const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                        dot.position.set(x * spacing - (gridSize - 1) * spacing / 2, y * spacing - (gridSize - 1) * spacing / 2, 0);
                        dot.userData = { x, y, basePosition: dot.position.clone() };
                        scene.add(dot);
                        dots.push(dot);
                        dotWobbleOffsets.push({
                            x: (Math.random() - 0.5) * 0.1,
                            y: (Math.random() - 0.5) * 0.1,
                            phase: Math.random() * Math.PI * 2
                        });
                    }
                }
                if (mode) {
                    startGame(mode);
                } else {
                    isWelcomeScreen = true;
                    const welcome = document.getElementById('welcome');
                    if (welcome) welcome.style.display = 'flex';
                }
            }
            function updateWobble() {
                wobbleTime += 0.05;
                dots.forEach((dot, index) => {
                    const offset = dotWobbleOffsets[index];
                    const wobbleX = offset.x * Math.sin(wobbleTime + offset.phase);
                    const wobbleY = offset.y * Math.cos(wobbleTime + offset.phase);
                    dot.position.copy(dot.userData.basePosition);
                    dot.position.x += wobbleX;
                    dot.position.y += wobbleY;
                });
                lines.forEach(line => {
                    const dot1 = line.dot1;
                    const dot2 = line.dot2;
                    if (dot1 && dot2) {
                        disposeObject(line.mesh);
                        const path = new THREE.LineCurve3(dot1.position, dot2.position);
                        const geometry = new THREE.TubeGeometry(path, 32, 0.1, 8, false);
                        line.mesh = new THREE.Mesh(geometry, line.mesh.material);
                        line.mesh.position.z = 0.05;
                        scene.add(line.mesh);
                    }
                });
                boxes.forEach(box => {
                    const x = box.userData.x;
                    const y = box.userData.y;
                    const corners = [
                        dots.find(dot => dot.userData.x === x && dot.userData.y === y),
                        dots.find(dot => dot.userData.x === x + 1 && dot.userData.y === y),
                        dots.find(dot => dot.userData.x === x && dot.userData.y === y + 1),
                        dots.find(dot => dot.userData.x === x + 1 && dot.userData.y === y + 1)
                    ];
                    if (corners.every(corner => corner)) {
                        const avgPosition = new THREE.Vector3();
                        corners.forEach(corner => avgPosition.add(corner.position));
                        avgPosition.multiplyScalar(0.25);
                        box.position.set(avgPosition.x, avgPosition.y, -0.1);
                        if (box.userData.fadeTime >= 1) {
                            const ripple = 0.5 * (Math.sin(wobbleTime + box.userData.ripplePhase) + 1);
                            const scale = 1.0 + 0.1 * ripple;
                            box.scale.set(scale, scale, 1);
                            box.material.opacity = 0.4 + 0.2 * ripple;
                        }
                    }
                });
                if (yellowOverlayDot && selectedDot) {
                    yellowOverlayDot.position.copy(selectedDot.position);
                    yellowOverlayDot.position.z = 0.01;
                }
                if (hintEnabled && bestHintMove && hintLine) {
                    const [dot1, dot2] = bestHintMove;
                    if (dot1 && dot2) {
                        disposeObject(hintLine);
                        const path = new THREE.LineCurve3(dot1.position, dot2.position);
                        const geometry = new THREE.TubeGeometry(path, 32, 0.1, 8, false);
                        hintLine = new THREE.Mesh(geometry, hintTubeMaterial.clone());
                        hintLine.position.z = 0.04;
                        scene.add(hintLine);
                    }
                }
            }
            function updateThrob() {
                throbTime += 0.05;
                const scale = 1 + 0.1 * Math.sin(throbTime);
                const flashOpacity = 0.3 + 0.7 * (Math.sin(throbTime * 2) + 1) / 2;
                dots.forEach(dot => {
                    if (dot.userData.isValid) {
                        dot.scale.set(1.2 * scale, 1.2 * scale, 1.2 * scale);
                        dot.material.opacity = flashOpacity;
                        dot.material.transparent = true;
                    } else {
                        dot.material.opacity = 1;
                        dot.material.transparent = false;
                    }
                });
                if (yellowOverlayDot) {
                    yellowOverlayDot.scale.set(scale, scale, scale);
                }
                flashingLines = flashingLines.filter(flash => {
                    flash.time += 0.05;
                    const opacity = 0.3 + 0.7 * (Math.sin(flash.time * 8) + 1) / 2;
                    flash.line.material.opacity = opacity;
                    if (flash.flashes < 3 && flash.time > 0.5) {
                        flash.flashes++;
                        flash.time = 0;
                    }
                    if (flash.flashes >= 3) {
                        flash.line.material.opacity = 1;
                        flash.line.material.transparent = false;
                        return false;
                    }
                    return true;
                });
                boxes.forEach(box => {
                    if (box.userData.fadeTime < 1) {
                        box.userData.fadeTime += 0.05;
                        box.material.opacity = Math.min(0.5, box.userData.fadeTime);
                    }
                });
                for (let i = 0; i < starOpacities.length; i++) {
                    starOpacities[i] = Math.random() * 0.5 + 0.5;
                }
                starGeometry.attributes.opacity.needsUpdate = true;
            }
            function updateCamera() {
                if ((isFlyCamera && (gameActive || (document.getElementById('game-over') && document.getElementById('game-over').style.display === 'flex'))) || isWelcomeScreen) {
                    cameraTime += 0.01;
                    const radius = 12;
                    camera.position.x = Math.sin(cameraTime) * radius;
                    camera.position.z = Math.cos(cameraTime) * radius;
                    camera.position.y = Math.sin(cameraTime * 0.5) * 2;
                    camera.lookAt(0, 0, 0);
                }
            }
            function updatePreviewLine() {
                if (previewLine && selectedDot) {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(dots);
                    const validIntersects = intersects
                        .filter(intersect => isValidConnection(selectedDot, intersect.object))
                        .sort((a, b) => a.distance - b.distance);
                    const targetDot = validIntersects[0];
                    const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                    const intersectPoint = new THREE.Vector3();
                    raycaster.ray.intersectPlane(plane, intersectPoint);
                    const endPoint = targetDot ? targetDot.object.position : intersectPoint;
                    disposeObject(previewLine);
                    const path = new THREE.LineCurve3(selectedDot.position, endPoint);
                    const geometry = new THREE.TubeGeometry(path, 32, 0.1, 8, false);
                    const tubeMaterial = currentPlayer === 'red' ? redTubeMaterial.clone() : blueTubeMaterial.clone();
                    previewLine = new THREE.Mesh(geometry, tubeMaterial);
                    previewLine.position.z = 0.05;
                    scene.add(previewLine);
                }
            }
            camera.position.z = 12;
            function animate() {
                requestAnimationFrame(animate);
                if (gameActive || isWelcomeScreen || (document.getElementById('game-over') && document.getElementById('game-over').style.display === 'flex')) {
                    updateThrob();
                    updateCamera();
                    if (gameActive) {
                        updateWobble();
                        const now = Date.now();
                        if (now - lastIdleReminder > 10000 && gameActive && (gameMode !== 'ai' && (gameMode !== '1player' || currentPlayer === 'red'))) {
                            lastIdleReminder = now;
                            const statsElement = document.getElementById(currentPlayer === 'red' ? 'red-stats' : 'blue-stats');
                            if (statsElement) {
                                statsElement.classList.add('flash');
                                setTimeout(() => statsElement.classList.remove('flash'), 1500);
                            }
                            showMessage(`${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s Turn!`, true);
                        }
                    }
                }
                renderer.render(scene, camera);
            }
            animate();
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        });
    </script>
</body>
</html>
