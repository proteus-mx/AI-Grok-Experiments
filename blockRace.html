<!DOCTYPE html>
<html lang="en" style="overflow: hidden;">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Race 2 Player</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { display: flex; flex-direction: column; align-items: center; font-family: 'Orbitron', sans-serif; background: #f0f0f0; margin: 0; padding: 20px; overflow: hidden; transition: background 0.3s, color 0.3s; }
        body.dark-mode { background: #121212; color: #f0f0f0; }
        #welcome-screen { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; background: linear-gradient(to bottom, #f0f0f0, #d0d0d0); transition: background 0.3s; }
        body.dark-mode #welcome-screen { background: linear-gradient(to bottom, #333, #222); }
        #welcome-screen h1 { font-size: 60px; margin-bottom: 20px; text-shadow: 0 0 10px #0074D9, 0 0 20px #0056b3; color: #0074D9; font-weight: 700; animation: glow 2s infinite alternate; }
        body.dark-mode #welcome-screen h1 { color: #3399ff; text-shadow: 0 0 10px #3399ff, 0 0 20px #0066cc; }
        @keyframes glow { from { text-shadow: 0 0 10px #0074D9, 0 0 20px #0056b3; } to { text-shadow: 0 0 20px #0074D9, 0 0 30px #0056b3; } }
        #welcome-screen p { font-size: 24px; margin-bottom: 20px; color: #333; }
        body.dark-mode #welcome-screen p { color: #ccc; }
        #welcome-screen button { padding: 15px 30px; font-size: 20px; margin: 15px 0; background: linear-gradient(#0074D9, #0056b3); border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.3); transition: transform 0.2s, background 0.3s; color: white; position: relative; overflow: hidden; }
        body.dark-mode #welcome-screen button { background: linear-gradient(#3399ff, #0066cc); box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        #welcome-screen button:hover { transform: scale(1.05); background: linear-gradient(#0056b3, #003f8a); }
        body.dark-mode #welcome-screen button:hover { background: linear-gradient(#0066cc, #003366); }
        #welcome-screen button.highlight { background: linear-gradient(#FFDC00, #cc9900); color: #333; }
        body.dark-mode #welcome-screen button.highlight { background: linear-gradient(#FFDC00, #cc9900); color: #333; }
        #welcome-screen button.highlight .progressbar { position: absolute; top: 0; left: 0; height: 100%; background: rgba(0,0,0,0.2); transition: width 1s linear; }
        #countdown { font-size: 48px; color: #FF4136; margin-top: 20px; }
        body.dark-mode #countdown { color: #FF4136; }
        #toggle-theme { padding: 10px 20px; font-size: 16px; margin-top: 10px; }
        #game-container { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 20px; display: none; }
        #pattern-container { display: flex; flex-direction: column; align-items: center; }
        #pattern { display: grid; grid-template-columns: repeat(3, 20px); gap: 1px; border: 2px solid #333; background: #fff; padding: 3px; border-radius: 6px; margin-bottom: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        body.dark-mode #pattern { background: #444; border-color: #666; }
        #board1, #board2 { display: grid; grid-template-columns: repeat(5, 40px); gap: 3px; border: 5px groove #666; background: linear-gradient(135deg, #eee, #ccc); padding: 8px; border-radius: 15px; box-shadow: 0 4px 10px rgba(0,0,0,0.3); position: relative; }
        body.dark-mode #board1, body.dark-mode #board2 { background: linear-gradient(135deg, #333, #222); border-color: #888; }
        .tile { width: 40px; height: 40px; border-radius: 10px; box-shadow: inset 0 2px 2px rgba(255,255,255,0.6), 0 3px 6px rgba(0,0,0,0.4); transition: transform 0.2s ease-in-out; user-select: none; border: 1px solid rgba(0,0,0,0.1); will-change: transform; }
        #pattern .tile { width: 20px; height: 20px; border-radius: 5px; box-shadow: inset 0 1px 1px rgba(255,255,255,0.6), 0 1px 3px rgba(0,0,0,0.3); }
        .tile:active { transform: scale(0.92); box-shadow: inset 0 1px 1px rgba(255,255,255,0.4), 0 2px 4px rgba(0,0,0,0.5); }
        .empty { background: rgba(0,0,0,0.05); box-shadow: inset 0 2px 4px rgba(0,0,0,0.2); border: none; }
        body.dark-mode .empty { background: rgba(255,255,255,0.05); box-shadow: inset 0 2px 4px rgba(255,255,255,0.1); }
        .red { background: linear-gradient(145deg, #ff5a50, #cc0000); }
        .green { background: linear-gradient(145deg, #3fff3f, #009900); }
        .blue { background: linear-gradient(145deg, #3399ff, #003399); }
        .yellow { background: linear-gradient(145deg, #ffff66, #cc9900); }
        .white { background: linear-gradient(145deg, #ffffff, #dddddd); border: 1px solid #bbb; }
        body.dark-mode .white { background: linear-gradient(145deg, #dddddd, #bbbbbb); border-color: #999; }
        .orange { background: linear-gradient(145deg, #ffaa55, #cc5200); }
        #stats1, #stats2 { font-size: 16px; margin: 10px 0; display: flex; flex-direction: column; gap: 5px; align-items: center; }
        #controls1, #controls2 { margin: 5px 0; display: flex; gap: 5px; }
        button { padding: 6px 12px; margin: 3px; background: linear-gradient(#0074D9, #0056b3); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 12px; box-shadow: 0 1px 3px rgba(0,0,0,0.2); transition: background 0.3s; }
        body.dark-mode button { background: linear-gradient(#3399ff, #0066cc); }
        button:hover { background: linear-gradient(#0056b3, #003f8a); }
        body.dark-mode button:hover { background: linear-gradient(#0066cc, #003366); }
        #randomize-pattern { padding: 5px 10px; font-size: 12px; }
        #gameover {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: #2ECC40;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 24px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        body.dark-mode #gameover { background: rgba(255, 255, 255, 0.1); color: #3fff3f; }
        #thinking {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 20px;
        }
        body.dark-mode #thinking { background: rgba(255, 255, 255, 0.1); }
        #randomizing { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.7); color: white; padding: 15px; border-radius: 8px; font-size: 20px; }
        body.dark-mode #randomizing { background: rgba(255, 255, 255, 0.1); }
        #solution {
            margin-top: 20px;
            max-height: 150px;
            overflow-y: auto;
            width: 80%;
            max-width: 300px;
            background: #fff;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: none;
        }
        body.dark-mode #solution { background: #333; color: #f0f0f0; }
        #solution p { margin: 5px 0; font-size: 14px; }
        #difficulty1, #difficulty2 {
            width: 100%;
            max-width: 200px;
            text-align: left;
        }
        #difficulty-bar1, #difficulty-bar2 {
            height: 15px;
            border-radius: 5px;
            background: #ccc;
            overflow: hidden;
        }
        body.dark-mode #difficulty-bar1, body.dark-mode #difficulty-bar2 { background: #555; }
        #difficulty-fill1, #difficulty-fill2 {
            height: 100%;
            transition: width 0.3s;
        }
        .easy { background: #2ECC40; }
        .medium { background: #FFDC00; }
        .hard { background: #FF4136; }
        .hint { animation: flash 0.5s infinite alternate; }
        @keyframes flash { from { box-shadow: 0 0 15px red; } to { box-shadow: 0 0 25px red; } }
        .player-label { font-size: 20px; font-weight: 700; margin-bottom: 5px; color: #0074D9; text-shadow: 1px 1px 2px rgba(0,0,0,0.2); }
        body.dark-mode .player-label { color: #3399ff; text-shadow: 1px 1px 2px rgba(0,0,0,0.4); }
        .large-board #game-container { margin-top: 80px; }
        .large-board #board1 { grid-template-columns: repeat(5, 60px); gap: 4px; border: 6px groove #666; padding: 10px; border-radius: 20px; }
        body.dark-mode .large-board #board1 { border-color: #888; }
        .large-board .tile { width: 60px; height: 60px; border-radius: 15px; box-shadow: inset 0 3px 3px rgba(255,255,255,0.6), 0 4px 8px rgba(0,0,0,0.4); }
        .large-board #pattern { grid-template-columns: repeat(3, 30px); gap: 2px; border: 3px solid #333; padding: 4px; border-radius: 9px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        body.dark-mode .large-board #pattern { border-color: #666; background: #444; }
        .large-board #pattern .tile { width: 30px; height: 30px; border-radius: 7px; box-shadow: inset 0 1px 1px rgba(255,255,255,0.6), 0 2px 4px rgba(0,0,0,0.3); }
    </style>
</head>
<body class="dark-mode">
    <div id="welcome-screen">
        <h1>Block Race</h1>
        <p>Choose your game mode:</p>
        <button class="highlight" onclick="startGame('easy', 1)">1 Player - Easy<div class="progressbar" style="width: 100%;"></div></button>
        <button onclick="startGame('hard', 1)">1 Player - Hard</button>
        <button onclick="startGame('easy', 2)">2 Player - Easy</button>
        <button onclick="startGame('hard', 2)">2 Player - Hard</button>
        <button id="toggle-theme">Toggle Theme</button>
        <div id="countdown"></div>
    </div>
    <div id="game-container">
        <div id="player1">
            <div class="player-label">Player 1</div>
            <div id="stats1">
                <div>
                    <span id="timer1">Time: 0s</span>
                    <span id="moves1">Moves: 0</span>
                    <span id="points1">Points: 0</span>
                </div>
                <div id="difficulty1">
                    <p>Difficulty: <span id="move-count1">0</span> moves</p>
                    <div id="difficulty-bar1">
                        <div id="difficulty-fill1"></div>
                    </div>
                </div>
            </div>
            <div id="board1"></div>
            <div id="controls1">
                <button onclick="hint(1)">Hint</button>
                <button onclick="autoComplete(1)">Auto Solve</button>
                <button onclick="showSolution(1)">Show Solution</button>
            </div>
        </div>
        <div id="pattern-container">
            <div id="pattern"></div>
            <button id="randomize-pattern" onclick="randomizePattern()">Randomize Pattern</button>
        </div>
        <div id="player2" style="display: none;">
            <div class="player-label">Player 2</div>
            <div id="stats2">
                <div>
                    <span id="timer2">Time: 0s</span>
                    <span id="moves2">Moves: 0</span>
                    <span id="points2">Points: 0</span>
                </div>
                <div id="difficulty2">
                    <p>Difficulty: <span id="move-count2">0</span> moves</p>
                    <div id="difficulty-bar2">
                        <div id="difficulty-fill2"></div>
                    </div>
                </div>
            </div>
            <div id="board2"></div>
            <div id="controls2">
                <button id="hint2" onclick="hint(2)">Hint</button>
                <button id="auto2" onclick="autoComplete(2)">Auto Solve</button>
                <button onclick="showSolution(2)">Show Solution</button>
            </div>
        </div>
    </div>
    <div id="solution"></div>
    <div id="gameover">
        <span id="winner"></span> Wins!<br>
        Time: <span id="wintime"></span>s<br>
        Moves: <span id="winmoves"></span><br>
        Points: <span id="winpoints"></span><br>
        <button onclick="newGame(currentMode, playerCount)">Play Again</button>
    </div>
    <div id="thinking">Thinking...</div>
    <div id="randomizing">Randomizing...</div>
    <script>
        const colors = ['red', 'green', 'blue', 'yellow', 'white', 'orange'];
        let board1 = [], board2 = [];
        let emptyPos1 = {x: 0, y: 0}, emptyPos2 = {x: 0, y: 0};
        let pattern = [];
        let startTime;
        let timerInterval1, timerInterval2;
        let moveCount1 = 0, moveCount2 = 0;
        let points1 = 0, points2 = 0;
        let gamesPlayed1 = 0, gamesPlayed2 = 0;
        let gamesWon1 = 0, gamesWon2 = 0;
        let initialMoveCount1 = 0, initialMoveCount2 = 0;
        let gameWon = false;
        let autoSolving = false;
        let currentMode = 'easy';
        let playerCount = 1;
        let currentPlayer = 1;
        let draggedTile = null;
        let dragStartX = 0, dragStartY = 0;
        let dragDirection = null;
        let movingTiles = [];
        let dragDx = 0, dragDy = 0;
        let countdownInterval;
        function initBoard(mode, player) {
            let tiles = [];
            colors.forEach(c => { for(let i=0; i<4; i++) tiles.push(c); });
            tiles.push(null);
           
            let board, moveCount;
            let attempts = 0;
            const maxAttempts = 10;
            if (mode === 'easy') {
                do {
                    board = Array.from({length: 5}, () => Array(5).fill(null));
                    for (let y = 0; y < 3; y++) {
                        for (let x = 0; x < 3; x++) {
                            board[y + 1][x + 1] = pattern[y][x] || null;
                        }
                    }
                    let remaining = {};
                    colors.forEach(c => remaining[c] = 4);
                    pattern.flat().forEach(c => { if (c) remaining[c]--; });
                    let outerTiles = [];
                    colors.forEach(c => { for (let i = 0; i < remaining[c]; i++) outerTiles.push(c); });
                    outerTiles.sort(() => Math.random() - 0.5);
                    let outerPos = [];
                    for (let y = 0; y < 5; y++) {
                        for (let x = 0; x < 5; x++) {
                            if (y >= 1 && y <= 3 && x >= 1 && x <= 3) continue;
                            outerPos.push({x, y});
                        }
                    }
                    let tileIdx = 0;
                    let emptyIdx = Math.floor(Math.random() * outerPos.length);
                    for (let i = 0; i < outerPos.length; i++) {
                        let pos = outerPos[i];
                        if (i === emptyIdx) {
                            board[pos.y][pos.x] = null;
                            if (player === 1) emptyPos1 = {x: pos.x, y: pos.y};
                            else emptyPos2 = {x: pos.x, y: pos.y};
                        } else {
                            board[pos.y][pos.x] = outerTiles[tileIdx++] || null;
                        }
                    }
                    for (let i = 0; i < 10; i++) {
                        let moves = getPossibleMoves(player === 1 ? emptyPos1 : emptyPos2);
                        let move = moves[Math.floor(Math.random() * moves.length)];
                        if (move) moveRowOrColumn(move.x, move.y, move.dx, move.dy, false, player, board);
                    }
                    moveCount = planSolutionSync(board, player === 1 ? emptyPos1 : emptyPos2).length;
                    attempts++;
                } while ((moveCount < 5 || moveCount > 15) && attempts < maxAttempts);
            } else {
                do {
                    tiles.sort(() => Math.random() - 0.5);
                    board = [];
                    for (let y = 0; y < 5; y++) {
                        board[y] = [];
                        for (let x = 0; x < 5; x++) {
                            board[y][x] = tiles[y * 5 + x];
                            if (!board[y][x]) {
                                if (player === 1) emptyPos1 = {x, y};
                                else emptyPos2 = {x, y};
                            }
                        }
                    }
                    moveCount = planSolutionSync(board, player === 1 ? emptyPos1 : emptyPos2).length;
                    attempts++;
                } while ((moveCount < 15 || moveCount >= 100) && attempts < maxAttempts);
            }
            if (attempts >= maxAttempts || moveCount === 0) {
                board = Array.from({length: 5}, () => Array(5).fill(null));
                for (let y = 0; y < 3; y++) {
                    for (let x = 0; x < 3; x++) {
                        board[y + 1][x + 1] = pattern[y][x] || null;
                    }
                }
                let remaining = {};
                colors.forEach(c => remaining[c] = 4);
                pattern.flat().forEach(c => { if (c) remaining[c]--; });
                let outerTiles = [];
                colors.forEach(c => { for (let i = 0; i < remaining[c]; i++) outerTiles.push(c); });
                outerTiles.sort(() => Math.random() - 0.5);
                let outerPos = [];
                for (let y = 0; y < 5; y++) {
                    for (let x = 0; x < 5; x++) {
                        if (y >= 1 && y <= 3 && x >= 1 && x <= 3) continue;
                        outerPos.push({x, y});
                    }
                }
                let tileIdx = 0;
                let emptyIdx = Math.floor(Math.random() * outerPos.length);
                for (let i = 0; i < outerPos.length; i++) {
                    let pos = outerPos[i];
                    if (i === emptyIdx) {
                        board[pos.y][pos.x] = null;
                        if (player === 1) emptyPos1 = {x: pos.x, y: pos.y};
                        else emptyPos2 = {x: pos.x, y: pos.y};
                    } else {
                        board[pos.y][pos.x] = outerTiles[tileIdx++] || null;
                    }
                }
                let targetMoves = mode === 'easy' ? 10 : 20;
                for (let i = 0; i < targetMoves; i++) {
                    let moves = getPossibleMoves(player === 1 ? emptyPos1 : emptyPos2);
                    let move = moves[Math.floor(Math.random() * moves.length)];
                    if (move) moveRowOrColumn(move.x, move.y, move.dx, move.dy, false, player, board);
                }
                moveCount = planSolutionSync(board, player === 1 ? emptyPos1 : emptyPos2).length;
                if (moveCount === 0) return initBoard(mode, player);
            }
            if (player === 1) initialMoveCount1 = moveCount || 0;
            else initialMoveCount2 = moveCount || 0;
            return board;
        }
        function generatePattern() {
            let attempts = 0;
            const maxAttempts = 10;
            let moveCount1, moveCount2;
            do {
                pattern = [];
                for (let y = 0; y < 3; y++) {
                    pattern[y] = [];
                    for (let x = 0; x < 3; x++) {
                        pattern[y][x] = colors[Math.floor(Math.random() * colors.length)];
                    }
                }
                let counts = {};
                pattern.flat().forEach(c => counts[c] = (counts[c] || 0) + 1);
                if (Object.values(counts).some(v => v > 4)) continue;
                let tempBoard1 = initBoard(currentMode, 1);
                moveCount1 = planSolutionSync(tempBoard1, emptyPos1).length;
                if (playerCount === 2) {
                    let tempBoard2 = initBoard(currentMode, 2);
                    moveCount2 = planSolutionSync(tempBoard2, emptyPos2).length;
                } else {
                    moveCount2 = moveCount1;
                }
                attempts++;
            } while ((moveCount1 === 0 || (playerCount === 2 && moveCount2 === 0)) && attempts < maxAttempts);
            if (attempts >= maxAttempts) generatePattern();
        }
        async function randomizePattern() {
            const randomizing = document.getElementById('randomizing');
            if (randomizing) randomizing.style.display = 'block';
            generatePattern();
            renderPattern();
            const solution = document.getElementById('solution');
            const difficulty1 = document.getElementById('difficulty1');
            const difficulty2 = document.getElementById('difficulty2');
            if (solution) solution.style.display = 'none';
            if (difficulty1) difficulty1.style.display = 'none';
            if (playerCount === 2 && difficulty2) difficulty2.style.display = 'none';
            board1 = initBoard(currentMode, 1);
            if (playerCount === 2) board2 = initBoard(currentMode, 2);
            renderBoard(1);
            if (playerCount === 2) renderBoard(2);
            startTime = Date.now();
            clearInterval(timerInterval1);
            clearInterval(timerInterval2);
            timerInterval1 = setInterval(() => updateTimer(1), 1000);
            if (playerCount === 2) timerInterval2 = setInterval(() => updateTimer(2), 1000);
            moveCount1 = 0;
            moveCount2 = 0;
            gameWon = false;
            updateMoves(1);
            if (playerCount === 2) updateMoves(2);
            updateTimer(1);
            if (playerCount === 2) updateTimer(2);
            await updateDifficulty(1);
            if (playerCount === 2) await updateDifficulty(2);
            if (randomizing) randomizing.style.display = 'none';
        }
        function isSolvableWithin(maxMoves, board, emptyPos) {
            if (!board || !emptyPos) return false;
            const queue = [{board: board.map(row => [...row]), emptyPos: {...emptyPos}, moves: 0}];
            const seenStates = new Set([JSON.stringify(board)]);
            const maxStates = 10000;
            let statesExplored = 0;
            while (queue.length > 0 && statesExplored < maxStates && queue[0].moves < maxMoves) {
                const {board: currentBoard, emptyPos: currentEmpty, moves} = queue.shift();
                if (!currentBoard || !currentEmpty) continue;
                if (isSolved(currentBoard)) return true;
                const possibleMoves = getPossibleMoves(currentEmpty);
                for (const move of possibleMoves) {
                    const newBoard = currentBoard.map(row => [...row]);
                    const newEmpty = {...currentEmpty};
                    const tx = move.x;
                    const ty = move.y;
                    const dx = move.dx;
                    const dy = move.dy;
                    if (dx !== 0) {
                        let row = newBoard[ty];
                        let emptyIndex = row.indexOf(null);
                        if (emptyIndex === -1 || (dx > 0 && tx >= emptyIndex) || (dx < 0 && tx <= emptyIndex)) continue;
                        if (dx > 0) {
                            for (let x = emptyIndex; x > tx; x--) row[x] = row[x - 1];
                        } else {
                            for (let x = emptyIndex; x < tx; x++) row[x] = row[x + 1];
                        }
                        row[tx] = null;
                        newEmpty.x = tx;
                    } else {
                        let column = newBoard.map(row => row[tx]);
                        let emptyIndex = column.indexOf(null);
                        if (emptyIndex === -1 || (dy > 0 && ty >= emptyIndex) || (dy < 0 && ty <= emptyIndex)) continue;
                        if (dy > 0) {
                            for (let y = emptyIndex; y > ty; y--) newBoard[y][tx] = newBoard[y - 1][tx];
                        } else {
                            for (let y = emptyIndex; y < ty; y++) newBoard[y][tx] = newBoard[y + 1][tx];
                        }
                        newBoard[ty][tx] = null;
                        newEmpty.y = ty;
                    }
                    const boardState = JSON.stringify(newBoard);
                    if (!seenStates.has(boardState)) {
                        seenStates.add(boardState);
                        queue.push({
                            board: newBoard,
                            emptyPos: newEmpty,
                            moves: moves + 1
                        });
                        statesExplored++;
                    }
                }
            }
            return false;
        }
        function renderBoard(player) {
            const boardDiv = document.getElementById(`board${player}`);
            const board = player === 1 ? board1 : board2;
            if (!boardDiv || !board) return;
            boardDiv.innerHTML = '';
            for (let y = 0; y < 5; y++) {
                for (let x = 0; x < 5; x++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile ' + (board[y][x] || 'empty');
                    tile.dataset.x = x;
                    tile.dataset.y = y;
                    tile.dataset.player = player;
                    if (!autoSolving) {
                        tile.addEventListener('touchstart', handleTouchStart, {passive: false});
                        tile.addEventListener('touchmove', handleTouchMove, {passive: false});
                        tile.addEventListener('touchend', handleTouchEnd, {passive: false});
                    }
                    boardDiv.appendChild(tile);
                }
            }
        }
        function renderPattern() {
            const patDiv = document.getElementById('pattern');
            if (!patDiv) return;
            patDiv.innerHTML = '';
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile ' + (pattern[y][x] || 'empty');
                    patDiv.appendChild(tile);
                }
            }
        }
        let touchStartX, touchStartY;
        function handleTouchStart(e) {
            if (e.target.classList.contains('empty')) return;
            if (isAnimating) return;
            draggedTile = e.target;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            dragDirection = null;
            movingTiles = [];
            dragDx = 0;
            dragDy = 0;
        }
        function handleTouchMove(e) {
            if (!draggedTile) return;
            e.preventDefault();
            dragDx = e.touches[0].clientX - touchStartX;
            dragDy = e.touches[0].clientY - touchStartY;
            if (!dragDirection && (Math.abs(dragDx) > 20 || Math.abs(dragDy) > 20)) {
                dragDirection = Math.abs(dragDx) > Math.abs(dragDy) ? 'horizontal' : 'vertical';
                const x = parseInt(draggedTile.dataset.x);
                const y = parseInt(draggedTile.dataset.y);
                const player = parseInt(draggedTile.dataset.player);
                const empty = player === 1 ? emptyPos1 : emptyPos2;
                const sign = dragDirection === 'horizontal' ? (dragDx > 0 ? 1 : -1) : (dragDy > 0 ? 1 : -1);
                if (dragDirection === 'horizontal') {
                    if (y !== empty.y) {
                        dragDirection = null;
                        return;
                    }
                    if ((sign > 0 && x >= empty.x) || (sign < 0 && x <= empty.x)) {
                        dragDirection = null;
                        return;
                    }
                    const min = Math.min(x, empty.x);
                    const max = Math.max(x, empty.x);
                    const tiles = document.querySelectorAll(`#board${player} .tile`);
                    for (let pos = min + 1; pos <= max; pos++) {
                        movingTiles.push(tiles[y * 5 + pos]);
                    }
                } else {
                    if (x !== empty.x) {
                        dragDirection = null;
                        return;
                    }
                    if ((sign > 0 && y >= empty.y) || (sign < 0 && y <= empty.y)) {
                        dragDirection = null;
                        return;
                    }
                    const min = Math.min(y, empty.y);
                    const max = Math.max(y, empty.y);
                    const tiles = document.querySelectorAll(`#board${player} .tile`);
                    for (let pos = min + 1; pos <= max; pos++) {
                        movingTiles.push(tiles[pos * 5 + x]);
                    }
                }
            }
            if (dragDirection) {
                const tileSize = draggedTile.offsetWidth;
                let delta = dragDirection === 'horizontal' ? dragDx : dragDy;
                const maxDelta = tileSize * (delta > 0 ? 1 : -1);
                delta = delta > 0 ? Math.min(delta, tileSize) : Math.max(delta, -tileSize);
                movingTiles.forEach(tile => {
                    tile.style.transition = 'none';
                    tile.style.transform = dragDirection === 'horizontal' ? `translateX(${delta}px)` : `translateY(${delta}px)`;
                });
            }
        }
        function handleTouchEnd(e) {
            if (!draggedTile || !dragDirection) {
                draggedTile = null;
                return;
            }
            const tileSize = draggedTile.offsetWidth;
            let delta = dragDirection === 'horizontal' ? dragDx : dragDy;
            const half = tileSize / 2;
            const complete = Math.abs(delta) > half;
            const targetDelta = complete ? (delta > 0 ? tileSize : -tileSize) : 0;
            movingTiles.forEach(tile => {
                tile.style.transition = 'transform 0.2s';
                tile.style.transform = dragDirection === 'horizontal' ? `translateX(${targetDelta}px)` : `translateY(${targetDelta}px)`;
            });
            setTimeout(() => {
                movingTiles.forEach(tile => {
                    tile.style.transition = '';
                    tile.style.transform = '';
                });
                if (complete) {
                    const x = parseInt(draggedTile.dataset.x);
                    const y = parseInt(draggedTile.dataset.y);
                    const player = parseInt(draggedTile.dataset.player);
                    const dx = dragDirection === 'horizontal' ? (delta > 0 ? 1 : -1) : 0;
                    const dy = dragDirection === 'vertical' ? (delta > 0 ? 1 : -1) : 0;
                    moveRowOrColumn(x, y, dx, dy, true, player);
                }
                draggedTile = null;
                dragDirection = null;
                movingTiles = [];
            }, 200);
        }
        function moveRowOrColumn(tx, ty, dx, dy, update = true, player = 1, targetBoard = null) {
            const board = targetBoard || (player === 1 ? board1 : board2);
            const emptyPos = player === 1 ? emptyPos1 : emptyPos2;
            if (!board || !emptyPos) return false;
            if (dx !== 0) {
                let row = board[ty];
                let emptyIndex = row.indexOf(null);
                if (emptyIndex === -1) return false;
                let startIndex = tx;
                let endIndex = emptyIndex;
                if (dx > 0 && startIndex >= emptyIndex) return false;
                if (dx < 0 && startIndex <= emptyIndex) return false;
                if (dx > 0) {
                    for (let x = emptyIndex; x > startIndex; x--) {
                        row[x] = row[x - 1];
                    }
                } else {
                    for (let x = emptyIndex; x < startIndex; x++) {
                        row[x] = row[x + 1];
                    }
                }
                row[startIndex] = null;
                emptyPos.x = startIndex;
            } else {
                let column = board.map(row => row[tx]);
                let emptyIndex = column.indexOf(null);
                if (emptyIndex === -1) return false;
                let startIndex = ty;
                if (dy > 0 && startIndex >= emptyIndex) return false;
                if (dy < 0 && startIndex <= emptyIndex) return false;
                if (dy > 0) {
                    for (let y = emptyIndex; y > startIndex; y--) {
                        board[y][tx] = board[y - 1][tx];
                    }
                } else {
                    for (let y = emptyIndex; y < startIndex; y++) {
                        board[y][tx] = board[y + 1][tx];
                    }
                }
                board[startIndex][tx] = null;
                emptyPos.y = startIndex;
            }
            if (update && !gameWon) {
                if (player === 1) moveCount1++;
                else moveCount2++;
                updateMoves(player);
                renderBoard(player);
                if (checkWin(player)) return true;
                updateDifficulty(player);
            }
            return true;
        }
        function updateMoves(player) {
            const moveCount = player === 1 ? moveCount1 : moveCount2;
            const board = player === 1 ? board1 : board2;
            const emptyPos = player === 1 ? emptyPos1 : emptyPos2;
            const optimalMoves = board ? planSolutionSync(board, player).length : 0;
            const points = player === 1 ? points1 : points2;
            const movesElement = document.getElementById(`moves${player}`);
            const pointsElement = document.getElementById(`points${player}`);
            if (movesElement) movesElement.innerText = `Moves: ${moveCount} (${optimalMoves})`;
            if (pointsElement) pointsElement.innerText = `Points: ${points}`;
        }
        function checkWin(player) {
            if (gameWon) return false;
            const board = player === 1 ? board1 : board2;
            if (!board) return false;
            let match = true;
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    if (board[y + 1][x + 1] !== (pattern[y][x] || null)) match = false;
                }
            }
            if (match) {
                gameWon = true;
                clearInterval(timerInterval1);
                if (playerCount === 2) clearInterval(timerInterval2);
                const time = Math.floor((Date.now() - startTime) / 1000);
                const pointsEarned = player === 1 ? (initialMoveCount1 || 0) : (initialMoveCount2 || 0);
                if (player === 1) {
                    points1 += pointsEarned;
                    gamesWon1++;
                    gamesPlayed1++;
                    if (playerCount === 2) gamesPlayed2++;
                } else {
                    points2 += pointsEarned;
                    gamesWon2++;
                    gamesPlayed2++;
                    gamesPlayed1++;
                }
                const gameover = document.getElementById('gameover');
                const winner = document.getElementById('winner');
                const wintime = document.getElementById('wintime');
                const winmoves = document.getElementById('winmoves');
                const winpoints = document.getElementById('winpoints');
                if (winner) winner.innerText = `Player ${player}`;
                if (wintime) wintime.innerText = time;
                if (winmoves) winmoves.innerText = player === 1 ? moveCount1 : moveCount2;
                if (winpoints) winpoints.innerText = pointsEarned;
                if (gameover) gameover.style.display = 'block';
                const thinking = document.getElementById('thinking');
                const solution = document.getElementById('solution');
                const difficulty1 = document.getElementById('difficulty1');
                const difficulty2 = document.getElementById('difficulty2');
                if (thinking) thinking.style.display = 'none';
                if (solution) solution.style.display = 'none';
                if (difficulty1) difficulty1.style.display = 'none';
                if (playerCount === 2 && difficulty2) difficulty2.style.display = 'none';
                updateMoves(1);
                if (playerCount === 2) updateMoves(2);
                autoSolving = false;
            }
            return match;
        }
        function updateTimer(player) {
            const time = Math.floor((Date.now() - startTime) / 1000);
            const timerElement = document.getElementById(`timer${player}`);
            if (timerElement) timerElement.innerText = `Time: ${time}s`;
        }
        async function updateDifficulty(player) {
            const thinking = document.getElementById('thinking');
            if (thinking) thinking.style.display = 'block';
            const moveSequence = await planSolution(player);
            if (thinking) thinking.style.display = 'none';
            const moveCount = moveSequence.length;
            const moveCountElement = document.getElementById(`move-count${player}`);
            const bar = document.getElementById(`difficulty-fill${player}`);
            const difficultyElement = document.getElementById(`difficulty${player}`);
            if (moveCountElement) moveCountElement.innerText = moveCount;
            if (bar) {
                const maxMoves = 100;
                const width = Math.min((moveCount / maxMoves) * 100, 100);
                bar.style.width = `${width}%`;
                bar.className = moveCount <= 10 ? 'easy' : moveCount <= 50 ? 'medium' : 'hard';
            }
            if (difficultyElement) difficultyElement.style.display = 'block';
        }
        function newGame(mode = currentMode, players = playerCount) {
            currentMode = mode === 'easy' || mode === 'hard' ? mode : 'easy';
            playerCount = players === 1 || players === 2 ? players : 1;
            currentPlayer = 1;
            gameWon = false;
            initialMoveCount1 = 0;
            initialMoveCount2 = 0;
            generatePattern();
            board1 = initBoard(currentMode, 1);
            if (playerCount === 2) board2 = initBoard(currentMode, 2);
            renderBoard(1);
            if (playerCount === 2) {
                renderBoard(2);
                const player2 = document.getElementById('player2');
                const controls2 = document.getElementById('controls2');
                if (player2) player2.style.display = 'block';
                if (controls2) controls2.style.display = 'flex';
            } else {
                const player2 = document.getElementById('player2');
                const controls2 = document.getElementById('controls2');
                const difficulty2 = document.getElementById('difficulty2');
                if (player2) player2.style.display = 'none';
                if (controls2) controls2.style.display = 'none';
                if (difficulty2) difficulty2.style.display = 'none';
            }
            renderPattern();
            startTime = Date.now();
            clearInterval(timerInterval1);
            clearInterval(timerInterval2);
            timerInterval1 = setInterval(() => updateTimer(1), 1000);
            if (playerCount === 2) timerInterval2 = setInterval(() => updateTimer(2), 1000);
            const gameover = document.getElementById('gameover');
            const thinking = document.getElementById('thinking');
            const solution = document.getElementById('solution');
            const difficulty1 = document.getElementById('difficulty1');
            const difficulty2 = document.getElementById('difficulty2');
            const board1Element = document.getElementById('board1');
            const patternElement = document.getElementById('pattern');
            const stats1 = document.getElementById('stats1');
            const welcomeScreen = document.getElementById('welcome-screen');
            const gameContainer = document.getElementById('game-container');
            if (gameover) gameover.style.display = 'none';
            if (thinking) thinking.style.display = 'none';
            if (solution) solution.style.display = 'none';
            if (difficulty1) difficulty1.style.display = 'none';
            if (playerCount === 2 && difficulty2) difficulty2.style.display = 'none';
            if (board1Element) board1Element.style.display = 'grid';
            if (patternElement) patternElement.style.display = 'grid';
            if (stats1) stats1.style.display = 'flex';
            if (welcomeScreen) welcomeScreen.style.display = 'none';
            if (gameContainer) gameContainer.style.display = 'flex';
            moveCount1 = 0;
            moveCount2 = 0;
            gameWon = false;
            updateMoves(1);
            if (playerCount === 2) updateMoves(2);
            updateTimer(1);
            if (playerCount === 2) updateTimer(2);
            autoSolving = false;
            updateDifficulty(1);
            if (playerCount === 2) updateDifficulty(2);
            if (playerCount === 1) {
                document.body.classList.add('large-board');
            } else {
                document.body.classList.remove('large-board');
            }
        }
        async function autoComplete(player) {
            autoSolving = true;
            const thinking = document.getElementById('thinking');
            if (thinking) thinking.style.display = 'block';
            renderBoard(player);
            let moveSequence = await planSolution(player);
            if (thinking) thinking.style.display = 'none';
            if (moveSequence.length > 0) {
                for (const move of moveSequence) {
                    if (!move || gameWon) break;
                    const {x, y, dx, dy} = move || {};
                    if (moveRowOrColumn(x, y, dx, dy, true, player)) {
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                    if (gameWon) return;
                }
            }
            const seenStates = new Set();
            while (!gameWon) {
                const bestMove = getBestMove(player);
                if (!bestMove) {
                    const alternativeMove = getAlternativeMove(player);
                    if (!alternativeMove) break;
                    if (moveRowOrColumn(alternativeMove.x, alternativeMove.y, alternativeMove.dx, alternativeMove.dy, true, player)) {
                        seenStates.add(JSON.stringify(player === 1 ? board1 : board2));
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                } else {
                    const boardState = JSON.stringify(player === 1 ? board1 : board2);
                    if (seenStates.has(boardState)) {
                        const alternativeMove = getAlternativeMove(player);
                        if (!alternativeMove) break;
                        if (moveRowOrColumn(alternativeMove.x, alternativeMove.y, alternativeMove.dx, alternativeMove.dy, true, player)) {
                            seenStates.add(boardState);
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    } else {
                        if (moveRowOrColumn(bestMove.x, bestMove.y, bestMove.dx, bestMove.dy, true, player)) {
                            seenStates.add(boardState);
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }
                }
            }
            autoSolving = false;
            renderBoard(player);
        }
        async function showSolution(player) {
            const thinking = document.getElementById('thinking');
            if (thinking) thinking.style.display = 'block';
            const moveSequence = await planSolution(player);
            if (thinking) thinking.style.display = 'none';
            const solutionDiv = document.getElementById('solution');
            if (!solutionDiv) return;
            solutionDiv.innerHTML = '';
            if (moveSequence.length === 0) {
                solutionDiv.innerHTML = '<p>No solution found within time limit.</p>';
            } else {
                const header = document.createElement('p');
                header.innerText = `Solution for Player ${player}: ${moveSequence.length} moves`;
                solutionDiv.appendChild(header);
                moveSequence.forEach((move, index) => {
                    const {x, y, dx, dy} = move || {};
                    const direction = dx > 0 ? 'right' : dx < 0 ? 'left' : dy > 0 ? 'down' : 'up';
                    const p = document.createElement('p');
                    p.innerText = `${index + 1}. Move tile at (${x},${y}) ${direction}`;
                    solutionDiv.appendChild(p);
                });
            }
            solutionDiv.style.display = 'block';
        }
        function planSolutionSync(board, player) {
            if (!board || !player) return [];
            const startTime = Date.now();
            const maxTime = 5000;
            const emptyPos = player === 1 ? {...emptyPos1} : {...emptyPos2};
            const queue = [{board: board.map(row => [...row]), emptyPos, moves: []}];
            const seenStates = new Set([JSON.stringify(board)]);
            const maxStates = 10000;
            while (queue.length > 0 && (Date.now() - startTime) < maxTime) {
                const {board: currentBoard, emptyPos: currentEmpty, moves} = queue.shift();
                if (!currentBoard || !currentEmpty) continue;
                if (isSolved(currentBoard)) {
                    return moves;
                }
                const possibleMoves = getPossibleMoves(currentEmpty, player);
                for (const move of possibleMoves) {
                    const newBoard = currentBoard.map(row => [...row]);
                    const newEmpty = {...currentEmpty};
                    const tx = move.x;
                    const ty = move.y;
                    const dx = move.dx;
                    const dy = move.dy;
                    if (dx !== 0) {
                        let row = newBoard[ty];
                        let emptyIndex = row.indexOf(null);
                        if (emptyIndex === -1 || (dx > 0 && tx >= emptyIndex) || (dx < 0 && tx <= emptyIndex)) continue;
                        if (dx > 0) {
                            for (let x = emptyIndex; x > tx; x--) row[x] = row[x - 1];
                        } else {
                            for (let x = emptyIndex; x < tx; x++) row[x] = row[x + 1];
                        }
                        row[tx] = null;
                        newEmpty.x = tx;
                    } else {
                        let column = newBoard.map(row => row[tx]);
                        let emptyIndex = column.indexOf(null);
                        if (emptyIndex === -1 || (dy > 0 && ty >= emptyIndex) || (dy < 0 && ty <= emptyIndex)) continue;
                        if (dy > 0) {
                            for (let y = emptyIndex; y > ty; y--) newBoard[y][tx] = newBoard[y - 1][tx];
                        } else {
                            for (let y = emptyIndex; y < ty; y++) newBoard[y][tx] = newBoard[y + 1][tx];
                        }
                        newBoard[ty][tx] = null;
                        newEmpty.y = ty;
                    }
                    const boardState = JSON.stringify(newBoard);
                    if (!seenStates.has(boardState)) {
                        seenStates.add(boardState);
                        queue.push({
                            board: newBoard,
                            emptyPos: newEmpty,
                            moves: [...moves, move]
                        });
                    }
                }
                if (seenStates.size >= maxStates) break;
                queue.sort((a, b) => {
                    const scoreA = getCorrectTileCount(a.board) - a.moves.length / 100;
                    const scoreB = getCorrectTileCount(b.board) - b.moves.length / 100;
                    return scoreB - scoreA;
                });
            }
            return [];
        }
        async function planSolution(player) {
            return new Promise(resolve => {
                resolve(planSolutionSync(player === 1 ? board1 : board2, player));
            });
        }
        function getCorrectTileCount(tempBoard) {
            if (!tempBoard) return 0;
            let correct = 0;
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    if (tempBoard[y + 1][x + 1] === (pattern[y][x] || null)) correct++;
                }
            }
            return correct;
        }
        function getPossibleMoves(empty = emptyPos1, player = 1) {
            const moves = [];
            if (!empty) return moves;
            for (let x = 0; x < 5; x++) {
                if (x !== empty.x) {
                    const dx = x < empty.x ? 1 : -1;
                    moves.push({x, y: empty.y, dx, dy: 0});
                }
            }
            for (let y = 0; y < 5; y++) {
                if (y !== empty.y) {
                    const dy = y < empty.y ? 1 : -1;
                    moves.push({x: empty.x, y, dx: 0, dy});
                }
            }
            return moves;
        }
        function isSolved(board) {
            if (!board) return false;
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    if (board[y + 1][x + 1] !== (pattern[y][x] || null)) return false;
                }
            }
            return true;
        }
        function getBestMove(player) {
            const board = player === 1 ? board1 : board2;
            const empty = player === 1 ? emptyPos1 : emptyPos2;
            if (!board || !empty) return null;
            const moves = getPossibleMoves(empty, player);
            let bestMove = null;
            let bestScore = -Infinity;
            for (const move of moves) {
                const tempBoard = board.map(row => [...row]);
                const tx = move.x;
                const ty = move.y;
                const dx = move.dx;
                const dy = move.dy;
                if (dx !== 0) {
                    let row = tempBoard[ty];
                    let emptyIndex = row.indexOf(null);
                    if (emptyIndex === -1 || (dx > 0 && tx >= emptyIndex) || (dx < 0 && tx <= emptyIndex)) continue;
                    if (dx > 0) {
                        for (let x = emptyIndex; x > tx; x--) row[x] = row[x - 1];
                    } else {
                        for (let x = emptyIndex; x < tx; x++) row[x] = row[x + 1];
                    }
                    row[tx] = null;
                } else {
                    let column = tempBoard.map(row => row[tx]);
                    let emptyIndex = column.indexOf(null);
                    if (emptyIndex === -1 || (dy > 0 && ty >= emptyIndex) || (dy < 0 && ty <= emptyIndex)) continue;
                    if (dy > 0) {
                        for (let y = emptyIndex; y > ty; y--) tempBoard[y][tx] = tempBoard[y - 1][tx];
                    } else {
                        for (let y = emptyIndex; y < ty; y++) tempBoard[y][tx] = tempBoard[y + 1][tx];
                    }
                    tempBoard[ty][tx] = null;
                }
                const score = getCorrectTileCount(tempBoard);
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            return bestMove;
        }
        function getAlternativeMove(player) {
            const empty = player === 1 ? emptyPos1 : emptyPos2;
            const moves = getPossibleMoves(empty, player);
            return moves[Math.floor(Math.random() * moves.length)] || null;
        }
        function hint(player) {
            const tiles = document.querySelectorAll(`#board${player} .tile`);
            tiles.forEach(t => t.classList.remove('hint'));
           
            const bestMove = getBestMove(player);
            if (bestMove) {
                const idx = bestMove.y * 5 + bestMove.x;
                tiles[idx].classList.add('hint');
                setTimeout(() => tiles[idx].classList.remove('hint'), 2000);
            }
        }
        document.getElementById('board1')?.addEventListener('touchend', () => {
            if (!document.getElementById('gameover')?.style.display && !autoSolving) {
                currentPlayer = 1;
                hint(1);
                updateDifficulty(1);
            }
        });
        document.getElementById('board2')?.addEventListener('touchend', () => {
            if (!document.getElementById('gameover')?.style.display && !autoSolving) {
                currentPlayer = 2;
                hint(2);
                updateDifficulty(2);
            }
        });
        function startGame(mode, players) {
            clearInterval(countdownInterval);
            newGame(mode, players);
        }
        window.addEventListener('load', () => {
            let count = 5;
            const countdownElement = document.getElementById('countdown');
            const progressBar = document.querySelector('.highlight .progressbar');
            countdownInterval = setInterval(() => {
                countdownElement.innerText = count;
                progressBar.style.width = `${(count / 5) * 100}%`;
                count--;
                if (count < 0) {
                    clearInterval(countdownInterval);
                    startGame('easy', 1);
                }
            }, 1000);
        });
        document.getElementById('toggle-theme').addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
        });
    </script>
</body>
</html>
