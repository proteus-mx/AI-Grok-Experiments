<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Spiral Starfield</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; color: white; font-family: sans-serif; }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 8px;
    }
    #controls > button {
      display: block;
      margin-bottom: 5px;
      width: 160px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <button id="toggleHue">Toggle Auto Hue</button>
    <button id="toggleZoom">Toggle Auto Zoom</button>
    <button id="toggleFly">Toggle Fly Camera</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 3000);
    let renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    camera.position.z = 600;

    let controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Spiral Star Layers
    const starLayers = [];

    function createSpiralLayer(count, radius, spiralFactor, colorBase) {
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];

      for (let i = 0; i < count; i++) {
        const angle = i * spiralFactor;
        const dist = radius * Math.sqrt(i / count);
        const x = Math.cos(angle) * dist;
        const y = Math.sin(angle) * dist;
        const z = (Math.random() - 0.5) * 1000;

        positions.push(x, y, z);

        const hue = (colorBase + i / count) % 1;
        const color = new THREE.Color().setHSL(hue, 1.0, 0.6);
        colors.push(color.r, color.g, color.b);
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      const material = new THREE.PointsMaterial({ size: 1.4, vertexColors: true });
      const points = new THREE.Points(geometry, material);
      scene.add(points);

      starLayers.push({ points, geometry, spiralFactor });
    }

    createSpiralLayer(3000, 250, 0.12, 0.1);
    createSpiralLayer(2000, 180, 0.18, 0.6);
    createSpiralLayer(1500, 120, 0.24, 0.3);

    // Auto Hue
    let autoHue = false;
    let hueShift = 0;

    document.getElementById('toggleHue').onclick = () => autoHue = !autoHue;

    function updateHue() {
      starLayers.forEach(({ geometry }) => {
        const colors = geometry.attributes.color;
        for (let i = 0; i < colors.count; i++) {
          const h = (hueShift + i / colors.count) % 1;
          const color = new THREE.Color().setHSL(h, 1.0, 0.6);
          colors.setXYZ(i, color.r, color.g, color.b);
        }
        colors.needsUpdate = true;
      });
    }

    // Auto Zoom
    let autoZoom = false;
    let zoomDir = -1;
    document.getElementById('toggleZoom').onclick = () => autoZoom = !autoZoom;

    // Fly Camera
    let flyCamera = false;
    document.getElementById('toggleFly').onclick = () => flyCamera = !flyCamera;
    let flyAngle = 0;

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animate
    function animate() {
      requestAnimationFrame(animate);

      // Spiral rotation
      starLayers.forEach((layer, i) => {
        layer.points.rotation.z += (i % 2 === 0 ? 0.001 : -0.0015);
      });

      // Auto hue
      if (autoHue) {
        hueShift += 0.001;
        updateHue();
      }

      // Auto zoom
      if (autoZoom) {
        camera.position.z += zoomDir * 0.5;
        if (camera.position.z < 300 || camera.position.z > 800) {
          zoomDir *= -1;
        }
      }

      // Fly camera
      if (flyCamera) {
        flyAngle += 0.002;
        camera.position.x = Math.sin(flyAngle) * 500;
        camera.position.z = Math.cos(flyAngle) * 500;
        camera.lookAt(scene.position);
      }

      controls.update();
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
