<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tAc-tIc-toe</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { }
        #welcome-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(0, 0, 50, 0.8), rgba(0, 0, 100, 0.8));
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #ffffff;
            font-family: 'Orbitron', sans-serif;
            text-align: center;
            z-index: 10;
            text-shadow: 0 0 10px #00f, 0 0 20px #00f;
        }
        #welcome-screen h1 {
            font-size: 4em;
            margin-bottom: 20px;
            letter-spacing: 5px;
        }
        #welcome-screen p {
            font-size: 1.3em;
            max-width: 700px;
            margin-bottom: 30px;
            line-height: 1.5;
        }
        .mode-button {
            background: linear-gradient(#1e90ff, #4682b4);
            border: none;
            color: white;
            padding: 15px 40px;
            margin: 10px;
            font-size: 1.1em;
            cursor: pointer;
            border-radius: 10px;
            transition: transform 0.2s, background 0.3s;
            box-shadow: 0 0 10px #1e90ff;
        }
        .mode-button:hover {
            background: linear-gradient(#4682b4, #1e90ff);
            transform: scale(1.05);
        }
        .mode-button.selected {
            background: linear-gradient(#ff4500, #ff6347);
            box-shadow: 0 0 15px #ff4500;
        }
        #start-button {
            background: linear-gradient(#ff4500, #ff6347);
            border: none;
            color: white;
            padding: 20px 50px;
            font-size: 1.4em;
            cursor: pointer;
            border-radius: 10px;
            animation: throb 1.5s ease-in-out infinite;
            box-shadow: 0 0 20px #ff4500;
            text-shadow: 0 0 5px #000;
        }
        #start-button:hover {
            background: linear-gradient(#ff6347, #ff4500);
        }
        @keyframes throb {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        #stats-x, #stats-o {
            position: absolute;
            bottom: 80px;
            color: #ffffff;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8em;
            padding: 15px;
            background: rgba(0, 0, 50, 0.7);
            border-radius: 10px;
            z-index: 5;
            box-shadow: 0 0 10px #00f;
            text-shadow: 0 0 5px #00f;
        }
        #stats-x { left: 20px; }
        #stats-o { right: 20px; }
        .response-time {
            font-size: 0.6em;
        }
        #game-summary {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(rgba(0, 0, 50, 0.9), rgba(0, 0, 100, 0.9));
            color: #ffffff;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            font-family: 'Orbitron', sans-serif;
            z-index: 10;
            display: none;
            box-shadow: 0 0 20px #00f;
        }
        #game-summary h2 {
            margin: 0 0 20px;
            font-size: 2.5em;
            text-shadow: 0 0 10px #ff4500;
        }
        #play-again-button {
            background: linear-gradient(#ff4500, #ff6347);
            border: none;
            color: white;
            padding: 15px 40px;
            font-size: 1.2em;
            cursor: pointer;
            border-radius: 10px;
            transition: background 0.3s, transform 0.2s;
            box-shadow: 0 0 10px #ff;
        }
        #play-again-button:hover {
            background: linear-gradient(#ff6347, #ff4500);
            transform: scale(1.05);
        }
        #submit-score-button {
            background: green;
            border: none;
            color: white;
            padding: 3px 10px;
            font-size: 1em;
            cursor: pointer;
            border-radius: 10px;
            transition: background 0.3s, transform 0.2s;
            box-shadow: 0 0 10px #ffffff;
        }
        #restart-button {
            position: absolute;
            top: 80px;
            right: 20px;
            background: linear-gradient(#ff4500, #ff6347);
            border: none;
            color: white;
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            border-radius: 10px;
            transition: background 0.3s, transform 0.2s;
            box-shadow: 0 0 10px #ff4500;
            font-family: 'Orbitron', sans-serif;
            z-index: 5;
            display: none;
            text-shadow: 0 0 5px #000;
        }
        #restart-button:hover {
            background: linear-gradient(#ff6347, #ff4500);
            transform: scale(1.05);
        }
        #win-percentage-bar {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 50px;
            background: rgba(0, 0, 50, 0.7);
            display: flex;
            z-index: 5;
        }
        #x-bar {
            height: 100%;
            background: linear-gradient(#ff0000, #ff4500);
            transition: width: 0.5s;
            text-align: left;
            padding-left: 10px;
            line-height: 50px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 1em;
            text-shadow: 0 0 5px #000;
        }
        #o-bar {
            height: 100%;
            background: linear-gradient(#0000ff, #1e90ff);
            transition: width: 0.5s;
            text-align: right;
            padding-right: 10px;
            line-height: 50px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 1em;
            text-shadow: 0 0 5px #000;
        }
        #game-title {
            position: absolute;
            top: 14px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5em;
            text-shadow: 0 0 10px #00f, 0 0 20px #00f;
            z-index: 5;
            letter-spacing: 5px;
        }
        #game-timer {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            font-family: 'Orbitron', sans-serif;
            font-size: 1em;
            text-shadow: 0 0 5px #00f;
            z-index: 5;
        }
        #game-mode {
            position: absolute;
            top: 85px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            font-family: 'Orbitron', sans-serif;
            font-size: 1em;
            text-shadow: 0 0 5px #00f;
            z-index: 5;
        }
        #game-number-flash, #bonus-flash-x, #bonus-flash-o, #tap-flash, #turn-flash {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-family: 'Orbitron', sans-serif;
            font-size: 4em;
            text-shadow: 0 0 20px #ff4500;
            z-index: 10;
            display: none;
            animation: flash 1s ease-in-out;
        }
        #bonus-flash-x, #bonus-flash-o {
            font-size: 2.5em;
            top: 60%;
        }
        #tap-flash {
            font-size: 2em;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }
        #turn-flash {
            font-size: 2em;
        }
        #turn-flash.red {
            color: #ff4500;
            text-shadow: 0 0 10px #ff4500;
        }
        #turn-flash.blue {
            color: #1e90ff;
            text-shadow: 0 0 10px #1e90ff;
        }
        #bonus-flash-x { color: #ff4500; }
        #bonus-flash-o { color: #1e90ff; }
        @keyframes flash {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
    </style>
</head>
<body>
    <div id="welcome-screen">
        <h1>tAc-tIc-toe</h1>
        <p>Welcome to 3D tAc-tIc-toe! Play on a 3x3x3 grid. Win by aligning three symbols in a row, column, or diagonal across any dimension. Tap and drag elsewhere to control the camera. </p>
        <div>
            <button class="mode-button" id="one-player">1 Player</button>
            <button class="mode-button" id="two-players">2 Players</button>
            <button class="mode-button selected" id="ai-players">AI Players</button>
        </div>
        <button id="start-button">Start Game</button>
        <p>
            <small>Version 0.7</small>
        </p>
    </div>
    <div id="stats-x">Red<br>Wins: 0<br>Score: 0<br>Game: 1<br>Last Move: None<br><span class="response-time">Response: 0.00s<br>Avg Response: 0.00s</span></div>
    <div id="stats-o">Blue<br>Wins: 0<br>Score: 0<br>Game: 1<br>Last Move: None<br><span class="response-time">Response: 0.00s<br>Avg Response: 0.00s</span></div>
    <div id="game-summary">
        <h2 id="summary-text"></h2>
        <button id="play-again-button">Play Again</button>
        <br/><br/>
        <button id="submit-score-button">Submit Score</button>
    </div>

    <div id="win-percentage-bar">
        <div id="x-bar" style="width: 50%;">Red: 0%</div>
        <div id="o-bar" style="width: 50%;">Blue: 0%</div>
    </div>
    <div id="game-title">tAc-tIc-toe</div>
    <div id="game-timer">Time: 00:00</div>
    <div id="game-mode">Mode: AI Players</div>
    <div id="game-number-flash"></div>
    <div id="bonus-flash-x"></div>
    <div id="bonus-flash-o"></div>
    <div id="tap-flash"></div>
    <div id="turn-flash"></div>
    <button id="restart-button">Restart</button>
    
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Star field background
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 2000;
        const starPositions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount * 3; i += 3) {
            starPositions[i] = (Math.random() - 0.5) * 300;
            starPositions[i + 1] = (Math.random() - 0.5) * 300;
            starPositions[i + 2] = (Math.random() - 0.5) * 300;
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, transparent: true, opacity: 0.8 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(5, 5, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        const spotlight = new THREE.SpotLight(0xffffff, 1.5, 20, Math.PI / 4, 0.5);
        spotlight.position.copy(camera.position);
        spotlight.target.position.set(0, 0, 0);
        spotlight.castShadow = true;
        scene.add(spotlight);
        scene.add(spotlight.target);

        // Game board (3x3x3)
        let board = Array(3).fill().map(() => Array(3).fill().map(() => Array(3).fill(null)));
        const cubes = [];
        const originalPositions = [];

        // Create grid of cubes
        const cubeSize = 1;
        const spacing = 1.5;
        for (let x = 0; x < 3; x++) {
            for (let y = 0; y < 3; y++) {
                for (let z = 0; z < 3; z++) {
                    const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
                    geometry.computeVertexNormals();
                    const material = new THREE.MeshStandardMaterial({ 
                        color: 0x888888, 
                        transparent: true, 
                        opacity: 0.4,
                        metalness: 0.5,
                        roughness: 0.3,
                        emissive: 0x222222,
                        emissiveIntensity: 0.2
                    });
                    const cube = new THREE.Mesh(geometry, material);
                    cube.castShadow = true;
                    cube.receiveShadow = true;
                    const pos = new THREE.Vector3(
                        (x - 1) * spacing,
                        (y - 1) * spacing,
                        (z - 1) * spacing
                    );
                    cube.position.copy(pos);
                    scene.add(cube);
                    cubes.push(cube);
                    originalPositions.push(pos.clone());
                }
            }
        }

        // Camera setup
        camera.position.set(8, 8, 8);
        camera.lookAt(0, 0, 0);

        // Game state
        let currentPlayer = 'X';
        let gameOver = false;
        let winner = null;
        let winningCubes = [];
        let selectedCube = null;
        let flashTime = 0;
        let gameMode = 'ai';
        let gameNumber = 1;
        let xWins = 0;
        let oWins = 0;
        let xBonusPoints = 0;
        let oBonusPoints = 0;
        let gameStartTime = Date.now();
        let lastMoveTime = Date.now();
        let xResponseTimes = [];
        let oResponseTimes = [];
        let xLastResponseTime = 0;
        let oLastResponseTime = 0;
        let moveTimeout = null;
        let lastMoveX = 'None';
        let lastMoveO = 'None';

        // Camera control state
        let isCameraDragging = false;
        let isCubeDragging = false;
        let cameraTheta = Math.PI / 4;
        let cameraPhi = Math.PI / 4;
        let cameraRadius = 8;
        let prevMouse = new THREE.Vector2();

        // Double-tap detection
        let lastTapTime = 0;

        // Materials for players
        const xMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xff0000, 
            transparent: true, 
            opacity: 0.8,
            metalness: 0.6,
            roughness: 0.2,
            emissive: 0xff3333,
            emissiveIntensity: 0.3
        });
        const oMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x0000ff, 
            transparent: true, 
            opacity: 0.8,
            metalness: 0.6,
            roughness: 0.2,
            emissive: 0x3333ff,
            emissiveIntensity: 0.3
        });
        const selectedMaterial = new THREE.MeshStandardMaterial({
            color: 0xff0000,
            transparent: true,
            opacity: 0.8,
            metalness: 0.5,
            roughness: 0.3,
            emissive: 0xff3333,
            emissiveIntensity: 0.5
        });
        const defaultMaterial = new THREE.MeshStandardMaterial({
            color: 0x888888,
            transparent: true,
            opacity: 0.4,
            metalness: 0.5,
            roughness: 0.3,
            emissive: 0x222222,
            emissiveIntensity: 0.2
        });

        // Winning line
        let winningLine = null;

        // UI elements
        const welcomeScreen = document.getElementById('welcome-screen');
        const onePlayerButton = document.getElementById('one-player');
        const twoPlayersButton = document.getElementById('two-players');
        const aiPlayersButton = document.getElementById('ai-players');
        const startButton = document.getElementById('start-button');
        const statsX = document.getElementById('stats-x');
        const statsO = document.getElementById('stats-o');
        const gameSummary = document.getElementById('game-summary');
        const summaryText = document.getElementById('summary-text');
        const playAgainButton = document.getElementById('play-again-button');
        const submitScoreButton = document.getElementById('submit-score-button');
        const xBar = document.getElementById('x-bar');
        const oBar = document.getElementById('o-bar');
        const gameTimer = document.getElementById('game-timer');
        const gameModeDisplay = document.getElementById('game-mode');
        const gameNumberFlash = document.getElementById('game-number-flash');
        const bonusFlashX = document.getElementById('bonus-flash-x');
        const bonusFlashO = document.getElementById('bonus-flash-o');
        const tapFlash = document.getElementById('tap-flash');
        const turnFlash = document.getElementById('turn-flash');
        const restartButton = document.getElementById('restart-button');

        // Flash game number
        function flashGameNumber() {
            gameNumberFlash.textContent = `Game ${gameNumber}`;
            gameNumberFlash.style.display = 'block';
            setTimeout(() => {
                gameNumberFlash.style.display = 'none';
            }, 2000);
        }

        // Flash bonus points with reason
        function flashBonusPoints(player, points, reason) {
            const flashElement = player === 'X' ? bonusFlashX : bonusFlashO;
            flashElement.textContent = `+${points} ${reason}!`;
            flashElement.style.display = 'block';
            setTimeout(() => {
                flashElement.style.display = 'none';
            }, 2000);
        }

        // Flash tap message
        /*
        function flashTapMessage() {
            tapFlash.textContent = 'Tapped';
            tapFlash.style.display = 'block';
            setTimeout(() => {
                tapFlash.style.display = 'none';
            }, 1000);
        }
        */

        // Flash turn message
        function flashTurnMessage() {
            turnFlash.textContent = currentPlayer === 'X' ? "Red's Turn" : "Blue's Turn";
            turnFlash.className = currentPlayer === 'X' ? 'red' : 'blue';
            turnFlash.style.display = 'block';
            setTimeout(() => {
                turnFlash.style.display = 'none';
            }, 1000);
        }

        // Update game timer
        function updateGameTimer() {
            const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
            const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
            const seconds = String(elapsed % 60).padStart(2, '0');
            gameTimer.textContent = `Time: ${minutes}:${seconds}`;
        }

        // Calculate average response time
        function getAverageResponseTime(times) {
            if (times.length === 0) return 0;
            const sum = times.reduce((a, b) => a + b, 0);
            return (sum / times.length).toFixed(2);
        }

        // Update stats and win percentage bar
        function updateStats() {
            const xScore = xWins * 100 + xBonusPoints;
            const oScore = oWins * 100 + oBonusPoints;
            statsX.innerHTML = `Red<br>Wins: ${xWins}<br>Score: ${xScore}<br>Game: ${gameNumber}<br>Last Move: ${lastMoveX}<br><span class="response-time">Response: ${xLastResponseTime.toFixed(2)}s<br>Avg Response: ${getAverageResponseTime(xResponseTimes)}s</span>`;
            statsO.innerHTML = `Blue<br>Wins: ${oWins}<br>Score: ${oScore}<br>Game: ${gameNumber}<br>Last Move: ${lastMoveO}<br><span class="response-time">Response: ${oLastResponseTime.toFixed(2)}s<br>Avg Response: ${getAverageResponseTime(oResponseTimes)}s</span>`;
            const totalWins = xWins + oWins || 1;
            const xPercent = (xWins / totalWins) * 100;
            const oPercent = (oWins / totalWins) * 100;
            xBar.style.width = `${xPercent}%`;
            oBar.style.width = `${oPercent}%`;
            xBar.textContent = `Red: ${Math.round(xPercent)}%`;
            oBar.textContent = `Blue: ${Math.round(oPercent)}%`;
        }

        // Show game summary
        function showGameSummary() {
            summaryText.textContent = winner === 'Draw' ? 'Game is a Draw!' : winner === 'X' ? 'Red Wins!' : 'Blue Wins!';
            gameSummary.style.display = 'block';
            restartButton.style.display = 'none';
            if (gameMode === 'ai') {
                setTimeout(() => {
                    hideGameSummary();
                    gameNumber++;
                    resetGame();
                    flashGameNumber();
                    updateStats();
                    restartButton.style.display = 'block';
                    flashTurnMessage();
                    scheduleNextMove();
                }, 2000);
            }
            
            //document.getElementById("submitScoreButton").addEventListener("click", (e) => {
            document.getElementById("submitScoreBtn").addEventListener("click", (e) => {
              submitScoreToGameCenter(overallScore, "tActIctoeLeaderboard1");
              e.target.disabled = true;
              e.target.innerText = "Score Submitted!";
              e.target.style.animation = "pop 0.5s ease";
              setTimeout(() => {
                e.target.style.backgroundColor = "#ccc";
              }, 500);
            });
            
        }

        // Hide game summary
        function hideGameSummary() {
            gameSummary.style.display = 'none';
        }

        // Reset to welcome screen
        function resetToWelcome() {
            resetGame();
            welcomeScreen.style.display = 'flex';
            restartButton.style.display = 'none';
            gameSummary.style.display = 'none';
            gameNumber = 1;
            xWins = 0;
            oWins = 0;
            xBonusPoints = 0;
            oBonusPoints = 0;
            xResponseTimes = [];
            oResponseTimes = [];
            xLastResponseTime = 0;
            oLastResponseTime = 0;
            updateStats();
        }

        // Game mode handling
        function setGameMode(mode) {
            gameMode = mode;
            onePlayerButton.classList.remove('selected');
            twoPlayersButton.classList.remove('selected');
            aiPlayersButton.classList.remove('selected');
            let modeText = 'AI Players';
            if (mode === 'one') {
                onePlayerButton.classList.add('selected');
                modeText = '1 Player';
            } else if (mode === 'two') {
                twoPlayersButton.classList.add('selected');
                modeText = '2 Players';
            } else {
                aiPlayersButton.classList.add('selected');
                modeText = 'AI Players';
            }
            gameModeDisplay.textContent = `Mode: ${modeText}`;
        }

        onePlayerButton.addEventListener('click', () => setGameMode('one'));
        twoPlayersButton.addEventListener('click', () => setGameMode('two'));
        aiPlayersButton.addEventListener('click', () => setGameMode('ai'));

        startButton.addEventListener('click', () => {
            welcomeScreen.style.display = 'none';
            restartButton.style.display = 'block';
            gameNumber = 1;
            xWins = 0;
            oWins = 0;
            xBonusPoints = 0;
            oBonusPoints = 0;
            xResponseTimes = [];
            oResponseTimes = [];
            xLastResponseTime = 0;
            oLastResponseTime = 0;
            gameStartTime = Date.now();
            updateStats();
            flashGameNumber();
            resetGame();
            flashTurnMessage();
            if (gameMode === 'one' && currentPlayer === 'O' || gameMode === 'ai') {
                scheduleNextMove();
            }
        });

        playAgainButton.addEventListener('click', () => {
            hideGameSummary();
            gameNumber++;
            gameStartTime = Date.now();
            xLastResponseTime = 0;
            oLastResponseTime = 0;
            resetGame();
            flashGameNumber();
            updateStats();
            restartButton.style.display = 'block';
            flashTurnMessage();
            if (gameMode === 'one' && currentPlayer === 'O' || gameMode === 'ai') {
                scheduleNextMove();
            }
        });

        function submitScoreToGameCenter(score, leaderboardId) {
            window.webkit?.messageHandlers.wordAIlyHandler.postMessage({
                action: "submitScore",
                score: score,
                leaderboardId: leaderboardId
            });
        }          
        
        restartButton.addEventListener('click', resetToWelcome);

        // Schedule next AI move with random delay
        function scheduleNextMove() {
            if (gameOver) return;
            if (moveTimeout) clearTimeout(moveTimeout);
            const delay = Math.random() * (1.25 - 0.2) + 0.2;
            if (currentPlayer === 'X') {
                xLastResponseTime = delay;
            } else {
                oLastResponseTime = delay;
            }
            moveTimeout = setTimeout(() => {
                if (!gameOver) {
                    makeAIMove();
                    if ((gameMode === 'one' && currentPlayer === 'O') || gameMode === 'ai') {
                        scheduleNextMove();
                    }
                }
            }, delay * 1000);
        }

        // Mouse interaction
        const raycaster = new THREE.Raycaster();
        raycaster.params.Mesh.threshold = 0.2;
        const mouse = new THREE.Vector2();
        let dragOffset = new THREE.Vector3();

        // Normalize touch coordinates
        function normalizeTouchCoordinates(clientX, clientY) {
            const rect = renderer.domElement.getBoundingClientRect();
            const x = ((clientX - rect.left) / rect.width) * 2 - 1;
            const y = -((clientY - rect.top) / rect.height) * 2 + 1;
            return { x, y };
        }

        // Check for win and return winning line points and cubes
        function checkWin(player) {
            winningCubes = [];
            // Check rows
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (board[i][j][0] === player && board[i][j][1] === player && board[i][j][2] === player) {
                        winningCubes = [
                            cubes[i * 9 + j * 3 + 0],
                            cubes[i * 9 + j * 3 + 1],
                            cubes[i * 9 + j * 3 + 2]
                        ];
                        return {
                            win: true,
                            start: new THREE.Vector3((i - 1) * spacing, (j - 1) * spacing, (-1) * spacing),
                            end: new THREE.Vector3((i - 1) * spacing, (j - 1) * spacing, 1 * spacing)
                        };
                    }
                    if (board[i][0][j] === player && board[i][1][j] === player && board[i][2][j] === player) {
                        winningCubes = [
                            cubes[i * 9 + 0 * 3 + j],
                            cubes[i * 9 + 1 * 3 + j],
                            cubes[i * 9 + 2 * 3 + j]
                        ];
                        return {
                            win: true,
                            start: new THREE.Vector3((i - 1) * spacing, (-1) * spacing, (j - 1) * spacing),
                            end: new THREE.Vector3((i - 1) * spacing, 1 * spacing, (j - 1) * spacing)
                        };
                    }
                    if (board[0][i][j] === player && board[1][i][j] === player && board[2][i][j] === player) {
                        winningCubes = [
                            cubes[0 * 9 + i * 3 + j],
                            cubes[1 * 9 + i * 3 + j],
                            cubes[2 * 9 + i * 3 + j]
                        ];
                        return {
                            win: true,
                            start: new THREE.Vector3((-1) * spacing, (i - 1) * spacing, (j - 1) * spacing),
                            end: new THREE.Vector3(1 * spacing, (i - 1) * spacing, (j - 1) * spacing)
                        };
                    }
                }
            }
            // Check 3D diagonals
            if (board[0][0][0] === player && board[1][1][1] === player && board[2][2][2] === player) {
                winningCubes = [
                    cubes[0 * 9 + 0 * 3 + 0],
                    cubes[1 * 9 + 1 * 3 + 1],
                    cubes[2 * 9 + 2 * 3 + 2]
                ];
                return {
                    win: true,
                    start: new THREE.Vector3(-1 * spacing, -1 * spacing, -1 * spacing),
                    end: new THREE.Vector3(1 * spacing, 1 * spacing, 1 * spacing)
                };
            }
            if (board[2][0][0] === player && board[1][1][1] === player && board[0][2][2] === player) {
                winningCubes = [
                    cubes[2 * 9 + 0 * 3 + 0],
                    cubes[1 * 9 + 1 * 3 + 1],
                    cubes[0 * 9 + 2 * 3 + 2]
                ];
                return {
                    win: true,
                    start: new THREE.Vector3(1 * spacing, -1 * spacing, -1 * spacing),
                    end: new THREE.Vector3(-1 * spacing, 1 * spacing, 1 * spacing)
                };
            }
            if (board[0][2][0] === player && board[1][1][1] === player && board[2][0][2] === player) {
                winningCubes = [
                    cubes[0 * 9 + 2 * 3 + 0],
                    cubes[1 * 9 + 1 * 3 + 1],
                    cubes[2 * 9 + 0 * 3 + 2]
                ];
                return {
                    win: true,
                    start: new THREE.Vector3(-1 * spacing, 1 * spacing, -1 * spacing),
                    end: new THREE.Vector3(1 * spacing, -1 * spacing, 1 * spacing)
                };
            }
            if (board[0][0][2] === player && board[1][1][1] === player && board[2][2][0] === player) {
                winningCubes = [
                    cubes[0 * 9 + 0 * 3 + 2],
                    cubes[1 * 9 + 1 * 3 + 1],
                    cubes[2 * 9 + 2 * 3 + 0]
                ];
                return {
                    win: true,
                    start: new THREE.Vector3(-1 * spacing, -1 * spacing, 1 * spacing),
                    end: new THREE.Vector3(1 * spacing, 1 * spacing, -1 * spacing)
                };
            }
            // Check 2D diagonals in each plane
            for (let i = 0; i < 3; i++) {
                // XY plane (fixed z)
                if (board[0][0][i] === player && board[1][1][i] === player && board[2][2][i] === player) {
                    winningCubes = [
                        cubes[0 * 9 + 0 * 3 + i],
                        cubes[1 * 9 + 1 * 3 + i],
                        cubes[2 * 9 + 2 * 3 + i]
                    ];
                    return {
                        win: true,
                        start: new THREE.Vector3(-1 * spacing, -1 * spacing, (i - 1) * spacing),
                        end: new THREE.Vector3(1 * spacing, 1 * spacing, (i - 1) * spacing)
                    };
                }
                if (board[2][0][i] === player && board[1][1][i] === player && board[0][2][i] === player) {
                    winningCubes = [
                        cubes[2 * 9 + 0 * 3 + i],
                        cubes[1 * 9 + 1 * 3 + i],
                        cubes[0 * 9 + 2 * 3 + i]
                    ];
                    return {
                        win: true,
                        start: new THREE.Vector3(1 * spacing, -1 * spacing, (i - 1) * spacing),
                        end: new THREE.Vector3(-1 * spacing, 1 * spacing, (i - 1) * spacing)
                    };
                }
                // XZ plane (fixed y)
                if (board[0][i][0] === player && board[1][i][1] === player && board[2][i][2] === player) {
                    winningCubes = [
                        cubes[0 * 9 + i * 3 + 0],
                        cubes[1 * 9 + i * 3 + 1],
                        cubes[2 * 9 + i * 3 + 2]
                    ];
                    return {
                        win: true,
                        start: new THREE.Vector3(-1 * spacing, (i - 1) * spacing, -1 * spacing),
                        end: new THREE.Vector3(1 * spacing, (i - 1) * spacing, 1 * spacing)
                    };
                }
                if (board[2][i][0] === player && board[1][i][1] === player && board[0][i][2] === player) {
                    winningCubes = [
                        cubes[2 * 9 + i * 3 + 0],
                        cubes[1 * 9 + i * 3 + 1],
                        cubes[0 * 9 + i * 3 + 2]
                    ];
                    return {
                        win: true,
                        start: new THREE.Vector3(1 * spacing, (i - 1) * spacing, -1 * spacing),
                        end: new THREE.Vector3(-1 * spacing, (i - 1) * spacing, 1 * spacing)
                    };
                }
                // YZ plane (fixed x)
                if (board[i][0][0] === player && board[i][1][1] === player && board[i][2][2] === player) {
                    winningCubes = [
                        cubes[i * 9 + 0 * 3 + 0],
                        cubes[i * 9 + 1 * 3 + 1],
                        cubes[i * 9 + 2 * 3 + 2]
                    ];
                    return {
                        win: true,
                        start: new THREE.Vector3((i - 1) * spacing, -1 * spacing, -1 * spacing),
                        end: new THREE.Vector3((i - 1) * spacing, 1 * spacing, 1 * spacing)
                    };
                }
                if (board[i][2][0] === player && board[i][1][1] === player && board[i][0][2] === player) {
                    winningCubes = [
                        cubes[i * 9 + 2 * 3 + 0],
                        cubes[i * 9 + 1 * 3 + 1],
                        cubes[i * 9 + 0 * 3 + 2]
                    ];
                    return {
                        win: true,
                        start: new THREE.Vector3((i - 1) * spacing, 1 * spacing, -1 * spacing),
                        end: new THREE.Vector3((i - 1) * spacing, -1 * spacing, 1 * spacing)
                    };
                }
            }
            return { win: false };
        }

        // Draw glowing winning line
        function drawWinningLine(start, end) {
            const geometry = new THREE.TubeGeometry(
                new THREE.LineCurve3(start, end),
                20,
                0.15,
                8,
                false
            );
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffff00, 
                transparent: true, 
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });
            winningLine = new THREE.Mesh(geometry, material);
            scene.add(winningLine);
        }

        // Shake winning cubes
        function shakeWinningCubes(time) {
            if (winningCubes.length > 0) {
                const shakeAmplitude = 0.1;
                const shakeFrequency = 10;
                winningCubes.forEach((cube, index) => {
                    const original = originalPositions[cubes.indexOf(cube)];
                    cube.position.set(
                        original.x + Math.sin(time * shakeFrequency + index) * shakeAmplitude,
                        original.y + Math.cos(time * shakeFrequency + index) * shakeAmplitude,
                        original.z + Math.sin(time * shakeFrequency + index) * shakeAmplitude
                    );
                });
            }
        }

        // Apply static red highlight to selected cube
        function flashSelectedCube() {
            if (selectedCube && gameMode === 'one' && currentPlayer === 'X' && !gameOver) {
                selectedCube.material = selectedMaterial;
                selectedCube.scale.set(1, 1, 1); // Keep cube still
            }
        }

        // Make AI move
        function makeAIMove() {
            if (gameOver) return;
            const emptyCells = [];
            for (let x = 0; x < 3; x++) {
                for (let y = 0; y < 3; y++) {
                    for (let z = 0; z < 3; z++) {
                        if (!board[x][y][z]) {
                            emptyCells.push({ x, y, z });
                        }
                    }
                }
            }
            if (emptyCells.length === 0) {
                gameOver = true;
                winner = 'Draw';
                showGameSummary();
                return;
            }

            let move;
            if (gameMode === 'one' && currentPlayer === 'O') {
                // Check for winning move for Blue (O)
                for (const cell of emptyCells) {
                    board[cell.x][cell.y][cell.z] = 'O';
                    if (checkWin('O').win) {
                        board[cell.x][cell.y][cell.z] = null;
                        move = cell;
                        break;
                    }
                    board[cell.x][cell.y][cell.z] = null;
                }

                // Check for blocking move against Red (X)
                if (!move) {
                    for (const cell of emptyCells) {
                        board[cell.x][cell.y][cell.z] = 'X';
                        if (checkWin('X').win) {
                            board[cell.x][cell.y][cell.z] = null;
                            move = cell;
                            break;
                        }
                        board[cell.x][cell.y][cell.z] = null;
                    }
                }
            }

            // If no winning or blocking move, choose random
            if (!move) {
                move = emptyCells[Math.floor(Math.random() * emptyCells.length)];
            }

            lastMoveO = `(${move.x}, ${move.y}, ${move.z})`;
            makeMove(move.x, move.y, move.z);
        }

        // Make a move
        function makeMove(x, y, z) {
            if (gameOver || board[x][y][z]) return;
            const responseTime = (Date.now() - lastMoveTime) / 1000;
            if (currentPlayer === 'X') {
                xResponseTimes.push(responseTime);
                if (responseTime < 0.5) {
                    xBonusPoints += 10;
                    flashBonusPoints('X', 10, 'Quick Response');
                }
                xLastResponseTime = responseTime;
                lastMoveX = `(${x}, ${y}, ${z})`;
            } else {
                oResponseTimes.push(responseTime);
                if (responseTime < 0.5) {
                    oBonusPoints += 10;
                    flashBonusPoints('O', 10, 'Quick Response');
                }
                oLastResponseTime = responseTime;
                lastMoveO = `(${x}, ${y}, ${z})`;
            }
            lastMoveTime = Date.now();
            board[x][y][z] = currentPlayer;
            const index = x * 9 + y * 3 + z;
            cubes[index].material = currentPlayer === 'X' ? xMaterial : oMaterial;
            if (selectedCube) {
                selectedCube.material = currentPlayer === 'X' ? xMaterial : oMaterial;
                selectedCube.scale.set(1, 1, 1);
                selectedCube = null;
            }

            const winResult = checkWin(currentPlayer);
            if (winResult.win) {
                gameOver = true;
                winner = currentPlayer;
                if (winner === 'X') {
                    xWins++;
                    xBonusPoints += 100;
                    flashBonusPoints('X', 100, 'Win');
                } else {
                    oWins++;
                    oBonusPoints += 100;
                    flashBonusPoints('O', 100, 'Win');
                }
                drawWinningLine(winResult.start, winResult.end);
                showGameSummary();
                updateStats();
                return;
            }
            if (!board.flat().flat().some(cell => !cell)) {
                gameOver = true;
                winner = 'Draw';
                showGameSummary();
                return;
            }
            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
            flashTurnMessage();
            updateStats();
        }

        // Reset game
        function resetGame() {
            board = Array(3).fill().map(() => Array(3).fill().map(() => Array(3).fill(null)));
            currentPlayer = 'X';
            gameOver = false;
            winner = null;
            winningCubes = [];
            selectedCube = null;
            gameStartTime = Date.now();
            lastMoveTime = Date.now();
            xLastResponseTime = 0;
            oLastResponseTime = 0;
            lastMoveX = 'None';
            lastMoveO = 'None';
            if (moveTimeout) clearTimeout(moveTimeout);
            moveTimeout = null;

            cubes.forEach((cube, index) => {
                cube.position.copy(originalPositions[index]);
                cube.scale.set(1, 1, 1);
                cube.material = defaultMaterial;
            });

            if (winningLine) {
                scene.remove(winningLine);
                winningLine = null;
            }
        }

        // Update camera position
        function updateCameraPosition() {
            camera.position.x = cameraRadius * Math.sin(cameraTheta) * Math.cos(cameraPhi);
            camera.position.z = cameraRadius * Math.sin(cameraTheta) * Math.sin(cameraPhi);
            camera.position.y = cameraRadius * Math.cos(cameraTheta);
            camera.lookAt(0, 0, 0);
            spotlight.position.copy(camera.position);
            spotlight.target.position.set(0, 0, 0);
        }

        // Mouse and touch events
        function onMouseDown(event) {
            if (welcomeScreen.style.display !== 'none' || gameSummary.style.display !== 'none') return;
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            prevMouse.copy(mouse);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubes);
            if (intersects.length > 0) {
                const newSelectedCube = intersects[0].object;
                const index = cubes.indexOf(newSelectedCube);
                const x = Math.floor(index / 9);
                const y = Math.floor((index % 9) / 3);
                const z = index % 3;
                if (gameMode === 'one' && currentPlayer === 'X' && !board[x][y][z]) {
                    if (selectedCube && selectedCube !== newSelectedCube) {
                        selectedCube.material = defaultMaterial;
                        selectedCube.scale.set(1, 1, 1);
                    }
                    selectedCube = newSelectedCube;
                    selectedCube.material = selectedMaterial;
                    makeMove(x, y, z);
                    if (!gameOver && currentPlayer === 'O') {
                        scheduleNextMove();
                    }
                } else if (gameMode === 'two' && !board[x][y][z]) {
                    makeMove(x, y, z);
                }
                isCubeDragging = true;
                const intersectPoint = intersects[0].point;
                dragOffset.subVectors(selectedCube ? selectedCube.position : newSelectedCube.position, intersectPoint);
            } else {
                isCameraDragging = true;
            }
        }

        function onMouseMove(event) {
            if (welcomeScreen.style.display !== 'none' || gameSummary.style.display !== 'none') return;
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            if (isCubeDragging && selectedCube) {
                raycaster.setFromCamera(mouse, camera);
                const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersectPoint);
                selectedCube.position.copy(intersectPoint).add(dragOffset);
            } else if (isCameraDragging && (gameMode === 'one' || gameMode === 'two')) {
                const deltaX = mouse.x - prevMouse.x;
                const deltaY = mouse.y - prevMouse.y;
                cameraTheta += deltaY * Math.PI;
                cameraPhi -= deltaX * Math.PI;
                cameraTheta = Math.max(0.1, Math.min(Math.PI - 0.1, cameraTheta));
                updateCameraPosition();
                prevMouse.copy(mouse);
            }
        }

        function onMouseUp() {
            if (welcomeScreen.style.display !== 'none' || gameSummary.style.display !== 'none') return;
            if (selectedCube) {
                const index = cubes.indexOf(selectedCube);
                selectedCube.position.copy(originalPositions[index]);
                selectedCube.scale.set(1, 1, 1);
                selectedCube.material = board[Math.floor(index / 9)][Math.floor((index % 9) / 3)][index % 3] === 'X' ? xMaterial : 
                                        board[Math.floor(index / 9)][Math.floor((index % 9) / 3)][index % 3] === 'O' ? oMaterial : 
                                        defaultMaterial;
                isCubeDragging = false;
            }
            isCameraDragging = false;
        }

        function onTouchStart(event) {
            if (welcomeScreen.style.display !== 'none' || gameSummary.style.display !== 'none') return;
            event.preventDefault();
            const touch = event.touches[0];
            const currentTime = Date.now();

            if (currentTime - lastTapTime < 300) {
                // Double tap: reset to welcome screen
                resetToWelcome();
                flashGameNumber();
                if (gameMode === 'one' && currentPlayer === 'O' || gameMode === 'ai') {
                    scheduleNextMove();
                }
                lastTapTime = 0;
                return;
            }

            // Flash "Tapped" message in non-AI modes
            //if (gameMode === 'one' || gameMode === 'two') {
            //    flashTapMessage();
            //}

            const coords = normalizeTouchCoordinates(touch.clientX, touch.clientY);
            mouse.x = coords.x;
            mouse.y = coords.y;
            prevMouse.copy(mouse);
            renderer.render(scene, camera);
            raycaster.setFromCamera(mouse, camera);
            raycaster.near = 0.1;
            raycaster.far = 50;
            const intersects = raycaster.intersectObjects(cubes);

            if (intersects.length > 0) {
                const newSelectedCube = intersects[0].object;
                const index = cubes.indexOf(newSelectedCube);
                const x = Math.floor(index / 9);
                const y = Math.floor((index % 9) / 3);
                const z = index % 3;
                if (gameMode === 'one' && currentPlayer === 'X' && !board[x][y][z]) {
                    if (selectedCube && selectedCube !== newSelectedCube) {
                        selectedCube.material = defaultMaterial;
                        selectedCube.scale.set(1, 1, 1);
                    }
                    selectedCube = newSelectedCube;
                    selectedCube.material = selectedMaterial;
                    selectedCube.scale.set(1, 1, 1);
                    makeMove(x, y, z);
                    if (!gameOver && currentPlayer === 'O') {
                        scheduleNextMove();
                    }
                } else if (gameMode === 'two' && !board[x][y][z]) {
                    makeMove(x, y, z);
                    isCubeDragging = true;
                    const intersectPoint = intersects[0].point;
                    dragOffset.subVectors(newSelectedCube.position, intersectPoint);
                }
            } else if (gameMode === 'one' || gameMode === 'two') {
                isCameraDragging = true;
            }

            lastTapTime = currentTime;
        }

        function onTouchMove(event) {
            if (welcomeScreen.style.display !== 'none' || gameSummary.style.display !== 'none') return;
            event.preventDefault();
            const touch = event.touches[0];
            const coords = normalizeTouchCoordinates(touch.clientX, touch.clientY);
            mouse.x = coords.x;
            mouse.y = coords.y;
            if (isCubeDragging && selectedCube && gameMode === 'two') {
                raycaster.setFromCamera(mouse, camera);
                const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersectPoint);
                selectedCube.position.copy(intersectPoint).add(dragOffset);
            } else if (isCameraDragging && (gameMode === 'one' || gameMode === 'two')) {
                const deltaX = mouse.x - prevMouse.x;
                const deltaY = mouse.y - prevMouse.y;
                cameraTheta += deltaY * Math.PI;
                cameraPhi -= deltaX * Math.PI;
                cameraTheta = Math.max(0.1, Math.min(Math.PI - 0.1, cameraTheta));
                updateCameraPosition();
                prevMouse.copy(mouse);
            }
        }

        function onTouchEnd() {
            if (welcomeScreen.style.display !== 'none' || gameSummary.style.display !== 'none') return;
            if (selectedCube && gameMode === 'two') {
                const index = cubes.indexOf(selectedCube);
                selectedCube.position.copy(originalPositions[index]);
                selectedCube.scale.set(1, 1, 1);
                selectedCube.material = board[Math.floor(index / 9)][Math.floor((index % 9) / 3)][index % 3] === 'X' ? xMaterial : 
                                        board[Math.floor(index / 9)][Math.floor((index % 9) / 3)][index % 3] === 'O' ? oMaterial : 
                                        defaultMaterial;
                isCubeDragging = false;
            }
            isCameraDragging = false;
        }

        // Event listeners
        renderer.domElement.addEventListener('mousedown', onMouseDown, { passive: false });
        renderer.domElement.addEventListener('mousemove', onMouseMove, { passive: false });
        renderer.domElement.addEventListener('mouseup', onMouseUp, { passive: false });
        renderer.domElement.addEventListener('touchstart', onTouchStart);
        renderer.domElement.addEventListener('touchmove', onTouchMove);
        renderer.domElement.addEventListener('touchend', onTouchEnd);

        // Animation loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            if (!isCameraDragging && gameMode === 'ai') {
                cameraTheta += 0.005;
                cameraPhi += 0.005;
                updateCameraPosition();
            }
            shakeWinningCubes(time);
            flashSelectedCube();
            updateGameTimer();
            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        
    </script>
</body>
</html>
