<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tronAIx Game - V0.95</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #ui { 
            position: absolute; 
            bottom: 10px; 
            width: 100%; 
            display: flex; 
            justify-content: space-between; 
            font-family: 'Arial', sans-serif; 
            padding: 0 10px; 
            box-sizing: border-box; 
        }
        #redStats, #blueStats { 
            background: rgba(0, 0, 0, 0.7); 
            padding: 10px; 
            border-radius: 5px; 
        }
        #redStats { color: #ff0000; }
        #blueStats { color: #00b7eb; }
        #redStats div, #blueStats div { font-size: 12px; }
        #redStats div:first-child, #blueStats div:first-child { font-size: 16px; }
        #speedStats { color: #00ff00; }
        #gameOver { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            font-family: 'Arial', sans-serif; 
            font-size: 18px;
            text-align: center; 
            display: none; 
            background: rgba(0, 0, 0, 0.7); 
            padding: 20px; 
            border: 2px solid #00ff00; 
            z-index: 5; 
            width: 75%
        }
        #gameOver div { color: #ffffff; }
        #gameOverTitle {
            font-size: 36px;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }
        #winner, #loser { color: #ffffff; }
        .scoreValue {
            font-size: 14px;
        }
        #redScoreValue { color: #ff0000; }
        #blueScoreValue { color: #00b7eb; }
        #restartButton {
            font-size: 16px;
            padding: 8px 16px;
            margin-top: 15px;
            background: #00ff00;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-shadow: 0 0 5px #000;
            transition: background 0.3s;
        }
        #restartButton:hover {
            background: #00b7eb;
        }
        #bonusMessage { 
            position: absolute; 
            top: 110px; 
            left: 50%; 
            transform: translate(-50%, 0); 
            font-family: 'Arial', sans-serif; 
            font-size: 32px; 
            color: #ffffff; 
            text-align: center; 
            display: none; 
            text-shadow: 0 0 10px #00ff00; 
        }
        #countdownDisplay { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            font-family: 'Arial', sans-serif; 
            font-size: 144px;
            color: #00ff00; 
            text-align: center; 
            display: none; 
            text-shadow: 0 0 15px #00ff00; 
            background: transparent; 
            z-index: 5; 
        }
        #fadeOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            opacity: 1;
            z-index: 4;
            pointer-events: none;
            transition: opacity 4s ease-out;
        }
        #welcomeScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 255, 0, 0.2));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Arial', sans-serif;
            color: #00ff00;
            text-align: center;
            z-index: 15;
        }
        #welcomeScreen h1 {
            font-size: 64px;
            z-index: 17;
            opacity: 0;
            animation: fadeIn 1s ease-in forwards;
        }
        #welcomeScreen h1 .letter {
            display: inline-block;
            animation: colorCycle 3s infinite;
        }
        #welcomeScreen h1 .letter:nth-child(1) { animation-delay: 0s; }
        #welcomeScreen h1 .letter:nth-child(2) { animation-delay: 0.2s; }
        #welcomeScreen h1 .letter:nth-child(3) { animation-delay: 0.4s; }
        #welcomeScreen h1 .letter:nth-child(4) { animation-delay: 0.6s; }
        #welcomeScreen h1 .letter:nth-child(5) { animation-delay: 0.8s; }
        #welcomeScreen h1 .letter:nth-child(6) { animation-delay: 1.0s; }
        #welcomeScreen h1 .letter:nth-child(7) { animation-delay: 1.2s; }
        @keyframes colorCycle {
            0% {
                color: #00ff00;
                text-shadow: 0 0 15px #00ff00, 0 0 30px #00b7eb;
            }
            33% {
                color: #ff0000;
                text-shadow: 0 0 15px #ff0000, 0 0 30px #00b7eb;
            }
            66% {
                color: #00b7eb;
                text-shadow: 0 0 15px #00b7eb, 0 0 30px #ff0000;
            }
            100% {
                color: #00ff00;
                text-shadow: 0 0 15px #00ff00, 0 0 30px #00b7eb;
            }
        }
        #welcomeScreen p {
            font-size: 18px;
            max-width: 700px;
            margin: 20px 0;
            text-shadow: 0 0 10px #00ff00;
            z-index: 17;
            opacity: 0;
            animation: fadeIn 1s ease-in 0.3s forwards;
        }
        #welcomeScreen button {
            font-size: 20px;
            padding: 12px 24px;
            margin: 10px;
            background: #00ff00;
            color: #ffffff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 10px #00ff00;
            text-shadow: 0 0 5px #000;
            transition: transform 0.2s, box-shadow 0.2s;
            z-index: 17;
            opacity: 0;
            animation: fadeIn 1s ease-in 0.6s forwards;
        }
        #start1Player {
            margin-top: 20px;
            animation: throb 0.5s ease-in-out infinite;
        }
        #welcomeScreen button:hover {
            background: #00b7eb;
            box-shadow: 0 0 15px #00b7eb;
            transform: scale(1.05);
        }
        #gameModeLabel, #gridSizeLabel, #speedLabel {
            font-size: 20px;
            margin: 10px 0;
            text-shadow: 0 0 10px #00ff00;
            z-index: 17;
            opacity: 0;
            animation: fadeIn 1s ease-in 0.9s forwards;
        }
        #gameModeLabel {
            margin-top: 20px;
        }
        #gameModeButtons {
            display: flex;
            gap: 10px;
            z-index: 17;
        }
        #gridSizeButtons {
            display: flex;
            gap: 10px;
            z-index: 17;
        }
        #speedButtons {
            display: flex;
            gap: 10px;
            z-index: 17;
        }
        #gridSizeButtons button, #speedButtons button {
            font-size: 16px;
            padding: 8px 16px;
            background: #00ff00;
            color: #ffffff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            box-shadow: 0 0 8px #00ff00;
            text-shadow: 0 0 5px #000;
            transition: transform 0.2s, box-shadow 0.2s, background 0.2s;
            opacity: 0;
            animation: fadeIn 1s ease-in 1.2s forwards;
        }
        #gridSizeButtons button:hover, #speedButtons button:hover {
            background: #00b7eb;
            box-shadow: 0 0 12px #00b7eb;
            transform: scale(1.05);
        }
        #gridSizeButtons button.selected, #speedButtons button.selected {
            background: #00b7eb;
            box-shadow: 0 0 12px #00b7eb;
        }
        #starField {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 16;
            overflow: hidden;
        }
        .star {
            position: absolute;
            background: #fff;
            border-radius: 50%;
            opacity: 0;
            animation: twinkle 3s infinite;
        }
        @keyframes twinkle {
            0% { opacity: 0; }
            50% { opacity: 0.8; }
            100% { opacity: 0; }
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        @keyframes throb {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        .throbbing {
            animation: throb 0.5s ease-in-out infinite;
        }
        #titleBar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Arial', sans-serif;
            text-align: center;
            color: #00ff00;
        }
        #titleBar h1 {
            font-size: 36px;
            margin: 0;
            text-shadow: 0 0 10px #00ff00;
        }
        #titleBar #speedStats {
            font-size: 16px;
        }
        #buttonContainer {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 6;
        }
        #gameRestartButton, #cameraButton, #speedButton {
            font-size: 12px;
            padding: 8px 16px;
            background: #00ff00;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        #gameRestartButton {
            background: #ff0000;
            color: #fff;
        }
        #gameRestartButton:hover {
            background: #cc0000;
        }
        #cameraButton:hover, #speedButton:hover {
            background: #00b7eb;
        }
        #welcomeScreen:not([style*="display: none"]) ~ #buttonContainer {
            display: none;
        }
        #controlBox {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #fff;
            border-radius: 5px;
            display: none;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-family: 'Arial', sans-serif;
            font-size: 12px;
            text-align: center;
            z-index: 6;
            width: 120px;
            height: 90px;
            opacity: 75%;
        }
        #controlBoxText {
            pointer-events: none;
        }
        #miniGrid {
            position: relative;
            width: 200px;
            height: 200px;
            background: #111111;
            border: 2px solid #00ff00;
            box-shadow: 0 0 10px #00ff00;
            z-index: 17;
            margin-top: 20px;
            display: grid;
            grid-template: repeat(10, 1fr) / repeat(10, 1fr);
        }
        .miniGridCell {
            position: relative;
            border: 1px solid #00ff00;
            box-sizing: border-box;
        }
        .miniGridPlayer {
            position: absolute;
            width: 80%;
            height: 80%;
            top: 10%;
            left: 10%;
            border: 1px solid #ffffff;
            box-shadow: 0 0 5px #ffffff;
            transition: all 0.2s;
        }
        #miniRedPlayer {
            background: #ff0000;
            box-shadow: 0 0 8px #ff0000;
        }
        #miniBluePlayer {
            background: #00b7eb;
            box-shadow: 0 0 8px #00b7eb;
        }
        .miniGridTrail {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0.5;
        }
        .miniGridWall {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0.9;
        }
        @media (max-width: 600px) {
            #welcomeScreen h1 {
                font-size: 48px;
            }
            #welcomeScreen p {
                font-size: 16px;
                max-width: 90%;
            }
            #welcomeScreen button {
                font-size: 16px;
                padding: 10px 20px;
            }
            #miniGrid {
                width: 150px;
                height: 150px;
            }
            #gameOverTitle {
                font-size: 24px;
            }
            #gameModeLabel, #gridSizeLabel, #speedLabel {
                font-size: 16px;
            }
            #gameModeButtons button, #gridSizeButtons button, #speedButtons button {
                font-size: 12px;
                padding: 6px 12px;
            }
            #controlBox {
                width: 120px;
                height: 90px;
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="welcomeScreen">
        <div id="starField"></div>
        <h1>
            <span class="letter">t</span>
            <span class="letter">r</span>
            <span class="letter">o</span>
            <span class="letter">n</span>
            <span class="letter">A</span>
            <span class="letter">I</span>
            <span class="letter">x</span>
        </h1>
        <p>Navigate the neon grid, outmaneuver your opponent, and claim territory by creating walls. Survive longer and cover more ground to win!</p>
        <div id="miniGrid"></div>
        <div id="gameModeLabel">Game Mode</div>
        <div id="gameModeButtons">
            <button id="start1Player">Human</button>
            <button id="startAIMode">AI</button>
        </div>
        <div id="gridSizeLabel">Grid Size</div>
        <div id="gridSizeButtons">
            <button id="gridSmall">Small</button>
            <button id="gridMedium" class="selected">Medium</button>
            <button id="gridLarge">Large</button>
            <button id="gridLudicrous">Ludicrous</button>
        </div>
        <div id="speedLabel">Game Speed</div>
        <div id="speedButtons">
            <button id="speedSlow" class="selected">Slow</button>
            <button id="speedMedium">Medium</button>
            <button id="speedFast">Fast</button>
        </div>
    </div>
    <div id="fadeOverlay"></div>
    <div id="titleBar">
        <h1>tronAIx</h1>
        <div id="speedStats">
            Time: <span id="timer">0</span>s<br>
            Speed: <span id="speed">1</span> (Next in <span id="countdown">5</span>s)
        </div>
    </div>
    <div id="buttonContainer">
        <button id="gameRestartButton">Restart</button>
        <button id="cameraButton">Cycle</button>
        <button id="speedButton">Speed</button>
    </div>
    <div id="ui">
        <div id="redStats">
            <div>Score: <span id="redScore">0</span></div>
            <div>Distance: <span id="redDistance">0</span></div>
            <div>Grid Covered: <span id="redGrid">0</span></div>
            <div>Walls: <span id="redWalls">0</span></div>
        </div>
        <div id="blueStats">
            <div>Score: <span id="blueScore">0</span></div>
            <div>Distance: <span id="blueDistance">0</span></div>
            <div>Grid Covered: <span id="blueGrid">0</span></div>
            <div>Walls: <span id="blueWalls">0</span></div>
        </div>
    </div>
    <div id="gameOver">
        <div id="gameOverTitle">Game Over!</div>
        <br/>
        <div>Winner: <span id="winner"></span></div>
        <div>Loser: <span id="loser"></span> <p>(Player Trapped)</p></div>
        <div>Traveled: <span id="winnerDistance"></span></div>
        <div>Area Covered: <span id="winnerGrid"></span></div>
        <div>Walls: <span id="winnerWalls"></span></div>
        <div>Red Score: <span id="redScoreValue" class="scoreValue"></span></div>
        <div>Blue Score: <span id="blueScoreValue" class="scoreValue"></span></div>
        <button id="restartButton">Restart</button>
    </div>
    <div id="bonusMessage"></div>
    <div id="countdownDisplay"></div>
    <div id="controlBox">
        <span id="controlBoxText">Touch to move</span>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Star field for welcome screen
        const starField = document.getElementById('starField');
        for (let i = 0; i < 200; i++) {
            const star = document.createElement('div');
            star.className = 'star';
            const size = Math.random() * 3 + 1;
            star.style.width = `${size}px`;
            star.style.height = `${size}px`;
            star.style.left = `${Math.random() * 100}%`;
            star.style.top = `${Math.random() * 100}%`;
            star.style.animationDelay = `${Math.random() * 3}s`;
            starField.appendChild(star);
        }

        // Mini grid setup
        const miniGridSize = 10;
        const miniGrid = [];
        const miniGridDiv = document.getElementById('miniGrid');
        for (let x = 0; x < miniGridSize; x++) {
            miniGrid[x] = [];
            for (let y = 0; y < miniGridSize; y++) {
                const cell = document.createElement('div');
                cell.className = 'miniGridCell';
                miniGridDiv.appendChild(cell);
                miniGrid[x][y] = { element: cell, visits: 0, owner: null, isWall: false };
            }
        }

        // Mini grid players
        const miniRedPlayer = document.createElement('div');
        miniRedPlayer.id = 'miniRedPlayer';
        miniRedPlayer.className = 'miniGridPlayer';
        miniGrid[2][2].element.appendChild(miniRedPlayer);

        const miniBluePlayer = document.createElement('div');
        miniBluePlayer.id = 'miniBluePlayer';
        miniBluePlayer.className = 'miniGridPlayer';
        miniGrid[7][7].element.appendChild(miniBluePlayer);

        const miniPlayer1 = { x: 2, y: 2, color: '#ff0000', direction: 'right', element: miniRedPlayer };
        const miniPlayer2 = { x: 7, y: 7, color: '#00b7eb', direction: 'left', element: miniBluePlayer };

        function resetMiniGrid() {
            for (let x = 0; x < miniGridSize; x++) {
                for (let y = 0; y < miniGridSize; y++) {
                    const cell = miniGrid[x][y];
                    cell.visits = 0;
                    cell.owner = null;
                    cell.isWall = false;
                    const trail = cell.element.querySelector('.miniGridTrail');
                    if (trail) trail.remove();
                    const wall = cell.element.querySelector('.miniGridWall');
                    if (wall) wall.remove();
                }
            }
            miniPlayer1.x = 2;
            miniPlayer1.y = 2;
            miniPlayer1.direction = 'right';
            miniPlayer1.element.remove();
            miniGrid[2][2].element.appendChild(miniPlayer1.element);

            miniPlayer2.x = 7;
            miniPlayer2.y = 7;
            miniPlayer2.direction = 'left';
            miniPlayer2.element.remove();
            miniGrid[7][7].element.appendChild(miniPlayer2.element);
        }

        function getMiniRandomDirection(currentDirection) {
            const directions = ['up', 'down', 'left', 'right'];
            const opposites = { 'up': 'down', 'down': 'up', 'left': 'right', 'right': 'left' };
            const validDirections = directions.filter(dir => dir !== opposites[currentDirection]);
            return validDirections[Math.floor(Math.random() * validDirections.length)];
        }

        function moveMiniPlayer(player, otherPlayer) {
            let newX = player.x;
            let newY = player.y;

            if (player.direction === 'up') newY--;
            if (player.direction === 'down') newY++;
            if (player.direction === 'left') newX--;
            if (player.direction === 'right') newX++;

            if (newX === otherPlayer.x && newY === otherPlayer.y) {
                player.direction = getMiniRandomDirection(player.direction);
                return;
            }

            if (newX >= 0 && newX < miniGridSize && newY >= 0 && newY < miniGridSize && !miniGrid[newX][newY].isWall) {
                player.element.remove();
                player.x = newX;
                player.y = newY;
                miniGrid[player.x][player.y].element.appendChild(player.element);

                const cell = miniGrid[player.x][player.y];
                cell.visits++;
                if (cell.owner !== player) {
                    if (cell.owner && cell.element.querySelector('.miniGridTrail')) {
                        cell.element.querySelector('.miniGridTrail').remove();
                    }
                    cell.owner = player;
                    const trail = document.createElement('div');
                    trail.className = 'miniGridTrail';
                    trail.style.background = player.color;
                    cell.element.appendChild(trail);
                }
                if (cell.visits >= 3) {
                    cell.isWall = true;
                    if (cell.element.querySelector('.miniGridTrail')) {
                        cell.element.querySelector('.miniGridTrail').remove();
                    }
                    const wall = document.createElement('div');
                    wall.className = 'miniGridWall';
                    wall.style.background = player.color;
                    cell.element.appendChild(wall);
                }
            } else {
                player.direction = getMiniRandomDirection(player.direction);
            }
        }

        function animateMiniGrid() {
            if (document.getElementById('welcomeScreen').style.display === 'none') return;
            if (Math.random() < 0.3) {
                miniPlayer1.direction = getMiniRandomDirection(miniPlayer1.direction);
            }
            if (Math.random() < 0.3) {
                miniPlayer2.direction = getMiniRandomDirection(miniPlayer2.direction);
            }
            moveMiniPlayer(miniPlayer1, miniPlayer2);
            moveMiniPlayer(miniPlayer2, miniPlayer1);
            setTimeout(animateMiniGrid, 200);
        }
        animateMiniGrid();

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Star field setup
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 1000;
        const starPositions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount * 3; i += 3) {
            starPositions[i] = (Math.random() - 0.5) * 2000;
            starPositions[i + 1] = (Math.random() - 0.5) * 2000;
            starPositions[i + 2] = (Math.random() - 0.5) * 2000;
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({ 
            color: 0xffffff, 
            size: 2, 
            sizeAttenuation: true 
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Lighting for neon effect
        const ambientLight = new THREE.AmbientLight(0x202020);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
        directionalLight.position.set(0, 10, 10);
        scene.add(directionalLight);

        // Grid size selection
        let gridSize = 30;
        const gridSizeButtons = document.querySelectorAll('#gridSizeButtons button');
        gridSizeButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                gridSizeButtons.forEach(btn => btn.classList.remove('selected'));
                e.target.classList.add('selected');
                if (e.target.id === 'gridSmall') gridSize = 20;
                if (e.target.id === 'gridMedium') gridSize = 30;
                if (e.target.id === 'gridLarge') gridSize = 40;
                if (e.target.id === 'gridLudicrous') gridSize = 60;
            });
        });

        // Game speed selection
        let selectedSpeed = 0.5;
        const speedButtons = document.querySelectorAll('#speedButtons button');
        speedButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                speedButtons.forEach(btn => btn.classList.remove('selected'));
                e.target.classList.add('selected');
                if (e.target.id === 'speedSlow') selectedSpeed = 0.5;
                if (e.target.id === 'speedMedium') selectedSpeed = 1;
                if (e.target.id === 'speedFast') selectedSpeed = 2;
            });
        });

        // Grid setup
        let grid = [];
        function setupGrid() {
            grid.forEach(row => row.forEach(cell => scene.remove(cell.mesh)));
            grid = [];

            for (let x = 0; x < gridSize; x++) {
                grid[x] = [];
                for (let z = 0; z < gridSize; z++) {
                    const geometry = new THREE.PlaneGeometry(1, 1);
                    const material = new THREE.MeshStandardMaterial({ 
                        color: 0x111111, 
                        side: THREE.DoubleSide, 
                        transparent: true, 
                        opacity: 0,
                        emissive: 0x111111,
                        emissiveIntensity: 0.5
                    });
                    const plane = new THREE.Mesh(geometry, material);
                    plane.position.set(x - gridSize / 2, 0, z - gridSize / 2);
                    plane.rotation.x = Math.PI / 2;
                    scene.add(plane);
                    grid[x][z] = { mesh: plane, color: 0x111111, visits: 0, owner: null, isWall: false };
                }
            }

            scene.remove(gridLines);
            const gridLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ff00, 
                emissive: 0x00ff00, 
                emissiveIntensity: 1, 
                transparent: true, 
                opacity: 0,
                linewidth: 2
            });
            gridLines = new THREE.Group();
            for (let i = 0; i <= gridSize; i++) {
                const pointsH = [
                    new THREE.Vector3(i - gridSize / 2, 0.01, -gridSize / 2),
                    new THREE.Vector3(i - gridSize / 2, 0.01, gridSize / 2)
                ];
                const pointsV = [
                    new THREE.Vector3(-gridSize / 2, 0.01, i - gridSize / 2),
                    new THREE.Vector3(gridSize / 2, 0.01, i - gridSize / 2)
                ];
                const geometryH = new THREE.BufferGeometry().setFromPoints(pointsH);
                const geometryV = new THREE.BufferGeometry().setFromPoints(pointsV);
                const lineH = new THREE.Line(geometryH, gridLineMaterial);
                const lineV = new THREE.Line(geometryV, gridLineMaterial);
                gridLines.add(lineH, lineV);
            }
            scene.add(gridLines);
        }
        let gridLines = new THREE.Group();
        setupGrid();

        // Players setup
        function getInitialPlayerPositions() {
            if (gridSize === 20) {
                return {
                    player1: { x: 5, z: 5 },
                    player2: { x: 10, z: 10 }
                };
            }
            return {
                player1: { x: Math.floor(gridSize / 4), z: Math.floor(gridSize / 4) },
                player2: { x: Math.floor(3 * gridSize / 4), z: Math.floor(3 * gridSize / 4) }
            };
        }

        const initialPositions = getInitialPlayerPositions();
        const player1 = { 
            x: initialPositions.player1.x, 
            z: initialPositions.player1.z, 
            color: 0xff0000, 
            direction: 'right', 
            distance: 0, 
            lastPos: { x: initialPositions.player1.x, z: initialPositions.player1.z }, 
            gridCovered: 0, 
            wallsMade: 0, 
            score: 0,
            lastMoveTime: performance.now(),
            isThrobbing: false
        };
        const player2 = { 
            x: initialPositions.player2.x, 
            z: initialPositions.player2.z, 
            color: 0x00b7eb, 
            direction: 'left', 
            distance: 0, 
            lastPos: { x: initialPositions.player2.x, z: initialPositions.player2.z }, 
            gridCovered: 0, 
            wallsMade: 0, 
            score: 0,
            lastMoveTime: performance.now(),
            isThrobbing: false
        };

        const player1Geometry = new THREE.BoxGeometry(0.8, 0.2, 0.8);
        const player1Material = new THREE.MeshStandardMaterial({ 
            color: player1.color, 
            emissive: player1.color, 
            emissiveIntensity: 0.8, 
            metalness: 0.2, 
            roughness: 0.8,
            transparent: true,
            opacity: 0
        });
        const player1Mesh = new THREE.Mesh(player1Geometry, player1Material);
        player1Mesh.position.set(player1.x - gridSize / 2, 0.1, player1.z - gridSize / 2);
        scene.add(player1Mesh);

        const player1BorderGeometry = new THREE.EdgesGeometry(player1Geometry);
        const player1BorderMaterial = new THREE.LineBasicMaterial({ 
            color: 0xffffff, 
            emissive: 0xffffff, 
            emissiveIntensity: 1,
            transparent: true,
            opacity: 0
        });
        const player1Border = new THREE.LineSegments(player1BorderGeometry, player1BorderMaterial);
        player1Mesh.add(player1Border);

        const player2Geometry = new THREE.BoxGeometry(0.8, 0.2, 0.8);
        const player2Material = new THREE.MeshStandardMaterial({ 
            color: player2.color, 
            emissive: player2.color, 
            emissiveIntensity: 0.8, 
            metalness: 0.2, 
            roughness: 0.8,
            transparent: true,
            opacity: 0
        });
        const player2Mesh = new THREE.Mesh(player2Geometry, player2Material);
        player2Mesh.position.set(player2.x - gridSize / 2, 0.1, player2.z - gridSize / 2);
        scene.add(player2Mesh);

        const player2BorderGeometry = new THREE.EdgesGeometry(player2Geometry);
        const player2BorderMaterial = new THREE.LineBasicMaterial({ 
            color: 0xffffff, 
            emissive: 0xffffff, 
            emissiveIntensity: 1,
            transparent: true,
            opacity: 0
        });
        const player2Border = new THREE.LineSegments(player2BorderGeometry, player2BorderMaterial);
        player2Mesh.add(player2Border);

        // Camera position and modes
        let cameraMode = 'grid';
        const cameraModes = ['grid', 'followPlayer1', 'followPlayer2', 'birdsEye', 'flyAround'];
        let flyAngle = 0;

        function updateCamera() {
            const gridViewPos = new THREE.Vector3(0, gridSize * 0.75, gridSize * 0.5);
            const gridViewTarget = new THREE.Vector3(0, 0, 0);
            const birdsEyePos = new THREE.Vector3(0, gridSize * 1.25, 0);
            const birdsEyeTarget = new THREE.Vector3(0, 0, 0);

            if (cameraMode === 'grid') {
                camera.position.copy(gridViewPos);
                camera.lookAt(gridViewTarget);
            } else if (cameraMode === 'followPlayer1') {
                camera.position.set(
                    player1Mesh.position.x - gridSize * 0.1,
                    player1Mesh.position.y + gridSize * 0.05,
                    player1Mesh.position.z + gridSize * 0.1
                );
                camera.lookAt(player1Mesh.position);
            } else if (cameraMode === 'followPlayer2') {
                camera.position.set(
                    player2Mesh.position.x - gridSize * 0.1,
                    player2Mesh.position.y + gridSize * 0.05,
                    player2Mesh.position.z + gridSize * 0.1
                );
                camera.lookAt(player2Mesh.position);
            } else if (cameraMode === 'birdsEye') {
                camera.position.copy(birdsEyePos);
                camera.lookAt(birdsEyeTarget);
            } else if (cameraMode === 'flyAround') {
                flyAngle += 0.01;
                const radius = gridSize * 0.75;
                const height = gridSize * 0.5 + Math.sin(flyAngle * 0.5) * (gridSize * 0.125);
                camera.position.set(
                    Math.cos(flyAngle) * radius,
                    height,
                    Math.sin(flyAngle) * radius
                );
                camera.lookAt(gridViewTarget);
            }
        }

        // Game mode
        let is1PlayerMode = false;

        // Handle input for red player direction in 1 Player Mode
        function handleInput(event) {
            if (document.getElementById('welcomeScreen').style.display !== 'none' || !is1PlayerMode) return;

            const controlBox = document.getElementById('controlBox');
            const controlBoxText = document.getElementById('controlBoxText');
            const rect = controlBox.getBoundingClientRect();
            const clientX = event.type.includes('touch') ? event.touches[0].clientX : event.clientX;
            const clientY = event.type.includes('touch') ? event.touches[0].clientY : event.clientY;

            if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
                const relativeX = clientX - rect.left;
                const relativeY = clientY - rect.top;
                const boxWidth = rect.width;
                const boxHeight = rect.height;

                const edgeThreshold = 0.3;

                if (relativeX < boxWidth * edgeThreshold) {
                    player1.direction = 'left';
                    controlBoxText.textContent = 'Left';
                } else if (relativeX > boxWidth * (1 - edgeThreshold)) {
                    player1.direction = 'right';
                    controlBoxText.textContent = 'Right';
                } else if (relativeY < boxHeight * edgeThreshold) {
                    player1.direction = 'up';
                    controlBoxText.textContent = 'Up';
                } else if (relativeY > boxHeight * (1 - edgeThreshold)) {
                    player1.direction = 'down';
                    controlBoxText.textContent = 'Down';
                } else {
                    controlBoxText.textContent = 'Touch edges';
                }
            }
        }

        // Camera toggle and speed boost
        let lastTap = 0;
        document.addEventListener('touchstart', (e) => {
            if (document.getElementById('welcomeScreen').style.display !== 'none') return;
            const now = performance.now();
            if (now - lastTap < 300) {
                updateInterval = baseUpdateInterval / (speedMultiplier * 2);
                setTimeout(() => { updateInterval = baseUpdateInterval / speedMultiplier; }, 5000);
            } else if (!is1PlayerMode) {
                const currentIndex = cameraModes.indexOf(cameraMode);
                cameraMode = cameraModes[(currentIndex + 1) % cameraModes.length];
                updateCamera();
            }
            handleInput(e);
            lastTap = now;
        });

        document.addEventListener('click', (e) => {
            if (document.getElementById('welcomeScreen').style.display !== 'none') return;
            handleInput(e);
        });

        // Camera cycle button
        document.getElementById('cameraButton').addEventListener('click', () => {
            const currentIndex = cameraModes.indexOf(cameraMode);
            cameraMode = cameraModes[(currentIndex + 1) % cameraModes.length];
            updateCamera();
        });

        // Speed increase button
        document.getElementById('speedButton').addEventListener('click', () => {
            speedMultiplier += 0.5;
            updateInterval = baseUpdateInterval / speedMultiplier;
        });

        // Initial camera position
        updateCamera();

        // Random direction change
        function getRandomDirection(currentDirection) {
            const directions = ['up', 'down', 'left', 'right'];
            const opposites = { 'up': 'down', 'down': 'up', 'left': 'right', 'right': 'left' };
            const validDirections = directions.filter(dir => dir !== opposites[currentDirection]);
            return validDirections[Math.floor(Math.random() * validDirections.length)];
        }

        // Check if player is trapped
        function isTrapped(player, otherPlayer) {
            const directions = [
                { dir: 'up', x: player.x, z: player.z - 1 },
                { dir: 'down', x: player.x, z: player.z + 1 },
                { dir: 'left', x: player.x - 1, z: player.z },
                { dir: 'right', x: player.x + 1, z: player.z }
            ];
            return directions.every(({ x, z }) => 
                x < 0 || x >= gridSize || z < 0 || z >= gridSize || grid[x][z].isWall
            );
        }

        // Check for adjacent walls
        function hasAdjacentWall(x, z) {
            const neighbors = [
                { x: x, z: z - 1 },
                { x: x, z: z + 1 },
                { x: x - 1, z: z },
                { x: x + 1, z: z }
            ];
            return neighbors.some(({ x, z }) => 
                x >= 0 && x < gridSize && z >= 0 && z < gridSize && grid[x][z].isWall
            );
        }

        // Find a valid nearby cell
        function findValidNearbyCell(player, otherPlayer) {
            const searchDist = gridSize === 20 ? 2 : 1;
            const directions = [];
            for (let dx = -searchDist; dx <= searchDist; dx++) {
                for (let dz = -searchDist; dz <= searchDist; dz++) {
                    if (dx === 0 && dz === 0) continue;
                    const x = player.x + dx;
                    const z = player.z + dz;
                    let dir = 'right';
                    if (dx < 0) dir = 'left';
                    else if (dx > 0) dir = 'right';
                    else if (dz < 0) dir = 'up';
                    else if (dz > 0) dir = 'down';
                    directions.push({ x, z, dir });
                }
            }
            for (const { x, z, dir } of directions) {
                if (x >= 0 && x < gridSize && z >= 0 && z < gridSize && !grid[x][z].isWall && !(x === otherPlayer.x && z === otherPlayer.z)) {
                    return { x, z, dir };
                }
            }
            // Fallback to reset position
            for (let x = 0; x < gridSize; x++) {
                for (let z = 0; z < gridSize; z++) {
                    if (!grid[x][z].isWall && !(x === otherPlayer.x && z === otherPlayer.z)) {
                        return { x, z, dir: getRandomDirection(player.direction) };
                    }
                }
            }
            return null;
        }

        // Display bonus message
        function showBonusMessage(message, color) {
            const bonusDiv = document.getElementById('bonusMessage');
            bonusDiv.textContent = message;
            bonusDiv.style.color = color;
            bonusDiv.style.display = 'block';
            setTimeout(() => { bonusDiv.style.display = 'none'; }, 1000);
        }

        // Reset game state
        function resetGame() {
            const initialPositions = getInitialPlayerPositions();
            player1.x = initialPositions.player1.x;
            player1.z = initialPositions.player1.z;
            player1.direction = 'right';
            player1.distance = 0;
            player1.lastPos = { x: initialPositions.player1.x, z: initialPositions.player1.z };
            player1.gridCovered = 0;
            player1.wallsMade = 0;
            player1.score = 0;
            player1.lastMoveTime = performance.now();
            player1.isThrobbing = false;
            player1Mesh.position.set(player1.x - gridSize / 2, 0.1, player1.z - gridSize / 2);
            player1Mesh.className = '';

            player2.x = initialPositions.player2.x;
            player2.z = initialPositions.player2.z;
            player2.direction = 'left';
            player2.distance = 0;
            player2.lastPos = { x: initialPositions.player2.x, z: initialPositions.player2.z };
            player2.gridCovered = 0;
            player2.wallsMade = 0;
            player2.score = 0;
            player2.lastMoveTime = performance.now();
            player2.isThrobbing = false;
            player2Mesh.position.set(player2.x - gridSize / 2, 0.1, player2.z - gridSize / 2);
            player2Mesh.className = '';

            setupGrid();
            grid.forEach(row => row.forEach(cell => {
                cell.mesh.material.color.setHex(0x111111);
                cell.mesh.material.opacity = 0;
                cell.mesh.material.emissive.setHex(0x111111);
                cell.mesh.position.y = 0;
                cell.color = 0x111111;
                cell.visits = 0;
                cell.owner = null;
                cell.isWall = false;
            }));

            gridLines.children.forEach(line => {
                line.material.opacity = 0;
            });
            player1Mesh.material.opacity = 0;
            player1Border.material.opacity = 0;
            player2Mesh.material.opacity = 0;
            player2Border.material.opacity = 0;

            resetMiniGrid();

            document.getElementById('controlBox').style.display = 'none';
            document.getElementById('controlBoxText').textContent = 'Touch to move';

            gameOver = false;
            gameStarted = false;
            gameStartTime = 0;
            speedMultiplier = selectedSpeed;
            updateInterval = baseUpdateInterval / speedMultiplier;
            lastSpeedIncrease = performance.now();

            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('welcomeScreen').style.display = 'flex';
            document.getElementById('fadeOverlay').style.display = 'block';
            document.getElementById('fadeOverlay').style.opacity = '1';
        }

        // End game
        let gameOver = false;
        let gameStartTime = 0;
        function endGame(winner, loser) {
            gameOver = true;
            cameraMode = 'flyAround';
            const gameOverDiv = document.getElementById('gameOver');
            gameOverDiv.style.display = 'block';
            document.getElementById('winner').textContent = winner === player1 ? 'Red' : 'Blue';
            document.getElementById('winner').style.color = winner === player1 ? '#ff0000' : '#00b7eb';
            document.getElementById('loser').textContent = loser === player1 ? 'Red' : 'Blue';
            document.getElementById('loser').style.color = loser === player1 ? '#ff0000' : '#00b7eb';
            document.getElementById('winnerDistance').textContent = winner.distance;
            document.getElementById('winnerGrid').textContent = winner.gridCovered;
            document.getElementById('winnerWalls').textContent = winner.wallsMade;
            document.getElementById('redScoreValue').textContent = player1.score;
            document.getElementById('blueScoreValue').textContent = player2.score;
            document.getElementById('controlBox').style.display = 'none';
        }

        // Restart button handler for game over
        document.getElementById('restartButton').addEventListener('click', (e) => {
            e.stopPropagation();
            resetGame();
        });

        // In-game restart button handler
        document.getElementById('gameRestartButton').addEventListener('click', (e) => {
            e.stopPropagation();
            gameOver = true;
            cameraMode = 'flyAround';
            const gameOverDiv = document.getElementById('gameOver');
            gameOverDiv.style.display = 'block';
            document.getElementById('winner').textContent = 'None';
            document.getElementById('winner').style.color = '#ffffff';
            document.getElementById('loser').textContent = 'None';
            document.getElementById('loser').style.color = '#ffffff';
            document.getElementById('winnerDistance').textContent = 'N/A';
            document.getElementById('winnerGrid').textContent = 'N/A';
            document.getElementById('winnerWalls').textContent = 'N/A';
            document.getElementById('redScoreValue').textContent = player1.score;
            document.getElementById('blueScoreValue').textContent = player2.score;
            document.getElementById('controlBox').style.display = 'none';
        });

        // Speed control
        let baseUpdateInterval = 100;
        let updateInterval = baseUpdateInterval;
        let speedMultiplier = selectedSpeed;
        let lastSpeedIncrease = performance.now();

        // Timer and UI
        let startTime = performance.now();
        function updateUI() {
            const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
            const timeToNextIncrease = (5 - ((performance.now() - lastSpeedIncrease) / 1000)).toFixed(1);
            document.getElementById('timer').textContent = elapsed;
            document.getElementById('redScore').textContent = player1.score;
            document.getElementById('redDistance').textContent = player1.distance;
            document.getElementById('redGrid').textContent = player1.gridCovered;
            document.getElementById('redWalls').textContent = player1.wallsMade;
            document.getElementById('blueScore').textContent = player2.score;
            document.getElementById('blueDistance').textContent = player2.distance;
            document.getElementById('blueGrid').textContent = player2.gridCovered;
            document.getElementById('blueWalls').textContent = player2.wallsMade;
            document.getElementById('speed').textContent = speedMultiplier.toFixed(1);
            document.getElementById('countdown').textContent = is1PlayerMode ? 'N/A' : (timeToNextIncrease > 0 ? timeToNextIncrease : 0);
        }

        // Fade-in grid
        function fadeInGrid(duration) {
            const startTime = performance.now();
            function animateFade() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const gridOpacity = progress * 0.5;
                const lineOpacity = progress * 0.5;
                const playerOpacity = progress;

                for (let x = 0; x < gridSize; x++) {
                    for (let z = 0; z < gridSize; z++) {
                        grid[x][z].mesh.material.opacity = gridOpacity;
                    }
                }

                gridLines.children.forEach(line => {
                    line.material.opacity = lineOpacity;
                });

                player1Mesh.material.opacity = playerOpacity;
                player1Border.material.opacity = playerOpacity;
                player2Mesh.material.opacity = playerOpacity;
                player2Border.material.opacity = playerOpacity;

                if (progress < 1) {
                    requestAnimationFrame(animateFade);
                }
            }
            requestAnimationFrame(animateFade);
        }

        // Render loop for countdown
        function renderDuringCountdown() {
            if (document.getElementById('countdownDisplay').style.display === 'block') {
                updateCamera();
                renderer.render(scene, camera);
                requestAnimationFrame(renderDuringCountdown);
            }
        }

        // Render loop for game over
        function renderGameOver() {
            if (document.getElementById('gameOver').style.display === 'block') {
                updateCamera();
                renderer.render(scene, camera);
                requestAnimationFrame(renderGameOver);
            }
        }

        // Countdown setup
        let gameStarted = false;
        function startCountdown() {
            const countdownDiv = document.getElementById('countdownDisplay');
            const fadeOverlay = document.getElementById('fadeOverlay');
            countdownDiv.style.display = 'block';
            fadeOverlay.style.opacity = '1';
            let countdown = 3;
            countdownDiv.textContent = countdown;

            fadeInGrid(4000);
            setTimeout(() => {
                fadeOverlay.style.opacity = '0';
            }, 0);

            renderDuringCountdown();

            const countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownDiv.textContent = countdown;
                } else {
                    countdownDiv.textContent = 'Go!';
                    setTimeout(() => {
                        countdownDiv.style.display = 'none';
                        fadeOverlay.style.display = 'none';
                        document.getElementById('controlBox').style.display = is1PlayerMode ? 'flex' : 'none';
                        gameStarted = true;
                        gameStartTime = performance.now();
                        startTime = performance.now();
                        animate();
                    }, 1000);
                    clearInterval(countdownInterval);
                }
            }, 1000);
        }

        // Game loop
        let lastUpdate = performance.now();
        function animate() {
            if (!gameStarted || gameOver) {
                if (gameOver) renderGameOver();
                return;
            }
            requestAnimationFrame(animate);
            const now = performance.now();

            if (!is1PlayerMode && now - lastSpeedIncrease >= 5000) {
                speedMultiplier += 0.5;
                updateInterval = baseUpdateInterval / speedMultiplier;
                lastSpeedIncrease = now;
            }

            updateInterval = gridSize === 20 ? baseUpdateInterval / (speedMultiplier * 1.2) : baseUpdateInterval / speedMultiplier;

            if (now - lastUpdate >= updateInterval) {
                if (!is1PlayerMode) {
                    if (Math.random() < 0.3) {
                        player1.direction = getRandomDirection(player1.direction);
                    }
                }
                const directionChangeProbability = gridSize === 20 ? 0.4 : 0.3;
                if (Math.random() < directionChangeProbability) {
                    player2.direction = getRandomDirection(player2.direction);
                }

                function movePlayer(player, mesh, otherPlayer) {
                    let newX = player.x;
                    let newZ = player.z;

                    if (player.direction === 'up') newZ--;
                    if (player.direction === 'down') newZ++;
                    if (player.direction === 'left') newX--;
                    if (player.direction === 'right') newX++;

                    if (newX === otherPlayer.x && newZ === otherPlayer.z) {
                        if (!is1PlayerMode || player !== player1) {
                            const directions = [
                                { dir: 'up', x: player.x, z: player.z - 1 },
                                { dir: 'down', x: player.x, z: player.z + 1 },
                                { dir: 'left', x: player.x - 1, z: player.z },
                                { dir: 'right', x: player.x + 1, z: player.z }
                            ];
                            let validDirection = null;
                            for (const { dir, x, z } of directions) {
                                if (x >= 0 && x < gridSize && z >= 0 && z < gridSize && !grid[x][z].isWall && !(x === otherPlayer.x && z === otherPlayer.z)) {
                                    validDirection = dir;
                                    break;
                                }
                            }
                            player.direction = validDirection || getRandomDirection(player.direction);
                        }
                        return;
                    }

                    if (newX >= 0 && newX < gridSize && newZ >= 0 && newZ < gridSize && !grid[newX][newZ].isWall) {
                        player.x = newX;
                        player.z = newZ;

                        if (player.x !== player.lastPos.x || player.z !== player.lastPos.z) {
                            player.distance++;
                            player.score += 1;
                            player.lastPos = { x: player.x, z: player.z };
                            player.lastMoveTime = now;
                            player.isThrobbing = false;
                            mesh.className = '';
                        }

                        const cell = grid[player.x][player.z];
                        cell.visits++;
                        if (cell.owner !== player) {
                            if (cell.owner === player1) player1.gridCovered--;
                            if (cell.owner === player2) player2.gridCovered--;
                            cell.owner = player;
                            player.gridCovered++;
                        }
                        const wallVisitThreshold = gridSize === 20 ? 8 : 5;
                        if (cell.visits >= wallVisitThreshold) {
                            cell.isWall = true;
                            cell.mesh.position.y = 0.02;
                            cell.mesh.material.opacity = 0.9;
                            cell.mesh.material.emissive.setHex(player.color);
                            cell.mesh.material.emissiveIntensity = 0.8;
                            player.wallsMade++;
                            player.score += 10;
                            showBonusMessage('+10 Wall Bonus!', player === player1 ? '#ff0000' : '#00b7eb');
                            if (hasAdjacentWall(player.x, player.z)) {
                                player.score += 50;
                                showBonusMessage('+50 Adjacent Wall Bonus!', player === player1 ? '#ff0000' : '#00b7eb');
                            }
                        }
                        const intensity = Math.min(cell.visits * 0.4, 1);
                        const r = Math.floor((player.color >> 16) * intensity);
                        const g = Math.floor(((player.color >> 8) & 0xff) * intensity);
                        const b = Math.floor((player.color & 0xff) * intensity);
                        const newColor = (r << 16) | (g << 8) | b;
                        cell.mesh.material.color.setHex(newColor);
                        cell.mesh.material.opacity = cell.isWall ? 0.9 : 0.5 + intensity * 0.4;
                        cell.color = newColor;

                        const targetPos = new THREE.Vector3(player.x - gridSize / 2, 0.1, player.z - gridSize / 2);
                        mesh.position.lerp(targetPos, 0.9);
                    } else if (!is1PlayerMode || player !== player1) {
                        const directions = [
                            { dir: 'up', x: player.x, z: player.z - 1 },
                            { dir: 'down', x: player.x, z: player.z + 1 },
                            { dir: 'left', x: player.x - 1, z: player.z },
                            { dir: 'right', x: player.x + 1, z: player.z }
                        ];
                        let validDirection = null;
                        for (const { dir, x, z } of directions) {
                            if (x >= 0 && x < gridSize && z >= 0 && z < gridSize && !grid[x][z].isWall && !(x === otherPlayer.x && z === otherPlayer.z)) {
                                validDirection = dir;
                                break;
                            }
                        }
                        if (validDirection) {
                            player.direction = validDirection;
                        } else {
                            const fallback = findValidNearbyCell(player, otherPlayer);
                            if (fallback) {
                                player.x = fallback.x;
                                player.z = fallback.z;
                                player.direction = fallback.dir;
                                player.distance++;
                                player.score += 1;
                                player.lastPos = { x: player.x, z: player.z };
                                player.lastMoveTime = now;
                                player.isThrobbing = false;
                                mesh.className = '';
                                const targetPos = new THREE.Vector3(player.x - gridSize / 2, 0.1, player.z - gridSize / 2);
                                mesh.position.lerp(targetPos, 0.9);
                            } else {
                                player.direction = getRandomDirection(player.direction);
                            }
                        }
                    }

                    if (now - gameStartTime >= 5000 && isTrapped(player, otherPlayer)) {
                        endGame(otherPlayer, player);
                    }
                }

                movePlayer(player1, player1Mesh, player2);
                movePlayer(player2, player2Mesh, player1);

                lastUpdate = now;
            }

            updateCamera();
            updateUI();
            renderer.render(scene, camera);
        }

        // Welcome screen button handlers
        document.getElementById('start1Player').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('welcomeScreen').style.display = 'none';
            is1PlayerMode = true;
            setupGrid();
            speedMultiplier = selectedSpeed;
            updateInterval = baseUpdateInterval / speedMultiplier;
            startCountdown();
        });

        document.getElementById('startAIMode').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('welcomeScreen').style.display = 'none';
            is1PlayerMode = false;
            setupGrid();
            speedMultiplier = selectedSpeed;
            updateInterval = baseUpdateInterval / speedMultiplier;
            startCountdown();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
