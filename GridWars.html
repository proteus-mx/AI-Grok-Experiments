<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Dot Connect Game</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background: #000; }
        canvas { display: block; }
        #welcome, #game-over, #exit-confirm { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            color: #fff; text-align: center; 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
        }
        #welcome, #exit-confirm { 
            background: rgba(0, 0, 0, 0.85); 
        }
        #game-over { 
            background: rgba(0, 0, 0, 0.7);
        }
        #game-over > div {
            background: rgba(0, 0, 0, 0.5); 
            padding: 20px; 
            border: 1px solid rgba(255, 255, 255, 0.3); 
            border-radius: 10px; 
            width: 80%;
        }
        #exit-confirm { display: none; }
        #welcome button, #game-over button, #camera-toggle, #undo-button, #exit-button, #sound-toggle, #hint-toggle, #exit-yes, #exit-no { 
            margin: 10px; padding: 6px 12px; font-size: 12px; cursor: pointer; 
            background: #00ff00; color: #000; border: none; border-radius: 8px; 
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5); transition: transform 0.2s; 
        }
        #welcome button:hover, #game-over button:hover, #camera-toggle:hover, #undo-button:hover, #exit-button:hover, #sound-toggle:hover, #hint-toggle:hover, #exit-yes:hover, #exit-no:hover { 
            background: #00cc00; transform: scale(1.05); 
        }
        #game-stats-container { 
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%); 
            background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px; 
            border: 1px solid rgba(255, 255, 255, 0.3); text-align: center; 
            display: none; 
        }
        #game-title { 
            color: #00ff00; font-size: 18px; text-shadow: 0 0 5px #000; 
            margin: 0; 
        }
        #game-timer { 
            color: #fff; font-size: 14px; text-shadow: 0 0 5px #000; 
            margin: 5px 0; 
        }
        #turn { 
            color: #fff; font-size: 16px; text-shadow: 0 0 5px #000; 
            margin: 5px 0; 
        }
        #moves { 
            color: #fff; font-size: 14px; text-shadow: 0 0 5px #000; 
            margin: 5px 0; 
        }
        #games-won { 
            color: #fff; font-size: 14px; text-shadow: 0 0 5px #000; 
            margin: 5px 0; 
        }
        #red-stats { 
            position: absolute; top: 120px; left: 10px; 
            color: #ff0000; font-size: 14px; text-shadow: 0 0 5px #000; 
            background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px; 
            border: 1px solid rgba(255, 0, 0, 0.3); 
        }
        #blue-stats { 
            position: absolute; top: 120px; right: 10px; 
            color: #0000ff; font-size: 14px; text-shadow: 0 0 5px #000; text-align: right; 
            background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px; 
            border: 1px solid rgba(0, 0, 255, 0.3); 
        }
        #red-stats.flash, #blue-stats.flash { 
            animation: flash 0.5s ease-in-out 3; 
        }
        #button-container { 
            position: absolute; bottom: 30px; right: 10px; display: none; 
            display: flex; gap: 10px; 
        }
        #camera-toggle, #undo-button, #exit-button, #sound-toggle, #hint-toggle { margin: 0; }
        #message { 
            position: absolute; bottom: 70px; left: 50%; transform: translate(-50%, 0); 
            font-size: 28px; display: none; text-shadow: 0 0 5px #000; 
            padding: 10px 20px; width: 80%; background: rgba(0, 0, 0, 0.5); 
            border-radius: 5px; text-align: center; 
        }
        #points-message { 
            position: absolute; font-size: 14px; display: none; text-shadow: 0 0 5px #000; 
            text-align: center; 
        }
        #points-message div {
            width: 150px;
            text-align: center;
        }
        .neutral-message { color: #ffffff; }
        .positive-message { color: #00ff00; }
        .red-message { color: #ff0000; }
        .blue-message { color: #0000ff; }
        .red-points { color: #ff0000; }
        .blue-points { color: #0000ff; }
        .red-winner { color: #ff0000; }
        .blue-winner { color: #0000ff; }
        .tie-winner { color: #ffffff; }
        .flash { animation: flash 0.5s ease-in-out 3; }
        @keyframes flash { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        #game-over { display: none; }
        #progress-bar { 
            position: absolute; bottom: 0; left: 0; width: 100%; height: 20px; display: none; 
            background: #333; font-size: 14px; color: #fff; text-align: center; 
        }
        #progress-red { background: #ff0000; height: 100%; float: left; }
        #progress-blue { background: #0000ff; height: 100%; float: left; }
        #progress-tie { background: #666; height: 100%; float: left; }
        .red-stat { color: #ff0000; }
        .blue-stat { color: #0000ff; }
        .neutral-stat { color: #ffffff; }
        #winner-text { font-size: 36px; }
    </style>
</head>
<body>
    <div id="welcome">
        <h1>3D Dot Connect Game</h1>
        <p>Connect adjacent dots to form glowing lines. Complete a 1x1 square to claim it with your color (Red or Blue). Players keep their turn if they form a box; otherwise, the turn switches. In 1 Player mode, a smart AI plays as Blue. In AI Mode, both players are automated.</p>
        <button onclick="startGame('1player')">1 Player</button>
        <button onclick="startGame('2player')">2 Player</button>
        <button onclick="startGame('ai')">AI Mode</button>
    </div>
    <div id="game-over">
        <div>
            <h1>Game Over</h1>
            <div id="winner-text"></div>
            <div id="final-stats">
                <span class="red-stat">Red: 0 (Score: 0, Time: 0s, Moves: 0)</span><br>
                <span class="blue-stat">Blue: 0 (Score: 0, Time: 0s, Moves: 0)</span><br>
                <span class="neutral-stat">Total Moves: 0</span><br>
                <span class="neutral-stat">Game Time: 0s</span><br>
                <span class="neutral-stat">Games Won - Red: 0, Blue: 0, Tie: 0</span>
            </div>
            <button onclick="resetGame(gameMode, false)">Play Again</button>
        </div>
    </div>
    <div id="exit-confirm" style="display: none;">
        <h2>Are you sure you want to exit?</h2>
        <button id="exit-yes" onclick="resetGame(null, true, false)">Yes</button>
        <button id="exit-no" onclick="document.getElementById('exit-confirm').style.display = 'none';">No</button>
    </div>
    <div id="game-stats-container">
        <div id="game-title">3D Dot Connect</div>
        <div id="game-timer" style="display: none;">Game Time: 0s</div>
        <div id="turn" style="display: none;">Red's Turn</div>
        <div id="moves" style="display: none;">Moves: 0</div>
        <div id="games-won" style="display: none;">Games Won: Red 0, Blue 0, Tie 0</div>
    </div>
    <div id="red-stats" style="display: none;">Red: 0<br>Score: 0<br>Time: 0s<br>Moves: 0</div>
    <div id="blue-stats" style="display: none;">Blue: 0<br>Score: 0<br>Time: 0s<br>Moves: 0</div>
    <div id="button-container">
        <button id="camera-toggle" onclick="toggleCamera()">Fly Camera</button>
        <button id="undo-button" onclick="undoMove()">Undo Move</button>
        <button id="exit-button" onclick="resetGame(null, true, true)">Exit Game</button>
        <button id="sound-toggle" onclick="toggleSound()">Sound On</button>
        <button id="hint-toggle" onclick="toggleHint()">Hint Off</button>
    </div>
    <div id="message"></div>
    <div id="points-message"></div>
    <div id="progress-bar" style="display: none;">
        <div id="progress-red" style="width: 0%;"></div>
        <div id="progress-blue" style="width: 0%;"></div>
        <div id="progress-tie" style="width: 0%;"></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Set up scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add lighting for shaded dots
        const pointLight = new THREE.PointLight(0xffffff, 1, 50);
        pointLight.position.set(0, 0, 12);
        scene.add(pointLight);

        // Game settings
        const gridSize = 5;
        const spacing = 2;
        const maxLines = gridSize * (gridSize - 1) * 2; // 40 lines for 5x5 grid
        const dots = [];
        const lines = [];
        const boxes = [];
        let selectedDot = null;
        let yellowOverlayDot = null;
        let previewLine = null;
        let currentPlayer = 'red';
        let scores = { red: 0, blue: 0 }; // Boxes formed
        let redScore = 0; // Points for lines, boxes, fast moves
        let blueScore = 0;
        let moveCount = 0;
        let redMoves = 0;
        let blueMoves = 0;
        let gameMode = null;
        let gameActive = false;
        let startTime = 0;
        let redTime = 0;
        let blueTime = 0;
        let lastSwitchTime = 0;
        let lastMoveTime = 0;
        let timerInterval = null;
        let throbTime = 0;
        let flashingLines = [];
        let isFlyCamera = false;
        let cameraTime = 0;
        let moveHistory = [];
        let audioCtx = null;
        let gameStats = { red: 0, blue: 0, tie: 0 };
        let soundEnabled = true;
        let hintEnabled = false;
        let hintLine = null;
        let isWelcomeScreen = true;
        let pointsMessages = [];
        let lastIdleReminder = 0;
        let wobbleTime = 0;
        const dotWobbleOffsets = [];

        // Create enhanced starfield
        const starGeometry = new THREE.BufferGeometry();
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true });
        const starPositions = new Float32Array(5000 * 3);
        const starOpacities = new Float32Array(5000);
        for (let i = 0; i < 5000; i++) {
            starPositions[i * 3] = (Math.random() - 0.5) * 150;
            starPositions[i * 3 + 1] = (Math.random() - 0.5) * 150;
            starPositions[i * 3 + 2] = (Math.random() - 0.5) * 150;
            starOpacities[i] = Math.random() * 0.5 + 0.5;
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starGeometry.setAttribute('opacity', new THREE.BufferAttribute(starOpacities, 1));
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Create glowing dots with shading
        const dotGeometry = new THREE.SphereGeometry(0.2, 64, 64);
        const dotMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00, shininess: 100, specular: 0x555555 });
        const validDotMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffff, shininess: 100, specular: 0x555555 });
        const dimDotMaterial = new THREE.MeshPhongMaterial({ color: 0x006600, shininess: 100, specular: 0x555555 });
        const glowMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3 });
        const yellowOverlayMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, shininess: 100, specular: 0x555555 });
        for (let x = 0; x < gridSize; x++) {
            for (let y = 0; y < gridSize; y++) {
                const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                dot.position.set(x * spacing - (gridSize - 1) * spacing / 2, y * spacing - (gridSize - 1) * spacing / 2, 0);
                dot.userData = { x, y, basePosition: dot.position.clone() };
                scene.add(dot);
                const glow = new THREE.Mesh(new THREE.SphereGeometry(0.25, 64, 64), glowMaterial);
                glow.position.copy(dot.position);
                scene.add(glow);
                dots.push(dot);
                dotWobbleOffsets.push({
                    x: (Math.random() - 0.5) * 0.1,
                    y: (Math.random() - 0.5) * 0.1,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }

        // Player-specific tube materials
        const redTubeMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, shininess: 100, specular: 0x555555, transparent: true });
        const blueTubeMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, shininess: 100, specular: 0x555555, transparent: true });
        const hintTubeMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, shininess: 100, specular: 0x555555, transparent: true });

        // Raycaster for mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Audio context initialization
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playSound(frequency, duration, type = 'sine') {
            if (!soundEnabled || !audioCtx) return;
            try {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + duration);
            } catch (e) {
                console.warn('Audio playback failed:', e);
            }
        }

        // Toggle sound on/off
        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('sound-toggle').textContent = soundEnabled ? 'Sound On' : 'Sound Off';
        }

        // Toggle hint on/off
        function toggleHint() {
            hintEnabled = !hintEnabled;
            document.getElementById('hint-toggle').textContent = hintEnabled ? 'Hint On' : 'Hint Off';
            if (hintEnabled && gameActive && (gameMode !== 'ai' && (gameMode !== '1player' || currentPlayer === 'red'))) {
                highlightBestMove();
            } else if (hintLine) {
                scene.remove(hintLine);
                hintLine = null;
            }
        }

        // Highlight the best move with a tube
        function highlightBestMove() {
            if (!hintEnabled || !gameActive || (gameMode === 'ai' || (gameMode === '1player' && currentPlayer === 'blue'))) return;
            if (hintLine) {
                scene.remove(hintLine);
                hintLine = null;
            }
            const validMoves = [];
            const boxClosingMoves = [];
            const blockingMoves = [];
            dots.forEach(dot1 => {
                dots.forEach(dot2 => {
                    if (isValidConnection(dot1, dot2)) {
                        const move = [dot1, dot2];
                        validMoves.push(move);
                        const tempLines = [...lines, {
                            start: { x: Math.min(dot1.userData.x, dot2.userData.x), y: Math.min(dot1.userData.y, dot2.userData.y) },
                            end: { x: Math.max(dot1.userData.x, dot2.userData.x), y: Math.max(dot1.userData.y, dot2.userData.y) }
                        }];
                        let closesBox = false;
                        for (let x = 0; x < gridSize - 1; x++) {
                            for (let y = 0; y < gridSize - 1; y++) {
                                if (hasBox(x, y, tempLines) && !boxes.some(box => box.userData.x === x && box.userData.y === y)) {
                                    closesBox = true;
                                    break;
                                }
                            }
                        }
                        if (closesBox) {
                            boxClosingMoves.push(move);
                        }
                        const opponent = currentPlayer === 'red' ? 'blue' : 'red';
                        let givesBox = false;
                        dots.forEach(d1 => {
                            dots.forEach(d2 => {
                                if (isValidConnection(d1, d2)) {
                                    const tempLines2 = [...tempLines, {
                                        start: { x: Math.min(d1.userData.x, d2.userData.x), y: Math.min(d1.userData.y, d2.userData.y) },
                                        end: { x: Math.max(d1.userData.x, d2.userData.x), y: Math.max(d2.userData.y, d2.userData.y) }
                                    }];
                                    for (let x = 0; x < gridSize - 1; x++) {
                                        for (let y = 0; y < gridSize - 1; y++) {
                                            if (hasBox(x, y, tempLines2) && !boxes.some(box => box.userData.x === x && box.userData.y === y)) {
                                                givesBox = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                            });
                        });
                        if (!givesBox) {
                            blockingMoves.push(move);
                        }
                    }
                });
            });
            let move;
            if (boxClosingMoves.length > 0) {
                move = boxClosingMoves[Math.floor(Math.random() * boxClosingMoves.length)];
            } else if (blockingMoves.length > 0) {
                move = blockingMoves[Math.floor(Math.random() * blockingMoves.length)];
            } else if (validMoves.length > 0) {
                move = validMoves[Math.floor(Math.random() * validMoves.length)];
            }
            if (move) {
                const [dot1, dot2] = move;
                const path = new THREE.LineCurve3(dot1.userData.basePosition, dot2.userData.basePosition);
                const geometry = new THREE.TubeGeometry(path, 32, 0.1, 8, false);
                hintLine = new THREE.Mesh(geometry, hintTubeMaterial.clone());
                hintLine.position.z = 0.04;
                scene.add(hintLine);
                flashingLines.push({ line: hintLine, time: 0, flashes: 0 });
            }
        }

        // Show flashing message
        function showMessage(text, isReminder = false) {
            const messageElement = document.getElementById('message');
            messageElement.textContent = text;
            messageElement.style.display = 'block';
            messageElement.classList.remove('neutral-message', 'positive-message', 'red-message', 'blue-message');
            if (text.includes('Invalid move')) {
                messageElement.classList.add('neutral-message');
            } else if (isReminder) {
                messageElement.classList.add(currentPlayer === 'red' ? 'red-message' : 'blue-message');
            } else {
                messageElement.classList.add('positive-message');
            }
            messageElement.classList.add('flash');
            setTimeout(() => {
                messageElement.style.display = 'none';
                messageElement.classList.remove('flash');
            }, 1500);
        }

        // Show points message near the line or box
        function showPointsMessage(points, reason, position) {
            const messageId = Date.now();
            // Project 3D position to 2D screen coordinates
            const vector = position.clone().project(camera);
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
            // Clamp position to avoid overlapping game grid or screen edges
            const clampedX = Math.max(50, Math.min(window.innerWidth - 50, x));
            const clampedY = Math.max(50, Math.min(window.innerHeight - 100, y));
            pointsMessages.push({ 
                id: messageId, 
                text: `+${points} ${reason}`, 
                x: clampedX, 
                y: clampedY, 
                offset: pointsMessages.length * 14,
                player: currentPlayer
            });
            updatePointsDisplay();
            setTimeout(() => {
                pointsMessages = pointsMessages.filter(msg => msg.id !== messageId);
                updatePointsDisplay();
            }, 1000);
        }

        function updatePointsDisplay() {
            const pointsElement = document.getElementById('points-message');
            if (pointsMessages.length === 0) {
                pointsElement.style.display = 'none';
                pointsElement.innerHTML = '';
                return;
            }
            pointsElement.style.display = 'block';
            pointsElement.innerHTML = pointsMessages.map(msg => 
                `<div class="${msg.player}-points" style="position: absolute; width: 150px; top: ${msg.y + msg.offset}px; left: ${msg.x}px; transform: translate(-50%, 0); text-align: center;">${msg.text}</div>`
            ).join('');
            pointsElement.classList.add('flash');
            setTimeout(() => pointsElement.classList.remove('flash'), 500);
        }

        // Toggle camera mode
        function toggleCamera() {
            isFlyCamera = !isFlyCamera;
            document.getElementById('camera-toggle').textContent = isFlyCamera ? 'Static Camera' : 'Fly Camera';
            if (!isFlyCamera) {
                camera.position.set(0, 0, 12);
                camera.lookAt(0, 0, 0);
            }
        }

        // Undo last move
        function undoMove() {
            if (gameMode === 'ai' || moveHistory.length === 0 || !gameActive) return;
            const lastMove = moveHistory.pop();
            if (lastMove && lastMove.line) {
                scene.remove(lastMove.line.mesh);
                lines.pop();
                moveCount--;
                if (lastMove.player === 'red') {
                    redMoves--;
                    redScore -= lastMove.points;
                    if (lastMove.boxes.length > 0) {
                        scores.red -= lastMove.boxes.length;
                    }
                } else {
                    blueMoves--;
                    blueScore -= lastMove.points;
                    if (lastMove.boxes.length > 0) {
                        scores.blue -= lastMove.boxes.length;
                    }
                }
                if (lastMove.boxes && lastMove.boxes.length > 0) {
                    lastMove.boxes.forEach(box => {
                        scene.remove(box);
                        const index = boxes.findIndex(b => b.userData.x === box.userData.x && b.userData.y === box.userData.y);
                        if (index !== -1) {
                            boxes.splice(index, 1);
                        }
                    });
                }
                currentPlayer = lastMove.player;
                updateDotConnectivity();
                updateTurnIndicator();
                updateStats();
                updateMoves();
                if (hintLine) {
                    scene.remove(hintLine);
                    hintLine = null;
                }
                if (hintEnabled) {
                    highlightBestMove();
                }
                playSound(300, 0.2, 'square');
                lastMoveTime = Date.now();
                lastIdleReminder = Date.now();
            }
        }

        // Check if a dot has any valid connections left
        function checkDotConnectivity(dot) {
            return dots.some(otherDot => isValidConnection(dot, otherDot));
        }

        // Update dot materials based on connectivity
        function updateDotConnectivity() {
            dots.forEach(dot => {
                if (!checkDotConnectivity(dot) && dot.material !== dimDotMaterial) {
                    dot.material = dimDotMaterial;
                } else if (checkDotConnectivity(dot) && dot.material === dimDotMaterial) {
                    dot.material = dotMaterial;
                }
            });
        }

        // Start game
        function startGame(mode) {
            initAudio();
            gameMode = mode;
            gameActive = true;
            isWelcomeScreen = false;
            isFlyCamera = false;
            document.getElementById('camera-toggle').textContent = 'Fly Camera';
            camera.position.set(0, 0, 12);
            camera.lookAt(0, 0, 0);
            document.getElementById('welcome').style.display = 'none';
            document.getElementById('game-stats-container').style.display = 'block';
            document.getElementById('game-timer').style.display = 'block';
            document.getElementById('turn').style.display = 'block';
            document.getElementById('moves').style.display = 'block';
            document.getElementById('games-won').style.display = 'block';
            document.getElementById('red-stats').style.display = 'block';
            document.getElementById('blue-stats').style.display = 'block';
            document.getElementById('progress-bar').style.display = 'block';
            document.getElementById('button-container').style.display = 'flex';
            if (mode === 'ai') {
                document.getElementById('undo-button').style.display = 'none';
                document.getElementById('hint-toggle').style.display = 'none';
            } else {
                document.getElementById('undo-button').style.display = 'block';
                document.getElementById('hint-toggle').style.display = 'block';
            }
            document.getElementById('sound-toggle').style.display = 'block';
            startTime = Date.now();
            lastSwitchTime = startTime;
            lastMoveTime = startTime;
            lastIdleReminder = startTime;
            redTime = 0;
            blueTime = 0;
            redMoves = 0;
            blueMoves = 0;
            timerInterval = setInterval(updateTimer, 1000);
            if (mode === 'ai') {
                aiMove();
            } else if (hintEnabled) {
                highlightBestMove();
            }
        }

        // Update timer
        function updateTimer() {
            if (gameActive) {
                const now = Date.now();
                const elapsed = Math.floor((now - startTime) / 1000);
                const turnTime = Math.floor((now - lastSwitchTime) / 1000);
                if (currentPlayer === 'red') {
                    redTime += turnTime;
                } else {
                    blueTime += turnTime;
                }
                lastSwitchTime = now;
                document.getElementById('game-timer').textContent = `Game Time: ${elapsed}s`;
                document.getElementById('red-stats').innerHTML = `Red: ${scores.red}<br>Score: ${redScore}<br>Time: ${redTime}s<br>Moves: ${redMoves}`;
                document.getElementById('blue-stats').innerHTML = `Blue: ${scores.blue}<br>Score: ${blueScore}<br>Time: ${blueTime}s<br>Moves: ${blueMoves}`;
            }
        }

        // Update move counter
        function updateMoves() {
            document.getElementById('moves').textContent = `Moves: ${moveCount}`;
        }

        // Handle mouse movement for preview line
        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        // Handle mouse clicks
        window.addEventListener('click', (event) => {
            if (!gameActive || (gameMode === '1player' && currentPlayer === 'blue') || gameMode === 'ai') return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            // Use base positions for raycasting to ensure accurate clicking
            const intersects = raycaster.intersectObjects(dots.map(dot => {
                const tempDot = dot.clone();
                tempDot.position.copy(dot.userData.basePosition);
                return tempDot;
            }));
            if (intersects.length > 0) {
                const clickedDot = dots.find(dot => dot.userData.x === intersects[0].object.userData.x && dot.userData.y === intersects[0].object.userData.y);
                if (!selectedDot) {
                    selectedDot = clickedDot;
                    yellowOverlayDot = new THREE.Mesh(new THREE.SphereGeometry(0.25, 64, 64), yellowOverlayMaterial);
                    yellowOverlayDot.position.copy(clickedDot.position);
                    yellowOverlayDot.position.z = 0.01;
                    scene.add(yellowOverlayDot);
                    // Initialize preview line
                    const path = new THREE.LineCurve3(clickedDot.position, clickedDot.position);
                    const geometry = new THREE.TubeGeometry(path, 32, 0.1, 8, false);
                    const tubeMaterial = currentPlayer === 'red' ? redTubeMaterial.clone() : blueTubeMaterial.clone();
                    previewLine = new THREE.Mesh(geometry, tubeMaterial);
                    previewLine.position.z = 0.05;
                    scene.add(previewLine);
                    highlightValidDots(clickedDot);
                } else {
                    if (isValidConnection(selectedDot, clickedDot)) {
                        drawLine(selectedDot, clickedDot);
                        const boxCount = checkForBoxes();
                        if (boxCount > 0) {
                            showMessage(`${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)} formed a box!`);
                            playSound(600, 0.3, 'sine');
                        } else {
                            playSound(400, 0.2, 'sine');
                            lastSwitchTime = Date.now();
                            lastMoveTime = Date.now();
                            lastIdleReminder = Date.now();
                        }
                        if (boxCount === 0) {
                            currentPlayer = currentPlayer === 'red' ? 'blue' : 'red';
                            updateTurnIndicator();
                            if (gameMode === '1player' && currentPlayer === 'blue') {
                                setTimeout(aiMove, 500);
                            } else if (hintEnabled) {
                                highlightBestMove();
                            }
                        } else if (hintEnabled) {
                            highlightBestMove();
                        }
                    } else {
                        showMessage('Invalid move! Choose an adjacent, unconnected dot.');
                        playSound(200, 0.2, 'square');
                    }
                    // Clean up preview line and overlays
                    if (previewLine) {
                        scene.remove(previewLine);
                        previewLine = null;
                    }
                    if (yellowOverlayDot) {
                        scene.remove(yellowOverlayDot);
                        yellowOverlayDot = null;
                    }
                    resetDotColors();
                    selectedDot = null;
                }
            } else if (selectedDot) {
                // Clicked outside dots, cancel selection
                if (previewLine) {
                    scene.remove(previewLine);
                    previewLine = null;
                }
                if (yellowOverlayDot) {
                    scene.remove(yellowOverlayDot);
                    yellowOverlayDot = null;
                }
                resetDotColors();
                selectedDot = null;
            }
        });

        // Check if connection is valid (prevents duplicate lines)
        function isValidConnection(dot1, dot2) {
            if (!dot1 || !dot2) return false;
            const dx = Math.abs(dot1.userData.x - dot2.userData.x);
            const dy = Math.abs(dot1.userData.y - dot2.userData.y);
            const isAdjacent = (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
            if (!isAdjacent) return false;
            const lineExists = lines.some(l => 
                (l.start.x === Math.min(dot1.userData.x, dot2.userData.x) && 
                 l.start.y === Math.min(dot1.userData.y, dot2.userData.y) && 
                 l.end.x === Math.max(dot1.userData.x, dot2.userData.x) && 
                 l.end.y === Math.max(dot1.userData.y, dot2.userData.y))
            );
            return !lineExists;
        }

        // Highlight valid adjacent dots
        function highlightValidDots(selected) {
            if (!selected) return;
            const x = selected.userData.x;
            const y = selected.userData.y;
            dots.forEach(dot => {
                if (isValidConnection(selected, dot)) {
                    dot.material = validDotMaterial;
                    dot.userData.isValid = true;
                } else {
                    dot.material = checkDotConnectivity(dot) ? dotMaterial : dimDotMaterial;
                    dot.userData.isValid = false;
                }
            });
        }

        // Reset all dot colors and scales
        function resetDotColors() {
            dots.forEach(dot => {
                dot.material = checkDotConnectivity(dot) ? dotMaterial : dimDotMaterial;
                dot.scale.set(1, 1, 1);
                dot.userData.isValid = false;
                dot.material.opacity = 1;
                dot.material.transparent = false;
            });
        }

        // Draw tube between two dots with flash effect
        function drawLine(dot1, dot2) {
            const path = new THREE.LineCurve3(dot1.userData.basePosition, dot2.userData.basePosition);
            const geometry = new THREE.TubeGeometry(path, 32, 0.1, 8, false);
            const tubeMaterial = currentPlayer === 'red' ? redTubeMaterial.clone() : blueTubeMaterial.clone();
            const tube = new THREE.Mesh(geometry, tubeMaterial);
            tube.position.z = 0.05;
            scene.add(tube);
            const newBoxes = [];
            // Calculate line midpoint for Line and Fast Move messages
            const lineMidpoint = new THREE.Vector3().addVectors(dot1.position, dot2.position).multiplyScalar(0.5);
            const boxCount = checkForBoxes(newBoxes);
            let points = 1; // 1 point for drawing a line
            showPointsMessage(1, 'Line', lineMidpoint);
            if (boxCount > 0) {
                points += 5 * boxCount; // 5 points per box
                // Use the last box's position for Box message
                const lastBox = newBoxes[newBoxes.length - 1];
                const boxPosition = lastBox ? lastBox.position : lineMidpoint;
                showPointsMessage(5 * boxCount, `${boxCount} Box${boxCount > 1 ? 'es' : ''}`, boxPosition);
            }
            const moveTime = Date.now();
            if (moveTime - lastMoveTime < 5000) { // 5 seconds for fast move
                points += 2; // 2 points for fast move
                showPointsMessage(2, 'Fast Move', lineMidpoint);
            }
            if (currentPlayer === 'red') {
                redScore += points;
                redMoves++;
            } else {
                blueScore += points;
                blueMoves++;
            }
            lines.push({ 
                start: { x: Math.min(dot1.userData.x, dot2.userData.x), y: Math.min(dot1.userData.y, dot2.userData.y) },
                end: { x: Math.max(dot1.userData.x, dot2.userData.x), y: Math.max(dot1.userData.y, dot2.userData.y) },
                player: currentPlayer,
                mesh: tube,
                dot1: dot1,
                dot2: dot2
            });
            moveHistory.push({ line: lines[lines.length - 1], player: currentPlayer, boxes: newBoxes, points: points });
            flashingLines.push({ line: tube, time: 0, flashes: 0 });
            moveCount++;
            lastMoveTime = moveTime;
            lastIdleReminder = moveTime;
            updateDotConnectivity();
            updateMoves();
            updateStats();
            if (hintLine) {
                scene.remove(hintLine);
                hintLine = null;
            }
            checkGameOver();
        }

        // Smarter AI move
        function aiMove() {
            if (!gameActive) return;
            const validMoves = [];
            const boxClosingMoves = [];
            const blockingMoves = [];
            dots.forEach(dot1 => {
                dots.forEach(dot2 => {
                    if (isValidConnection(dot1, dot2)) {
                        const move = [dot1, dot2];
                        validMoves.push(move);
                        const tempLines = [...lines, {
                            start: { x: Math.min(dot1.userData.x, dot2.userData.x), y: Math.min(dot1.userData.y, dot2.userData.y) },
                            end: { x: Math.max(dot1.userData.x, dot2.userData.x), y: Math.max(dot1.userData.y, dot2.userData.y) }
                        }];
                        let closesBox = false;
                        for (let x = 0; x < gridSize - 1; x++) {
                            for (let y = 0; y < gridSize - 1; y++) {
                                if (hasBox(x, y, tempLines) && !boxes.some(box => box.userData.x === x && box.userData.y === y)) {
                                    closesBox = true;
                                    break;
                                }
                            }
                        }
                        if (closesBox) {
                            boxClosingMoves.push(move);
                        }
                        const opponent = currentPlayer === 'red' ? 'blue' : 'red';
                        let givesBox = false;
                        dots.forEach(d1 => {
                            dots.forEach(d2 => {
                                if (isValidConnection(d1, d2)) {
                                    const tempLines2 = [...tempLines, {
                                        start: { x: Math.min(d1.userData.x, d2.userData.x), y: Math.min(d1.userData.y, d2.userData.y) },
                                        end: { x: Math.max(d1.userData.x, d2.userData.x), y: Math.max(d2.userData.y, d2.userData.y) }
                                    }];
                                    for (let x = 0; x < gridSize - 1; x++) {
                                        for (let y = 0; y < gridSize - 1; y++) {
                                            if (hasBox(x, y, tempLines2) && !boxes.some(box => box.userData.x === x && box.userData.y === y)) {
                                                givesBox = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                            });
                        });
                        if (!givesBox) {
                            blockingMoves.push(move);
                        }
                    }
                });
            });
            let move;
            if (boxClosingMoves.length > 0) {
                move = boxClosingMoves[Math.floor(Math.random() * boxClosingMoves.length)];
            } else if (blockingMoves.length > 0) {
                move = blockingMoves[Math.floor(Math.random() * blockingMoves.length)];
            } else if (validMoves.length > 0) {
                move = validMoves[Math.floor(Math.random() * validMoves.length)];
            }
            if (move) {
                const [dot1, dot2] = move;
                drawLine(dot1, dot2);
                const boxCount = checkForBoxes();
                if (boxCount > 0) {
                    showMessage(`${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)} formed a box!`);
                    playSound(600, 0.3, 'sine');
                } else {
                    playSound(400, 0.2, 'sine');
                    lastSwitchTime = Date.now();
                    lastMoveTime = Date.now();
                    lastIdleReminder = Date.now();
                }
                if (boxCount === 0) {
                    currentPlayer = currentPlayer === 'red' ? 'blue' : 'red';
                    updateTurnIndicator();
                }
                if (gameMode === 'ai' || (gameMode === '1player' && currentPlayer === 'blue')) {
                    setTimeout(aiMove, gameMode === 'ai' ? 50 : 500);
                }
            }
        }

        // Check for completed boxes
        function checkForBoxes(newBoxes = []) {
            let boxCount = 0;
            for (let x = 0; x < gridSize - 1; x++) {
                for (let y = 0; y < gridSize - 1; y++) {
                    if (hasBox(x, y) && !boxes.some(box => box.userData.x === x && box.userData.y === y)) {
                        const box = createBox(x, y);
                        newBoxes.push(box);
                        scores[currentPlayer]++;
                        boxCount++;
                        updateStats();
                    }
                }
            }
            return boxCount;
        }

        // Check if a box is formed at (x, y)
        function hasBox(x, y, linesToCheck = lines) {
            return linesToCheck.some(l => l.start.x === x && l.start.y === y && l.end.x === x && l.end.y === y + 1) &&
                   linesToCheck.some(l => l.start.x === x && l.start.y === y + 1 && l.end.x === x + 1 && l.end.y === y + 1) &&
                   linesToCheck.some(l => l.start.x === x + 1 && l.start.y === y && l.end.x === x + 1 && l.end.y === y + 1) &&
                   linesToCheck.some(l => l.start.x === x && l.start.y === y && l.end.x === x + 1 && l.end.y === y);
        }

        // Create transparent colored box with fade-in and ripple phase
        function createBox(x, y) {
            const boxGeometry = new THREE.PlaneGeometry(spacing, spacing);
            const boxMaterial = new THREE.MeshBasicMaterial({ 
                color: currentPlayer === 'red' ? 0xff0000 : 0x0000ff, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0
            });
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.set(x * spacing - (gridSize - 1) * spacing / 2 + spacing / 2, y * spacing - (gridSize - 1) * spacing / 2 + spacing / 2, -0.1);
            box.userData = { x, y, player: currentPlayer, fadeTime: 0, ripplePhase: Math.random() * Math.PI * 2 };
            scene.add(box);
            boxes.push(box);
            return box;
        }

        // Update turn indicator
        function updateTurnIndicator() {
            const turnElement = document.getElementById('turn');
            turnElement.textContent = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s Turn`;
            turnElement.style.color = currentPlayer === 'red' ? '#ff0000' : '#0000ff';
            turnElement.classList.add('flash');
            setTimeout(() => turnElement.classList.remove('flash'), 1500);
        }

        // Update stats display and progress bar
        function updateStats() {
            document.getElementById('red-stats').innerHTML = `Red: ${scores.red}<br>Score: ${redScore}<br>Time: ${redTime}s<br>Moves: ${redMoves}`;
            document.getElementById('blue-stats').innerHTML = `Blue: ${scores.blue}<br>Score: ${blueScore}<br>Time: ${blueTime}s<br>Moves: ${blueMoves}`;
            document.getElementById('games-won').textContent = `Games Won: Red ${gameStats.red}, Blue ${gameStats.blue}, Tie ${gameStats.tie}`;
            const totalGames = gameStats.red + gameStats.blue + gameStats.tie;
            const redPercent = totalGames > 0 ? (gameStats.red / totalGames * 100).toFixed(1) : 0;
            const bluePercent = totalGames > 0 ? (gameStats.blue / totalGames * 100).toFixed(1) : 0;
            const tiePercent = totalGames > 0 ? (gameStats.tie / totalGames * 100).toFixed(1) : 0;
            document.getElementById('progress-red').style.width = `${redPercent}%`;
            document.getElementById('progress-blue').style.width = `${bluePercent}%`;
            document.getElementById('progress-tie').style.width = `${tiePercent}%`;
        }

        // Check for game over (when all lines are drawn)
        function checkGameOver() {
            if (lines.length === maxLines) {
                gameActive = false;
                isFlyCamera = true;
                clearInterval(timerInterval);
                const now = Date.now();
                const elapsed = Math.floor((now - startTime) / 1000);
                const turnTime = Math.floor((now - lastSwitchTime) / 1000);
                if (currentPlayer === 'red') {
                    redTime += turnTime;
                } else {
                    blueTime += turnTime;
                }
                const winner = scores.red > scores.blue ? 'Red' : scores.blue > scores.red ? 'Blue' : 'Tie';
                gameStats[winner.toLowerCase()]++;
                const winnerElement = document.getElementById('winner-text');
                winnerElement.textContent = `Winner: ${winner}`;
                winnerElement.classList.remove('red-winner', 'blue-winner', 'tie-winner');
                if (winner === 'Red') {
                    winnerElement.classList.add('red-winner');
                } else if (winner === 'Blue') {
                    winnerElement.classList.add('blue-winner');
                } else {
                    winnerElement.classList.add('tie-winner');
                }
                document.getElementById('final-stats').innerHTML = `
                    <span class="red-stat">Red: ${scores.red} (Score: ${redScore}, Time: ${redTime}s, Moves: ${redMoves})</span><br>
                    <span class="blue-stat">Blue: ${scores.blue} (Score: ${blueScore}, Time: ${blueTime}s, Moves: ${blueMoves})</span><br>
                    <span class="neutral-stat">Total Moves: ${moveCount}</span><br>
                    <span class="neutral-stat">Game Time: ${elapsed}s</span><br>
                    <span class="neutral-stat">Games Won - Red: ${gameStats.red}, Blue: ${gameStats.blue}, Tie: ${gameStats.tie}</span>`;
                document.getElementById('game-over').style.display = 'flex';
                updateStats();
            }
        }

        // Reset game
        function resetGame(mode, resetStats = false, showConfirm = false) {
            if (showConfirm && gameActive) {
                document.getElementById('exit-confirm').style.display = 'flex';
                return;
            }
            gameActive = false;
            if (timerInterval) clearInterval(timerInterval);
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('exit-confirm').style.display = 'none';
            document.getElementById('game-stats-container').style.display = 'none';
            document.getElementById('game-timer').style.display = 'none';
            document.getElementById('turn').style.display = 'none';
            document.getElementById('moves').style.display = 'none';
            document.getElementById('games-won').style.display = 'none';
            document.getElementById('red-stats').style.display = 'none';
            document.getElementById('blue-stats').style.display = 'none';
            document.getElementById('progress-bar').style.display = 'none';
            document.getElementById('button-container').style.display = 'none';
            document.getElementById('message').style.display = 'none';
            document.getElementById('points-message').style.display = 'none';
            lines.forEach(line => scene.remove(line.mesh));
            boxes.forEach(box => scene.remove(box));
            if (yellowOverlayDot) {
                scene.remove(yellowOverlayDot);
                yellowOverlayDot = null;
            }
            if (hintLine) {
                scene.remove(hintLine);
                hintLine = null;
            }
            if (previewLine) {
                scene.remove(previewLine);
                previewLine = null;
            }
            scene.children = scene.children.filter(child => !(child.isMesh && child.geometry.type === 'SphereGeometry' && child.material === glowMaterial));
            lines.length = 0;
            boxes.length = 0;
            scores = { red: 0, blue: 0 };
            redScore = 0;
            blueScore = 0;
            moveCount = 0;
            redMoves = 0;
            blueMoves = 0;
            moveHistory = [];
            pointsMessages = [];
            currentPlayer = 'red';
            selectedDot = null;
            flashingLines = [];
            isFlyCamera = false;
            redTime = 0;
            blueTime = 0;
            lastSwitchTime = 0;
            lastMoveTime = 0;
            lastIdleReminder = 0;
            wobbleTime = 0;
            soundEnabled = true;
            hintEnabled = false;
            document.getElementById('camera-toggle').textContent = 'Fly Camera';
            document.getElementById('sound-toggle').textContent = 'Sound On';
            document.getElementById('hint-toggle').textContent = 'Hint Off';
            camera.position.set(0, 0, 12);
            camera.lookAt(0, 0, 0);
            if (resetStats) {
                gameStats = { red: 0, blue: 0, tie: 0 };
            }
            resetDotColors();
            updateStats();
            updateMoves();
            document.getElementById('turn').textContent = "Red's Turn";
            document.getElementById('game-timer').textContent = "Game Time: 0s";
            dots.length = 0;
            dotWobbleOffsets.length = 0;
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                    dot.position.set(x * spacing - (gridSize - 1) * spacing / 2, y * spacing - (gridSize - 1) * spacing / 2, 0);
                    dot.userData = { x, y, basePosition: dot.position.clone() };
                    scene.add(dot);
                    const glow = new THREE.Mesh(new THREE.SphereGeometry(0.25, 64, 64), glowMaterial);
                    glow.position.copy(dot.position);
                    scene.add(glow);
                    dots.push(dot);
                    dotWobbleOffsets.push({
                        x: (Math.random() - 0.5) * 0.1,
                        y: (Math.random() - 0.5) * 0.1,
                        phase: Math.random() * Math.PI * 2
                    });
                }
            }
            if (mode) {
                startGame(mode);
            } else {
                isWelcomeScreen = true;
                document.getElementById('welcome').style.display = 'flex';
            }
        }

        // Update wobble for dots, lines, and boxes with ripple effect
        function updateWobble() {
            wobbleTime += 0.05;
            dots.forEach((dot, index) => {
                const offset = dotWobbleOffsets[index];
                const wobbleX = offset.x * Math.sin(wobbleTime + offset.phase);
                const wobbleY = offset.y * Math.cos(wobbleTime + offset.phase);
                dot.position.copy(dot.userData.basePosition);
                dot.position.x += wobbleX;
                dot.position.y += wobbleY;
                // Update glow position
                const glow = scene.children.find(child => 
                    child.isMesh && 
                    child.geometry.type === 'SphereGeometry' && 
                    child.material === glowMaterial && 
                    child.position.distanceTo(dot.userData.basePosition) < 0.01
                );
                if (glow) {
                    glow.position.copy(dot.position);
                }
            });

            // Update lines
            lines.forEach(line => {
                const dot1 = line.dot1;
                const dot2 = line.dot2;
                if (dot1 && dot2) {
                    scene.remove(line.mesh);
                    const path = new THREE.LineCurve3(dot1.position, dot2.position);
                    const geometry = new THREE.TubeGeometry(path, 32, 0.1, 8, false);
                    line.mesh = new THREE.Mesh(geometry, line.mesh.material);
                    line.mesh.position.z = 0.05;
                    scene.add(line.mesh);
                }
            });

            // Update boxes with ripple effect
            boxes.forEach(box => {
                const x = box.userData.x;
                const y = box.userData.y;
                const corners = [
                    dots.find(dot => dot.userData.x === x && dot.userData.y === y),
                    dots.find(dot => dot.userData.x === x + 1 && dot.userData.y === y),
                    dots.find(dot => dot.userData.x === x && dot.userData.y === y + 1),
                    dots.find(dot => dot.userData.x === x + 1 && dot.userData.y === y + 1)
                ];
                if (corners.every(corner => corner)) {
                    const avgPosition = new THREE.Vector3();
                    corners.forEach(corner => avgPosition.add(corner.position));
                    avgPosition.multiplyScalar(0.25);
                    box.position.set(avgPosition.x, avgPosition.y, -0.1);
                    // Ripple effect: scale and opacity
                    if (box.userData.fadeTime >= 1) {
                        const ripple = 0.5 * (Math.sin(wobbleTime + box.userData.ripplePhase) + 1);
                        const scale = 1.0 + 0.1 * ripple; // Scale from 1.0 to 1.1
                        box.scale.set(scale, scale, 1);
                        box.material.opacity = 0.4 + 0.2 * ripple; // Opacity from 0.4 to 0.6
                    }
                }
            });

            // Update yellow overlay dot
            if (yellowOverlayDot && selectedDot) {
                yellowOverlayDot.position.copy(selectedDot.position);
                yellowOverlayDot.position.z = 0.01;
            }

            // Update hint line
            if (hintLine && hintEnabled) {
                scene.remove(hintLine);
                const validMoves = [];
                dots.forEach(dot1 => {
                    dots.forEach(dot2 => {
                        if (isValidConnection(dot1, dot2)) {
                            validMoves.push([dot1, dot2]);
                        }
                    });
                });
                if (validMoves.length > 0) {
                    const move = validMoves[Math.floor(Math.random() * validMoves.length)];
                    const [dot1, dot2] = move;
                    const path = new THREE.LineCurve3(dot1.position, dot2.position);
                    const geometry = new THREE.TubeGeometry(path, 32, 0.1, 8, false);
                    hintLine = new THREE.Mesh(geometry, hintTubeMaterial.clone());
                    hintLine.position.z = 0.04;
                    scene.add(hintLine);
                }
            }
        }

        // Throb effect for selected dot, flash effect for valid dots and tubes, animate boxes, twinkle stars
        function updateThrob() {
            throbTime += 0.05;
            const scale = 1 + 0.1 * Math.sin(throbTime);
            const flashOpacity = 0.3 + 0.7 * (Math.sin(throbTime * 2) + 1) / 2;
            dots.forEach(dot => {
                if (dot.userData.isValid) {
                    dot.scale.set(scale, scale, scale);
                    dot.material.opacity = flashOpacity;
                    dot.material.transparent = true;
                } else {
                    dot.material.opacity = 1;
                    dot.material.transparent = false;
                }
            });
            if (yellowOverlayDot) {
                yellowOverlayDot.scale.set(scale, scale, scale);
            }
            flashingLines = flashingLines.filter(flash => {
                flash.time += 0.05;
                const opacity = 0.3 + 0.7 * (Math.sin(flash.time * 8) + 1) / 2;
                flash.line.material.opacity = opacity;
                if (flash.flashes < 3 && flash.time > 0.5) {
                    flash.flashes++;
                    flash.time = 0;
                }
                if (flash.flashes >= 3) {
                    flash.line.material.opacity = 1;
                    flash.line.material.transparent = false;
                    return false;
                }
                return true;
            });
            boxes.forEach(box => {
                if (box.userData.fadeTime < 1) {
                    box.userData.fadeTime += 0.05;
                    box.material.opacity = Math.min(0.5, box.userData.fadeTime);
                }
            });
            for (let i = 0; i < starOpacities.length; i++) {
                starOpacities[i] = Math.random() * 0.5 + 0.5;
            }
            starGeometry.attributes.opacity.needsUpdate = true;
        }

        // Update camera for fly mode or welcome screen
        function updateCamera() {
            if ((isFlyCamera && (gameActive || document.getElementById('game-over').style.display === 'flex')) || isWelcomeScreen) {
                cameraTime += 0.01;
                const radius = 12;
                camera.position.x = Math.sin(cameraTime) * radius;
                camera.position.z = Math.cos(cameraTime) * radius;
                camera.position.y = Math.sin(cameraTime * 0.5) * 2;
                camera.lookAt(0, 0, 0);
            }
        }

        // Update preview line to follow mouse
        function updatePreviewLine() {
            if (previewLine && selectedDot) {
                raycaster.setFromCamera(mouse, camera);
                const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersectPoint);
                scene.remove(previewLine);
                const path = new THREE.LineCurve3(selectedDot.position, intersectPoint);
                const geometry = new THREE.TubeGeometry(path, 32, 0.1, 8, false);
                const tubeMaterial = currentPlayer === 'red' ? redTubeMaterial.clone() : blueTubeMaterial.clone();
                previewLine = new THREE.Mesh(geometry, tubeMaterial);
                previewLine.position.z = 0.05;
                scene.add(previewLine);
            }
        }

        // Camera position (initial)
        camera.position.z = 12;

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            if (gameActive || isWelcomeScreen || document.getElementById('game-over').style.display === 'flex') {
                updateThrob();
                updateCamera();
                if (gameActive) {
                    updateWobble();
                    updatePreviewLine();
                    // Check for idle state (10 seconds since last move)
                    const now = Date.now();
                    if (now - lastIdleReminder > 10000 && gameActive && (gameMode !== 'ai' && (gameMode !== '1player' || currentPlayer === 'red'))) {
                        lastIdleReminder = now;
                        // Flash player's time
                        const statsElement = document.getElementById(currentPlayer === 'red' ? 'red-stats' : 'blue-stats');
                        statsElement.classList.add('flash');
                        setTimeout(() => statsElement.classList.remove('flash'), 1500);
                        // Show reminder message
                        showMessage(`${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s Turn!`, true);
                    }
                }
            }
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
