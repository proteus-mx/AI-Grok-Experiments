<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Race 2</title>
    <style>
        body { display: flex; flex-direction: column; align-items: center; font-family: Arial, sans-serif; background: #f0f0f0; margin: 0; padding: 20px; }
        #game-container { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 20px; }
        #pattern-container { display: flex; flex-direction: column; align-items: center; }
        #pattern { display: grid; grid-template-columns: repeat(3, 20px); gap: 1px; border: 2px solid #333; background: #fff; padding: 3px; border-radius: 6px; margin-bottom: 5px; }
        #board1, #board2 { display: grid; grid-template-columns: repeat(5, 40px); gap: 2px; border: 3px solid #333; background: #ddd; padding: 5px; border-radius: 10px; }
        .tile { width: 40px; height: 40px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.3); transition: transform 0.2s; user-select: none; }
        #pattern .tile { width: 20px; height: 20px; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        .tile:active { transform: scale(0.95); }
        .empty { background: transparent; box-shadow: none; }
        .red { background: #FF4136; }
        .green { background: #2ECC40; }
        .blue { background: #0074D9; }
        .yellow { background: #FFDC00; }
        .white { background: #FFFFFF; border: 1px solid #ccc; }
        .orange { background: #FF851B; }
        #stats1, #stats2 { font-size: 16px; margin: 10px 0; display: flex; flex-direction: column; gap: 5px; align-items: center; }
        #controls { margin: 10px 0; }
        button { padding: 8px 16px; margin: 5px; background: #0074D9; color: white; border: none; border-radius: 5px; cursor: pointer; }
        button:hover { background: #0056b3; }
        #randomize-pattern { padding: 5px 10px; font-size: 12px; }
        #gameover { 
            display: none; 
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            background: rgba(0, 0, 0, 0.7); 
            color: #2ECC40; 
            padding: 20px; 
            border-radius: 10px; 
            text-align: center; 
            font-size: 24px; 
            box-shadow: 0 4px 10px rgba(0,0,0,0.5); 
        }
        #thinking {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 20px;
        }
        #mode-selection { margin-bottom: 10px; }
        #solution { 
            margin-top: 20px; 
            max-height: 150px; 
            overflow-y: auto; 
            width: 80%; 
            max-width: 300px; 
            background: #fff; 
            padding: 10px; 
            border-radius: 5px; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
            display: none; 
        }
        #solution p { margin: 5px 0; font-size: 14px; }
        #difficulty1, #difficulty2 { 
            width: 100%; 
            max-width: 200px; 
            text-align: left; 
        }
        #difficulty-bar1, #difficulty-bar2 {
            height: 15px;
            border-radius: 5px;
            background: #ccc;
            overflow: hidden;
        }
        #difficulty-fill1, #difficulty-fill2 {
            height: 100%;
            transition: width 0.3s;
        }
        #progress1, #progress2 {
            width: 100%;
            max-width: 200px;
            text-align: left;
        }
        #progress-bar1, #progress-bar2 {
            height: 15px;
            border-radius: 5px;
            background: #ccc;
            overflow: hidden;
        }
        #progress-fill1, #progress-fill2 {
            height: 100%;
            background: #2ECC40;
            transition: width 0.3s;
        }
        .easy { background: #2ECC40; }
        .medium { background: #FFDC00; }
        .hard { background: #FF4136; }
        .hint { animation: flash 0.5s infinite alternate; }
        @keyframes flash { from { box-shadow: 0 0 15px red; } to { box-shadow: 0 0 25px red; } }
        .player-label { font-size: 18px; font-weight: bold; margin-bottom: 5px; }
    </style>
</head>
<body>
    <div id="mode-selection">
        <button onclick="newGame('easy', 1)">1 Player - Easy</button>
        <button onclick="newGame('hard', 1)">1 Player - Hard</button>
        <button onclick="newGame('easy', 2)">2 Player - Easy</button>
        <button onclick="newGame('hard', 2)">2 Player - Hard</button>
    </div>
    <div id="game-container">
        <div id="player1">
            <div class="player-label">Player 1</div>
            <div id="board1"></div>
            <div id="stats1">
                <div>
                    <span id="timer1">Time: 0s</span>
                    <span id="moves1">Moves: 0</span>
                    <span id="points1">Points: 0</span>
                </div>
                <div id="progress1">
                    <p>Games: <span id="games-played1">0</span> (<span id="games-won1">0</span>)</p>
                    <div id="progress-bar1">
                        <div id="progress-fill1"></div>
                    </div>
                </div>
                <div id="difficulty1">
                    <p>Difficulty: <span id="move-count1">0</span> moves</p>
                    <div id="difficulty-bar1">
                        <div id="difficulty-fill1"></div>
                    </div>
                </div>
            </div>
        </div>
        <div id="pattern-container">
            <div id="pattern"></div>
            <button id="randomize-pattern" onclick="randomizePattern()">Randomize Pattern</button>
        </div>
        <div id="player2" style="display: none;">
            <div class="player-label">Player 2</div>
            <div id="board2"></div>
            <div id="stats2">
                <div>
                    <span id="timer2">Time: 0s</span>
                    <span id="moves2">Moves: 0</span>
                    <span id="points2">Points: 0</span>
                </div>
                <div id="progress2">
                    <p>Games: <span id="games-played2">0</span> (<span id="games-won2">0</span>)</p>
                    <div id="progress-bar2">
                        <div id="progress-fill2"></div>
                    </div>
                </div>
                <div id="difficulty2">
                    <p>Difficulty: <span id="move-count2">0</span> moves</p>
                    <div id="difficulty-bar2">
                        <div id="difficulty-fill2"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="controls">
        <button onclick="hint(1)">Hint P1</button>
        <button onclick="autoComplete(1)">Auto Solve P1</button>
        <button id="hint2" onclick="hint(2)" style="display: none;">Hint P2</button>
        <button id="auto2" onclick="autoComplete(2)" style="display: none;">Auto Solve P2</button>
        <button onclick="showSolution()">Show Solution</button>
    </div>
    <div id="solution"></div>
    <div id="gameover">
        <span id="winner"></span> Wins!<br>
        Time: <span id="wintime"></span>s<br>
        Moves: <span id="winmoves"></span><br>
        Points: <span id="winpoints"></span><br>
        <button onclick="newGame(currentMode, playerCount)">Play Again</button>
    </div>
    <div id="thinking">Thinking...</div>
    <script>
        const colors = ['red', 'green', 'blue', 'yellow', 'white', 'orange'];
        let board1 = [], board2 = [];
        let emptyPos1 = {x: 0, y: 0}, emptyPos2 = {x: 0, y: 0};
        let pattern = [];
        let startTime;
        let timerInterval1, timerInterval2;
        let moveCount1 = 0, moveCount2 = 0;
        let points1 = 0, points2 = 0;
        let gamesPlayed1 = 0, gamesPlayed2 = 0;
        let gamesWon1 = 0, gamesWon2 = 0;
        let initialMoveCount1 = 0, initialMoveCount2 = 0;
        let gameWon = false;
        let autoSolving = false;
        let currentMode = 'easy';
        let playerCount = 1;
        let currentPlayer = 1;

        function initBoard(mode, player) {
            let tiles = [];
            colors.forEach(c => { for(let i=0; i<4; i++) tiles.push(c); });
            tiles.push(null);
            
            let board, moveCount;
            let attempts = 0;
            const maxAttempts = 10;

            if (mode === 'easy') {
                do {
                    board = Array.from({length: 5}, () => Array(5).fill(null));
                    for (let y = 0; y < 3; y++) {
                        for (let x = 0; x < 3; x++) {
                            board[y + 1][x + 1] = pattern[y][x] || null;
                        }
                    }
                    let remaining = {};
                    colors.forEach(c => remaining[c] = 4);
                    pattern.flat().forEach(c => { if (c) remaining[c]--; });
                    let outerTiles = [];
                    colors.forEach(c => { for (let i = 0; i < remaining[c]; i++) outerTiles.push(c); });
                    outerTiles.sort(() => Math.random() - 0.5);
                    let outerPos = [];
                    for (let y = 0; y < 5; y++) {
                        for (let x = 0; x < 5; x++) {
                            if (y >= 1 && y <= 3 && x >= 1 && x <= 3) continue;
                            outerPos.push({x, y});
                        }
                    }
                    let tileIdx = 0;
                    let emptyIdx = Math.floor(Math.random() * outerPos.length);
                    for (let i = 0; i < outerPos.length; i++) {
                        let pos = outerPos[i];
                        if (i === emptyIdx) {
                            board[pos.y][pos.x] = null;
                            if (player === 1) emptyPos1 = {x: pos.x, y: pos.y};
                            else emptyPos2 = {x: pos.x, y: pos.y};
                        } else {
                            board[pos.y][pos.x] = outerTiles[tileIdx++] || null;
                        }
                    }
                    for (let i = 0; i < 10; i++) {
                        let moves = getPossibleMoves(player === 1 ? emptyPos1 : emptyPos2);
                        let move = moves[Math.floor(Math.random() * moves.length)];
                        if (move) moveRowOrColumn(move.x, move.y, move.dx, move.dy, false, player, board);
                    }
                    moveCount = planSolutionSync(board, player === 1 ? emptyPos1 : emptyPos2).length;
                    attempts++;
                } while ((moveCount < 5 || moveCount > 15) && attempts < maxAttempts);
            } else {
                do {
                    tiles.sort(() => Math.random() - 0.5);
                    board = [];
                    for (let y = 0; y < 5; y++) {
                        board[y] = [];
                        for (let x = 0; x < 5; x++) {
                            board[y][x] = tiles[y * 5 + x];
                            if (!board[y][x]) {
                                if (player === 1) emptyPos1 = {x, y};
                                else emptyPos2 = {x, y};
                            }
                        }
                    }
                    moveCount = planSolutionSync(board, player === 1 ? emptyPos1 : emptyPos2).length;
                    attempts++;
                } while ((moveCount < 15 || moveCount >= 100) && attempts < maxAttempts);
            }

            if (attempts >= maxAttempts || moveCount === 0) {
                board = Array.from({length: 5}, () => Array(5).fill(null));
                for (let y = 0; y < 3; y++) {
                    for (let x = 0; x < 3; x++) {
                        board[y + 1][x + 1] = pattern[y][x] || null;
                    }
                }
                let remaining = {};
                colors.forEach(c => remaining[c] = 4);
                pattern.flat().forEach(c => { if (c) remaining[c]--; });
                let outerTiles = [];
                colors.forEach(c => { for (let i = 0; i < remaining[c]; i++) outerTiles.push(c); });
                outerTiles.sort(() => Math.random() - 0.5);
                let outerPos = [];
                for (let y = 0; y < 5; y++) {
                    for (let x = 0; x < 5; x++) {
                        if (y >= 1 && y <= 3 && x >= 1 && x <= 3) continue;
                        outerPos.push({x, y});
                    }
                }
                let tileIdx = 0;
                let emptyIdx = Math.floor(Math.random() * outerPos.length);
                for (let i = 0; i < outerPos.length; i++) {
                    let pos = outerPos[i];
                    if (i === emptyIdx) {
                        board[pos.y][pos.x] = null;
                        if (player === 1) emptyPos1 = {x: pos.x, y: pos.y};
                        else emptyPos2 = {x: pos.x, y: pos.y};
                    } else {
                        board[pos.y][pos.x] = outerTiles[tileIdx++] || null;
                    }
                }
                let targetMoves = mode === 'easy' ? 10 : 20;
                for (let i = 0; i < targetMoves; i++) {
                    let moves = getPossibleMoves(player === 1 ? emptyPos1 : emptyPos2);
                    let move = moves[Math.floor(Math.random() * moves.length)];
                    if (move) moveRowOrColumn(move.x, move.y, move.dx, move.dy, false, player, board);
                }
                moveCount = planSolutionSync(board, player === 1 ? emptyPos1 : emptyPos2).length;
                if (moveCount === 0) return initBoard(mode, player);
            }
            if (player === 1) initialMoveCount1 = moveCount || 0;
            else initialMoveCount2 = moveCount || 0;
            return board;
        }

        function generatePattern() {
            let attempts = 0;
            const maxAttempts = 10;
            let moveCount1, moveCount2;
            do {
                pattern = [];
                for (let y = 0; y < 3; y++) {
                    pattern[y] = [];
                    for (let x = 0; x < 3; x++) {
                        pattern[y][x] = colors[Math.floor(Math.random() * colors.length)];
                    }
                }
                let counts = {};
                pattern.flat().forEach(c => counts[c] = (counts[c] || 0) + 1);
                if (Object.values(counts).some(v => v > 4)) continue;

                let tempBoard1 = initBoard(currentMode, 1);
                moveCount1 = planSolutionSync(tempBoard1, emptyPos1).length;
                if (playerCount === 2) {
                    let tempBoard2 = initBoard(currentMode, 2);
                    moveCount2 = planSolutionSync(tempBoard2, emptyPos2).length;
                } else {
                    moveCount2 = moveCount1;
                }
                attempts++;
            } while ((moveCount1 === 0 || (playerCount === 2 && moveCount2 === 0)) && attempts < maxAttempts);
            if (attempts >= maxAttempts) generatePattern();
        }

        function randomizePattern() {
            generatePattern();
            renderPattern();
            const solution = document.getElementById('solution');
            const difficulty1 = document.getElementById('difficulty1');
            const difficulty2 = document.getElementById('difficulty2');
            if (solution) solution.style.display = 'none';
            if (difficulty1) difficulty1.style.display = 'none';
            if (playerCount === 2 && difficulty2) difficulty2.style.display = 'none';
            board1 = initBoard(currentMode, 1);
            if (playerCount === 2) board2 = initBoard(currentMode, 2);
            renderBoard(1);
            if (playerCount === 2) renderBoard(2);
            startTime = Date.now();
            clearInterval(timerInterval1);
            clearInterval(timerInterval2);
            timerInterval1 = setInterval(() => updateTimer(1), 1000);
            if (playerCount === 2) timerInterval2 = setInterval(() => updateTimer(2), 1000);
            moveCount1 = 0;
            moveCount2 = 0;
            gameWon = false;
            updateMoves(1);
            if (playerCount === 2) updateMoves(2);
            updateTimer(1);
            if (playerCount === 2) updateTimer(2);
            updateDifficulty(1);
            if (playerCount === 2) updateDifficulty(2);
        }

        function isSolvableWithin(maxMoves, board, emptyPos) {
            if (!board || !emptyPos) return false;
            const queue = [{board: board.map(row => [...row]), emptyPos: {...emptyPos}, moves: 0}];
            const seenStates = new Set([JSON.stringify(board)]);
            const maxStates = 10000;
            let statesExplored = 0;

            while (queue.length > 0 && statesExplored < maxStates && queue[0].moves < maxMoves) {
                const {board: currentBoard, emptyPos: currentEmpty, moves} = queue.shift();
                if (!currentBoard || !currentEmpty) continue;
                if (isSolved(currentBoard)) return true;
                const possibleMoves = getPossibleMoves(currentEmpty);
                for (const move of possibleMoves) {
                    const newBoard = currentBoard.map(row => [...row]);
                    const newEmpty = {...currentEmpty};
                    const tx = move.x;
                    const ty = move.y;
                    const dx = move.dx;
                    const dy = move.dy;
                    if (dx !== 0) {
                        let row = newBoard[ty];
                        let emptyIndex = row.indexOf(null);
                        if (emptyIndex === -1 || (dx > 0 && tx >= emptyIndex) || (dx < 0 && tx <= emptyIndex)) continue;
                        if (dx > 0) {
                            for (let x = emptyIndex; x > tx; x--) row[x] = row[x - 1];
                        } else {
                            for (let x = emptyIndex; x < tx; x++) row[x] = row[x + 1];
                        }
                        row[tx] = null;
                        newEmpty.x = tx;
                    } else {
                        let column = newBoard.map(row => row[tx]);
                        let emptyIndex = column.indexOf(null);
                        if (emptyIndex === -1 || (dy > 0 && ty >= emptyIndex) || (dy < 0 && ty <= emptyIndex)) continue;
                        if (dy > 0) {
                            for (let y = emptyIndex; y > ty; y--) newBoard[y][tx] = newBoard[y - 1][tx];
                        } else {
                            for (let y = emptyIndex; y < ty; y++) newBoard[y][tx] = newBoard[y + 1][tx];
                        }
                        newBoard[ty][tx] = null;
                        newEmpty.y = ty;
                    }
                    const boardState = JSON.stringify(newBoard);
                    if (!seenStates.has(boardState)) {
                        seenStates.add(boardState);
                        queue.push({
                            board: newBoard,
                            emptyPos: newEmpty,
                            moves: moves + 1
                        });
                        statesExplored++;
                    }
                }
            }
            return false;
        }

        function renderBoard(player) {
            const boardDiv = document.getElementById(`board${player}`);
            const board = player === 1 ? board1 : board2;
            if (!boardDiv || !board) return;
            boardDiv.innerHTML = '';
            for (let y = 0; y < 5; y++) {
                for (let x = 0; x < 5; x++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile ' + (board[y][x] || 'empty');
                    tile.dataset.x = x;
                    tile.dataset.y = y;
                    tile.dataset.player = player;
                    if (!autoSolving) {
                        tile.addEventListener('touchstart', handleTouchStart);
                        tile.addEventListener('touchend', handleTouchEnd);
                    }
                    boardDiv.appendChild(tile);
                }
            }
        }

        function renderPattern() {
            const patDiv = document.getElementById('pattern');
            if (!patDiv) return;
            patDiv.innerHTML = '';
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile ' + (pattern[y][x] || 'empty');
                    patDiv.appendChild(tile);
                }
            }
        }

        let touchStartX, touchStartY;
        function handleTouchStart(e) {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }

        function handleTouchEnd(e) {
            const dx = e.changedTouches[0].clientX - touchStartX;
            const dy = e.changedTouches[0].clientY - touchStartY;
            const tile = e.target;
            const x = parseInt(tile.dataset.x) || 0;
            const y = parseInt(tile.dataset.y) || 0;
            const player = parseInt(tile.dataset.player) || 1;
            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 30) {
                moveRowOrColumn(x, y, dx > 0 ? 1 : -1, 0, true, player);
            } else if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > 30) {
                moveRowOrColumn(x, y, 0, dy > 0 ? 1 : -1, true, player);
            }
        }

        function moveRowOrColumn(tx, ty, dx, dy, update = true, player = 1, targetBoard = null) {
            const board = targetBoard || (player === 1 ? board1 : board2);
            const emptyPos = player === 1 ? emptyPos1 : emptyPos2;
            if (!board || !emptyPos) return false;

            if (dx !== 0) {
                let row = board[ty];
                let emptyIndex = row.indexOf(null);
                if (emptyIndex === -1) return false;

                let startIndex = tx;
                let endIndex = emptyIndex;
                if (dx > 0 && startIndex >= emptyIndex) return false;
                if (dx < 0 && startIndex <= emptyIndex) return false;

                if (dx > 0) {
                    for (let x = emptyIndex; x > startIndex; x--) {
                        row[x] = row[x - 1];
                    }
                } else {
                    for (let x = emptyIndex; x < startIndex; x++) {
                        row[x] = row[x + 1];
                    }
                }
                row[startIndex] = null;
                emptyPos.x = startIndex;
            } else {
                let column = board.map(row => row[tx]);
                let emptyIndex = column.indexOf(null);
                if (emptyIndex === -1) return false;

                let startIndex = ty;
                if (dy > 0 && startIndex >= emptyIndex) return false;
                if (dy < 0 && startIndex <= emptyIndex) return false;

                if (dy > 0) {
                    for (let y = emptyIndex; y > startIndex; y--) {
                        board[y][tx] = board[y - 1][tx];
                    }
                } else {
                    for (let y = emptyIndex; y < startIndex; y++) {
                        board[y][tx] = board[y + 1][tx];
                    }
                }
                board[startIndex][tx] = null;
                emptyPos.y = startIndex;
            }

            if (update && !gameWon) {
                if (player === 1) moveCount1++;
                else moveCount2++;
                updateMoves(player);
                renderBoard(player);
                if (checkWin(player)) return true;
                updateDifficulty(player);
            }
            return true;
        }

        function updateMoves(player) {
            const moveCount = player === 1 ? moveCount1 : moveCount2;
            const board = player === 1 ? board1 : board2;
            const emptyPos = player === 1 ? emptyPos1 : emptyPos2;
            const optimalMoves = board ? planSolutionSync(board, player).length : 0;
            const points = player === 1 ? points1 : points2;
            const movesElement = document.getElementById(`moves${player}`);
            const pointsElement = document.getElementById(`points${player}`);
            const gamesPlayedElement = document.getElementById(`games-played${player}`);
            const gamesWonElement = document.getElementById(`games-won${player}`);
            const progressFill = document.getElementById(`progress-fill${player}`);
            if (movesElement) movesElement.innerText = `Moves: ${moveCount} (${optimalMoves})`;
            if (pointsElement) pointsElement.innerText = `Points: ${points}`;
            if (gamesPlayedElement) gamesPlayedElement.innerText = player === 1 ? gamesPlayed1 : gamesPlayed2;
            if (gamesWonElement) gamesWonElement.innerText = player === 1 ? gamesWon1 : gamesWon2;
            if (progressFill) {
                const winRate = (player === 1 ? gamesPlayed1 : gamesPlayed2) > 0 
                    ? ((player === 1 ? gamesWon1 : gamesWon2) / (player === 1 ? gamesPlayed1 : gamesPlayed2)) * 100 
                    : 0;
                progressFill.style.width = `${winRate}%`;
            }
        }

        function checkWin(player) {
            if (gameWon) return false;
            const board = player === 1 ? board1 : board2;
            if (!board) return false;
            let match = true;
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    if (board[y + 1][x + 1] !== (pattern[y][x] || null)) match = false;
                }
            }
            if (match) {
                gameWon = true;
                clearInterval(timerInterval1);
                if (playerCount === 2) clearInterval(timerInterval2);
                const time = Math.floor((Date.now() - startTime) / 1000);
                const pointsEarned = player === 1 ? (initialMoveCount1 || 0) : (initialMoveCount2 || 0);
                if (player === 1) {
                    points1 += pointsEarned;
                    gamesWon1++;
                    gamesPlayed1++;
                    if (playerCount === 2) gamesPlayed2++;
                } else {
                    points2 += pointsEarned;
                    gamesWon2++;
                    gamesPlayed2++;
                    gamesPlayed1++;
                }
                const gameover = document.getElementById('gameover');
                const winner = document.getElementById('winner');
                const wintime = document.getElementById('wintime');
                const winmoves = document.getElementById('winmoves');
                const winpoints = document.getElementById('winpoints');
                if (winner) winner.innerText = `Player ${player}`;
                if (wintime) wintime.innerText = time;
                if (winmoves) winmoves.innerText = player === 1 ? moveCount1 : moveCount2;
                if (winpoints) winpoints.innerText = pointsEarned;
                if (gameover) gameover.style.display = 'block';
                const thinking = document.getElementById('thinking');
                const solution = document.getElementById('solution');
                const difficulty1 = document.getElementById('difficulty1');
                const difficulty2 = document.getElementById('difficulty2');
                if (thinking) thinking.style.display = 'none';
                if (solution) solution.style.display = 'none';
                if (difficulty1) difficulty1.style.display = 'none';
                if (playerCount === 2 && difficulty2) difficulty2.style.display = 'none';
                updateMoves(1);
                if (playerCount === 2) updateMoves(2);
                autoSolving = false;
            }
            return match;
        }

        function updateTimer(player) {
            const time = Math.floor((Date.now() - startTime) / 1000);
            const timerElement = document.getElementById(`timer${player}`);
            if (timerElement) timerElement.innerText = `Time: ${time}s`;
        }

        async function updateDifficulty(player) {
            const thinking = document.getElementById('thinking');
            if (thinking) thinking.style.display = 'block';
            const moveSequence = await planSolution(player);
            if (thinking) thinking.style.display = 'none';

            const moveCount = moveSequence.length;
            const moveCountElement = document.getElementById(`move-count${player}`);
            const bar = document.getElementById(`difficulty-fill${player}`);
            const difficultyElement = document.getElementById(`difficulty${player}`);
            if (moveCountElement) moveCountElement.innerText = moveCount;
            if (bar) {
                const maxMoves = 100;
                const width = Math.min((moveCount / maxMoves) * 100, 100);
                bar.style.width = `${width}%`;
                bar.className = moveCount <= 10 ? 'easy' : moveCount <= 50 ? 'medium' : 'hard';
            }
            if (difficultyElement) difficultyElement.style.display = 'block';
        }

        function newGame(mode = currentMode, players = playerCount) {
            currentMode = mode === 'easy' || mode === 'hard' ? mode : 'easy';
            playerCount = players === 1 || players === 2 ? players : 1;
            currentPlayer = 1;
            gameWon = false;
            initialMoveCount1 = 0;
            initialMoveCount2 = 0;
            generatePattern();
            board1 = initBoard(currentMode, 1);
            if (playerCount === 2) board2 = initBoard(currentMode, 2);
            renderBoard(1);
            if (playerCount === 2) {
                renderBoard(2);
                const player2 = document.getElementById('player2');
                const hint2 = document.getElementById('hint2');
                const auto2 = document.getElementById('auto2');
                if (player2) player2.style.display = 'block';
                if (hint2) hint2.style.display = 'inline-block';
                if (auto2) auto2.style.display = 'inline-block';
            } else {
                const player2 = document.getElementById('player2');
                const hint2 = document.getElementById('hint2');
                const auto2 = document.getElementById('auto2');
                const difficulty2 = document.getElementById('difficulty2');
                if (player2) player2.style.display = 'none';
                if (hint2) hint2.style.display = 'none';
                if (auto2) auto2.style.display = 'none';
                if (difficulty2) difficulty2.style.display = 'none';
            }
            renderPattern();
            startTime = Date.now();
            clearInterval(timerInterval1);
            clearInterval(timerInterval2);
            timerInterval1 = setInterval(() => updateTimer(1), 1000);
            if (playerCount === 2) timerInterval2 = setInterval(() => updateTimer(2), 1000);
            const gameover = document.getElementById('gameover');
            const thinking = document.getElementById('thinking');
            const solution = document.getElementById('solution');
            const difficulty1 = document.getElementById('difficulty1');
            const difficulty2 = document.getElementById('difficulty2');
            const board1Element = document.getElementById('board1');
            const patternElement = document.getElementById('pattern');
            const stats1 = document.getElementById('stats1');
            const controls = document.getElementById('controls');
            const modeSelection = document.getElementById('mode-selection');
            if (gameover) gameover.style.display = 'none';
            if (thinking) thinking.style.display = 'none';
            if (solution) solution.style.display = 'none';
            if (difficulty1) difficulty1.style.display = 'none';
            if (playerCount === 2 && difficulty2) difficulty2.style.display = 'none';
            if (board1Element) board1Element.style.display = 'grid';
            if (patternElement) patternElement.style.display = 'grid';
            if (stats1) stats1.style.display = 'flex';
            if (controls) controls.style.display = 'block';
            if (modeSelection) modeSelection.style.display = 'block';
            moveCount1 = 0;
            moveCount2 = 0;
            gameWon = false;
            updateMoves(1);
            if (playerCount === 2) updateMoves(2);
            updateTimer(1);
            if (playerCount === 2) updateTimer(2);
            autoSolving = false;
            updateDifficulty(1);
            if (playerCount === 2) updateDifficulty(2);
        }

        async function autoComplete(player) {
            autoSolving = true;
            const thinking = document.getElementById('thinking');
            if (thinking) thinking.style.display = 'block';
            renderBoard(player);

            let moveSequence = await planSolution(player);
            if (thinking) thinking.style.display = 'none';

            if (moveSequence.length > 0) {
                for (const move of moveSequence) {
                    if (!move || gameWon) break;
                    const {x, y, dx, dy} = move || {};
                    if (moveRowOrColumn(x, y, dx, dy, true, player)) {
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                    if (gameWon) return;
                }
            }

            const seenStates = new Set();
            while (!gameWon) {
                const bestMove = getBestMove(player);
                if (!bestMove) {
                    const alternativeMove = getAlternativeMove(player);
                    if (!alternativeMove) break;
                    if (moveRowOrColumn(alternativeMove.x, alternativeMove.y, alternativeMove.dx, alternativeMove.dy, true, player)) {
                        seenStates.add(JSON.stringify(player === 1 ? board1 : board2));
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                } else {
                    const boardState = JSON.stringify(player === 1 ? board1 : board2);
                    if (seenStates.has(boardState)) {
                        const alternativeMove = getAlternativeMove(player);
                        if (!alternativeMove) break;
                        if (moveRowOrColumn(alternativeMove.x, alternativeMove.y, alternativeMove.dx, alternativeMove.dy, true, player)) {
                            seenStates.add(boardState);
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    } else {
                        if (moveRowOrColumn(bestMove.x, bestMove.y, bestMove.dx, bestMove.dy, true, player)) {
                            seenStates.add(boardState);
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }
                }
            }

            autoSolving = false;
            renderBoard(player);
        }

        async function showSolution() {
            const thinking = document.getElementById('thinking');
            if (thinking) thinking.style.display = 'block';
            const moveSequence = await planSolution(currentPlayer);
            if (thinking) thinking.style.display = 'none';

            const solutionDiv = document.getElementById('solution');
            if (!solutionDiv) return;
            solutionDiv.innerHTML = '';
            if (moveSequence.length === 0) {
                solutionDiv.innerHTML = '<p>No solution found within time limit.</p>';
            } else {
                const header = document.createElement('p');
                header.innerText = `Solution for Player ${currentPlayer}: ${moveSequence.length} moves`;
                solutionDiv.appendChild(header);
                moveSequence.forEach((move, index) => {
                    const {x, y, dx, dy} = move || {};
                    const direction = dx > 0 ? 'right' : dx < 0 ? 'left' : dy > 0 ? 'down' : 'up';
                    const p = document.createElement('p');
                    p.innerText = `${index + 1}. Move tile at (${x},${y}) ${direction}`;
                    solutionDiv.appendChild(p);
                });
            }
            solutionDiv.style.display = 'block';
        }

        function planSolutionSync(board, player) {
            if (!board || !player) return [];
            const startTime = Date.now();
            const maxTime = 5000;
            const emptyPos = player === 1 ? {...emptyPos1} : {...emptyPos2};
            const queue = [{board: board.map(row => [...row]), emptyPos, moves: []}];
            const seenStates = new Set([JSON.stringify(board)]);
            const maxStates = 10000;

            while (queue.length > 0 && (Date.now() - startTime) < maxTime) {
                const {board: currentBoard, emptyPos: currentEmpty, moves} = queue.shift();
                if (!currentBoard || !currentEmpty) continue;

                if (isSolved(currentBoard)) {
                    return moves;
                }

                const possibleMoves = getPossibleMoves(currentEmpty, player);
                for (const move of possibleMoves) {
                    const newBoard = currentBoard.map(row => [...row]);
                    const newEmpty = {...currentEmpty};
                    const tx = move.x;
                    const ty = move.y;
                    const dx = move.dx;
                    const dy = move.dy;

                    if (dx !== 0) {
                        let row = newBoard[ty];
                        let emptyIndex = row.indexOf(null);
                        if (emptyIndex === -1 || (dx > 0 && tx >= emptyIndex) || (dx < 0 && tx <= emptyIndex)) continue;

                        if (dx > 0) {
                            for (let x = emptyIndex; x > tx; x--) row[x] = row[x - 1];
                        } else {
                            for (let x = emptyIndex; x < tx; x++) row[x] = row[x + 1];
                        }
                        row[tx] = null;
                        newEmpty.x = tx;
                    } else {
                        let column = newBoard.map(row => row[tx]);
                        let emptyIndex = column.indexOf(null);
                        if (emptyIndex === -1 || (dy > 0 && ty >= emptyIndex) || (dy < 0 && ty <= emptyIndex)) continue;

                        if (dy > 0) {
                            for (let y = emptyIndex; y > ty; y--) newBoard[y][tx] = newBoard[y - 1][tx];
                        } else {
                            for (let y = emptyIndex; y < ty; y++) newBoard[y][tx] = newBoard[y + 1][tx];
                        }
                        newBoard[ty][tx] = null;
                        newEmpty.y = ty;
                    }

                    const boardState = JSON.stringify(newBoard);
                    if (!seenStates.has(boardState)) {
                        seenStates.add(boardState);
                        queue.push({
                            board: newBoard,
                            emptyPos: newEmpty,
                            moves: [...moves, move]
                        });
                    }
                }

                if (seenStates.size >= maxStates) break;

                queue.sort((a, b) => {
                    const scoreA = getCorrectTileCount(a.board) - a.moves.length / 100;
                    const scoreB = getCorrectTileCount(b.board) - b.moves.length / 100;
                    return scoreB - scoreA;
                });
            }

            return [];
        }

        async function planSolution(player) {
            return new Promise(resolve => {
                resolve(planSolutionSync(player === 1 ? board1 : board2, player));
            });
        }

        function getCorrectTileCount(tempBoard) {
            if (!tempBoard) return 0;
            let correct = 0;
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    if (tempBoard[y + 1][x + 1] === (pattern[y][x] || null)) correct++;
                }
            }
            return correct;
        }

        function getPossibleMoves(empty = emptyPos1, player = 1) {
            const moves = [];
            if (!empty) return moves;
            for (let x = 0; x < 5; x++) {
                if (x !== empty.x) {
                    const dx = x < empty.x ? 1 : -1;
                    moves.push({x, y: empty.y, dx, dy: 0});
                }
            }
            for (let y = 0; y < 5; y++) {
                if (y !== empty.y) {
                    const dy = y < empty.y ? 1 : -1;
                    moves.push({x: empty.x, y, dx: 0, dy});
                }
            }
            return moves;
        }

        function isSolved(board) {
            if (!board) return false;
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    if (board[y + 1][x + 1] !== (pattern[y][x] || null)) return false;
                }
            }
            return true;
        }

        function getBestMove(player) {
            const board = player === 1 ? board1 : board2;
            const empty = player === 1 ? emptyPos1 : emptyPos2;
            if (!board || !empty) return null;
            const moves = getPossibleMoves(empty, player);
            let bestMove = null;
            let bestScore = -Infinity;

            for (const move of moves) {
                const tempBoard = board.map(row => [...row]);
                const tx = move.x;
                const ty = move.y;
                const dx = move.dx;
                const dy = move.dy;

                if (dx !== 0) {
                    let row = tempBoard[ty];
                    let emptyIndex = row.indexOf(null);
                    if (emptyIndex === -1 || (dx > 0 && tx >= emptyIndex) || (dx < 0 && tx <= emptyIndex)) continue;

                    if (dx > 0) {
                        for (let x = emptyIndex; x > tx; x--) row[x] = row[x - 1];
                    } else {
                        for (let x = emptyIndex; x < tx; x++) row[x] = row[x + 1];
                    }
                    row[tx] = null;
                } else {
                    let column = tempBoard.map(row => row[tx]);
                    let emptyIndex = column.indexOf(null);
                    if (emptyIndex === -1 || (dy > 0 && ty >= emptyIndex) || (dy < 0 && ty <= emptyIndex)) continue;

                    if (dy > 0) {
                        for (let y = emptyIndex; y > ty; y--) tempBoard[y][tx] = tempBoard[y - 1][tx];
                    } else {
                        for (let y = emptyIndex; y < ty; y++) tempBoard[y][tx] = tempBoard[y + 1][tx];
                    }
                    tempBoard[ty][tx] = null;
                }

                const score = getCorrectTileCount(tempBoard);
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }

            return bestMove;
        }

        function getAlternativeMove(player) {
            const empty = player === 1 ? emptyPos1 : emptyPos2;
            const moves = getPossibleMoves(empty, player);
            return moves[Math.floor(Math.random() * moves.length)] || null;
        }

        function hint(player) {
            const tiles = document.querySelectorAll(`#board${player} .tile`);
            tiles.forEach(t => t.classList.remove('hint'));
            
            const bestMove = getBestMove(player);
            if (bestMove) {
                const idx = bestMove.y * 5 + bestMove.x;
                tiles[idx].classList.add('hint');
                setTimeout(() => tiles[idx].classList.remove('hint'), 2000);
            }
        }

        document.getElementById('board1')?.addEventListener('touchend', () => {
            if (!document.getElementById('gameover')?.style.display && !autoSolving) {
                currentPlayer = 1;
                hint(1);
                updateDifficulty(1);
            }
        });
        document.getElementById('board2')?.addEventListener('touchend', () => {
            if (!document.getElementById('gameover')?.style.display && !autoSolving) {
                currentPlayer = 2;
                hint(2);
                updateDifficulty(2);
            }
        });

        newGame();
    </script>
</body>
</html>
