<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hex Grid Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #toggleButton, #speedUpButton, #addPlayerButton {
            position: absolute;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            background: #333;
            color: white;
            border: none;
            border-radius: 5px;
        }
        #toggleButton { left: 10px; top: 10px; }
        #speedUpButton { left: 120px; top: 10px; }
        #addPlayerButton { left: 10px; top: 50px; }
        #levelDisplay, #gameOverDisplay, #wallDisplay, #countdownDisplay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 10px;
            display: none;
            font-family: Arial, sans-serif;
        }
        #statsDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 16px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            width: 200px;
        }
        #timerDisplay {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
        }
        .red-stat { color: #ff0000; }
        .blue-stat { color: #0000ff; }
        .green-stat { color: #00ff00; }
        .yellow-stat { color: #ffff00; }
        .purple-stat { color: #800080; }
        .progress-bar {
            width: 100%;
            background: #333;
            height: 10px;
            border-radius: 5px;
            margin: 5px 0;
            display: flex;
            overflow: hidden;
        }
        .progress-bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            display: inline-block;
        }
        .red-progress { background: #ff0000; }
        .blue-progress { background: #0000ff; }
        .green-progress { background: #00ff00; }
        .yellow-progress { background: #ffff00; }
        .purple-progress { background: #800080; }
    </style>
</head>
<body>
    <button id="toggleButton">Toggle Autoplay</button>
    <button id="speedUpButton">Speed Up</button>
    <button id="addPlayerButton">Add Player</button>
    <div id="levelDisplay"></div>
    <div id="gameOverDisplay"></div>
    <div id="wallDisplay"></div>
    <div id="countdownDisplay"></div>
    <div id="statsDisplay"></div>
    <div id="timerDisplay"></div>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Spotlights
        const spotlights = {
            fly: new THREE.SpotLight(0xffffff, 1, 0, Math.PI / 4, 0.5, 2),
            red: new THREE.SpotLight(0xff0000, 0.8, 0, Math.PI / 6, 0.5, 2),
            blue: new THREE.SpotLight(0x0000ff, 0.8, 0, Math.PI / 6, 0.5, 2),
            green: new THREE.SpotLight(0x00ff00, 0.8, 0, Math.PI / 6, 0.5, 2),
            yellow: new THREE.SpotLight(0xffff00, 0.8, 0, Math.PI / 6, 0.5, 2),
            purple: new THREE.SpotLight(0x800080, 0.8, 0, Math.PI / 6, 0.5, 2)
        };
        Object.values(spotlights).forEach(spotlight => {
            spotlight.castShadow = true;
            spotlight.visible = false;
            scene.add(spotlight);
            scene.add(spotlight.target);
        });

        const gridSize = 16;
        const hexRadius = 1;
        const hexHeight = 0.2;
        const hexGeometry = new THREE.CylinderGeometry(hexRadius, hexRadius, hexHeight, 6);
        const hexMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x00ff00, 
            transparent: true, 
            opacity: 0.2, 
            shininess: 100,
            emissive: 0x00ff00,
            emissiveIntensity: 0.5
        });
        const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
        const grid = [];
        let trails = {};
        let walls = new Map();

        for (let x = 0; x < gridSize; x++) {
            grid[x] = [];
            for (let y = 0; y < gridSize; y++) {
                const hex = new THREE.Mesh(hexGeometry, hexMaterial);
                hex.receiveShadow = true;
                const offset = y % 2 ? hexRadius * Math.sqrt(3) / 2 : 0;
                hex.position.set(x * hexRadius * Math.sqrt(3) + offset, 0, y * hexRadius * 1.5);
                scene.add(hex);

                const edges = new THREE.EdgesGeometry(hexGeometry);
                const line = new THREE.LineSegments(edges, edgeMaterial);
                line.position.copy(hex.position);
                scene.add(line);

                grid[x][y] = { mesh: hex, visits: { red: 0, blue: 0, green: 0, yellow: 0, purple: 0 } };
            }
        }

        const playerGeometry = new THREE.SphereGeometry(0.3, 32, 32);
        const playerMaterialConfig = (color) => ({
            color,
            shininess: 100,
            emissive: color,
            emissiveIntensity: 0.5,
            roughness: 0.4,
            metalness: 0.2
        });
        let players = {
            red: { 
                x: 0, y: 0, 
                color: 0xff0000, 
                speed: 3.0,
                mesh: new THREE.Mesh(playerGeometry, new THREE.MeshStandardMaterial(playerMaterialConfig(0xff0000))),
                moves: 0,
                wallsCreated: 0,
                targetPosition: null,
                transitionStart: null,
                transitionDuration: 300,
                lastDirection: { dx: 0, dy: 0 },
                moveHistory: []
            },
            blue: { 
                x: gridSize - 1, y: gridSize - 1,
                color: 0x0000ff, 
                speed: 3.0,
                mesh: new THREE.Mesh(playerGeometry, new THREE.MeshStandardMaterial(playerMaterialConfig(0x0000ff))),
                moves: 0,
                wallsCreated: 0,
                targetPosition: null,
                transitionStart: null,
                transitionDuration: 300,
                lastDirection: { dx: 0, dy: 0 },
                moveHistory: []
            }
        };

        Object.values(players).forEach(player => {
            const { x, y } = player;
            player.mesh.position.copy(grid[x][y].mesh.position);
            player.mesh.position.y = hexHeight + 0.3;
            player.mesh.castShadow = true;
            player.mesh.receiveShadow = true;
            scene.add(player.mesh);
        });

        const gridWidth = gridSize * hexRadius * Math.sqrt(3);
        const gridHeight = gridSize * hexRadius * 1.5;
        const maxDim = Math.max(gridWidth, gridHeight);
        const fullViewPosition = new THREE.Vector3(gridWidth / 2, maxDim * 1.5, gridHeight / 2);
        const fullViewTarget = new THREE.Vector3(gridWidth / 2, 0, gridHeight / 2);

        // Camera view states
        let cameraView = 'full';
        let cameraViews = ['full', 'red', 'blue', 'fly'];
        let cameraViewIndex = 0;
        let flyAngle = 0;
        let shakeTime = 0;
        let shakeDuration = 500;
        let shakeAmplitude = 0.5;

        // Set initial camera position farther away
        const startViewPosition = fullViewPosition.clone().multiplyScalar(3);
        camera.position.copy(startViewPosition);
        camera.lookAt(fullViewTarget);

        // Countdown and game start
        let gameStarted = false;
        let gameOver = false;
        const countdownDisplay = document.getElementById('countdownDisplay');
        const gameDuration = 60000; // 1 minute
        let startTime;

        function startCountdown() {
            let countdown = 3;
            countdownDisplay.style.display = 'block';
            const countdownStartTime = Date.now();
            function updateCountdown() {
                const elapsed = Date.now() - countdownStartTime;
                const t = Math.min(elapsed / 3000, 1);
                if (elapsed < 1000) {
                    countdownDisplay.textContent = '3';
                } else if (elapsed < 2000) {
                    countdownDisplay.textContent = '2';
                } else if (elapsed < 3000) {
                    countdownDisplay.textContent = '1';
                } else {
                    countdownDisplay.textContent = 'Start!';
                    setTimeout(() => {
                        countdownDisplay.style.display = 'none';
                        gameStarted = true;
                        startTime = Date.now() + gameDuration; // Set end time
                    }, 500);
                    return;
                }
                camera.position.lerpVectors(startViewPosition, fullViewPosition, t);
                camera.lookAt(fullViewTarget);
                renderer.render(scene, camera);
                requestAnimationFrame(updateCountdown);
            }
            updateCountdown();
        }

        // Add player button
        const addPlayerButton = document.getElementById('addPlayerButton');
        let nextPlayer = 'green';
        addPlayerButton.addEventListener('click', () => {
            if (!gameStarted || Object.keys(players).length >= 4) return;
            let newPlayer;
            if (nextPlayer === 'green') {
                newPlayer = {
                    x: Math.floor(gridSize / 2),
                    y: Math.floor(gridSize / 2),
                    color: 0x00ff00,
                    speed: 3.0,
                    mesh: new THREE.Mesh(playerGeometry, new THREE.MeshStandardMaterial(playerMaterialConfig(0x00ff00))),
                    moves: 0,
                    wallsCreated: 0,
                    targetPosition: null,
                    transitionStart: null,
                    transitionDuration: 300,
                    lastDirection: { dx: 0, dy: 0 },
                    moveHistory: []
                };
                nextPlayer = 'yellow';
            } else if (nextPlayer === 'yellow') {
                newPlayer = {
                    x: 0, y: gridSize - 1,
                    color: 0xffff00,
                    speed: 3.0,
                    mesh: new THREE.Mesh(playerGeometry, new THREE.MeshStandardMaterial(playerMaterialConfig(0xffff00))),
                    moves: 0,
                    wallsCreated: 0,
                    targetPosition: null,
                    transitionStart: null,
                    transitionDuration: 300,
                    lastDirection: { dx: 0, dy: 0 },
                    moveHistory: []
                };
                nextPlayer = 'purple';
            } else if (nextPlayer === 'purple') {
                newPlayer = {
                    x: gridSize - 1, y: 0,
                    color: 0x800080,
                    speed: 3.0,
                    mesh: new THREE.Mesh(playerGeometry, new THREE.MeshStandardMaterial(playerMaterialConfig(0x800080))),
                    moves: 0,
                    wallsCreated: 0,
                    targetPosition: null,
                    transitionStart: null,
                    transitionDuration: 300,
                    lastDirection: { dx: 0, dy: 0 },
                    moveHistory: []
                };
                nextPlayer = null;
            }
            if (newPlayer) {
                newPlayer.mesh.position.copy(grid[newPlayer.x][newPlayer.y].mesh.position);
                newPlayer.mesh.position.y = hexHeight + 0.3;
                newPlayer.mesh.castShadow = true;
                newPlayer.mesh.receiveShadow = true;
                scene.add(newPlayer.mesh);
                const playerKey = nextPlayer === 'yellow' ? 'green' : nextPlayer === 'purple' ? 'yellow' : 'purple';
                players[playerKey] = newPlayer;
                cameraViews.push(playerKey);
                addPlayerButton.textContent = nextPlayer ? `Add ${nextPlayer.charAt(0).toUpperCase() + nextPlayer.slice(1)} Player` : 'Max Players';
                addPlayerButton.disabled = !nextPlayer;
            }
        });

        // Handle tap or click to switch camera or restart
        function handleInteraction(event) {
            event.preventDefault(); // Prevent default behavior
            if (gameOver) {
                resetGame();
                return;
            }
            if (!gameStarted) return;
            cameraViewIndex = (cameraViewIndex + 1) % cameraViews.length;
            cameraView = cameraViews[cameraViewIndex];
            Object.keys(spotlights).forEach(key => {
                spotlights[key].visible = cameraView === key;
            });
        }
        ['touchstart', 'click'].forEach(eventType => {
            document.addEventListener(eventType, handleInteraction);
        });

        // Timer
        const timerDisplay = document.getElementById('timerDisplay');
        function updateTimer() {
            if (!gameStarted || gameOver) return;
            const remaining = Math.max(0, Math.floor((startTime - Date.now()) / 1000));
            const minutes = Math.floor(remaining / 60);
            const seconds = remaining % 60;
            timerDisplay.textContent = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            return remaining;
        }

        const trailGeometry = new THREE.CylinderGeometry(hexRadius, hexRadius, hexHeight / 2, 6);
        function addTrail(x, y, color, visits) {
            const alpha = Math.min(0.2 * visits, 0.8);
            const trailMaterial = new THREE.MeshPhongMaterial({
                color, transparent: true, opacity: alpha, shininess: 50,
                emissive: color, emissiveIntensity: 0.3
            });
            const trail = new THREE.Mesh(trailGeometry, trailMaterial);
            trail.position.copy(grid[x][y].mesh.position);
            trail.position.y += hexHeight / 2;
            scene.add(trail);
            const key = `${x},${y}`;
            if (!trails[key]) trails[key] = [];
            trails[key].push(trail);
        }

        function createWall(x, y, color) {
            const initialHeight = hexHeight * 2;
            const wallMaterial = new THREE.MeshPhongMaterial({ 
                color, 
                shininess: 50, 
                transparent: true, 
                opacity: 0.3,
                emissive: color,
                emissiveIntensity: 0.5
            });
            const wallGeometry = new THREE.CylinderGeometry(hexRadius, hexRadius, initialHeight, 6);
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.copy(grid[x][y].mesh.position);
            wall.position.y += hexHeight;
            wall.castShadow = true;
            scene.add(wall);

            const borderGeometry = new THREE.EdgesGeometry(wallGeometry);
            const borderMaterial = new THREE.LineBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.5 
            });
            const border = new THREE.LineSegments(borderGeometry, borderMaterial);
            border.position.copy(wall.position);
            border.scale.set(1.05, 1, 1.05);
            scene.add(border);

            const beamGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2, 8);
            const beamMaterial = new THREE.MeshBasicMaterial({ 
                color: color, 
                transparent: true, 
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const beam = new THREE.Mesh(beamGeometry, beamMaterial);
            beam.position.copy(wall.position);
            beam.position.y += initialHeight / 2 + 1;
            scene.add(beam);

            const startTime = Date.now();
            function animateBeam() {
                const elapsed = Date.now() - startTime;
                const duration = 1000;
                if (elapsed < duration) {
                    const t = elapsed / duration;
                    beam.scale.y = 1 + t * 3;
                    beamMaterial.opacity = 0.8 * (1 - t);
                    beam.position.y += 0.02;
                    requestAnimationFrame(animateBeam);
                } else {
                    scene.remove(beam);
                    beamGeometry.dispose();
                    beamMaterial.dispose();
                }
            }
            animateBeam();

            walls.set(`${x},${y}`, { color, mesh: wall, height: initialHeight, border });

            const flashMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff, 
                shininess: 100,
                emissive: 0xffffff,
                emissiveIntensity: 1
            });
            wall.material = flashMaterial;
            setTimeout(() => {
                wall.material = wallMaterial;
            }, 500);

            const wallDisplay = document.getElementById('wallDisplay');
            wallDisplay.textContent = `${color === 0xff0000 ? 'Red' : color === 0x0000ff ? 'Blue' : color === 0x00ff00 ? 'Green' : color === 0xffff00 ? 'Yellow' : 'Purple'} Wall Created!`;
            wallDisplay.style.display = 'block';
            setTimeout(() => {
                wallDisplay.style.display = 'none';
            }, 1000);

            const player = Object.values(players).find(p => p.color === color);
            player.wallsCreated++;
        }

        function increaseWallHeight(x, y, color) {
            const wallData = walls.get(`${x},${y}`);
            if (!wallData) return;
            const newHeight = wallData.height + hexHeight;
            if (newHeight > 20) return;
            const newGeometry = new THREE.CylinderGeometry(hexRadius, hexRadius, newHeight, 6);
            const wallMaterial = new THREE.MeshPhongMaterial({ 
                color: wallData.color, 
                shininess: 50, 
                transparent: true, 
                opacity: 0.3,
                emissive: wallData.color,
                emissiveIntensity: 0.5
            });
            scene.remove(wallData.mesh);
            scene.remove(wallData.border);
            const newWall = new THREE.Mesh(newGeometry, wallMaterial);
            newWall.position.copy(grid[x][y].mesh.position);
            newWall.position.y += hexHeight;
            newWall.castShadow = true;
            scene.add(newWall);

            const borderGeometry = new THREE.EdgesGeometry(newGeometry);
            const borderMaterial = new THREE.LineBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.5 
            });
            const newBorder = new THREE.LineSegments(borderGeometry, borderMaterial);
            newBorder.position.copy(newWall.position);
            newBorder.scale.set(1.05, 1, 1.05);
            scene.add(newBorder);

            walls.set(`${x},${y}`, { color: wallData.color, mesh: newWall, height: newHeight, border: newBorder });
        }

        function getReachableHexes(player) {
            const visited = new Set();
            const queue = [[player.x, player.y]];
            const playerColor = player.color;
            visited.add(`${player.x},${player.y}`);

            const directions = [
                { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
            ];

            while (queue.length > 0) {
                const [x, y] = queue.shift();
                for (const { dx, dy } of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    const key = `${newX},${newY}`;
                    if (
                        newX >= 0 && newX < gridSize &&
                        newY >= 0 && newY < gridSize &&
                        !visited.has(key) &&
                        (!walls.has(key) || walls.get(key).color === playerColor)
                    ) {
                        visited.add(key);
                        queue.push([newX, newY]);
                    }
                }
            }

            return visited.size;
        }

        function calculateWinProbabilities() {
            const probabilities = {};
            let totalScore = 0;
            const playerScores = {};

            Object.values(players).forEach(player => {
                const reachableHexes = getReachableHexes(player);
                const wallsScore = player.wallsCreated * 10;
                const score = reachableHexes + wallsScore;
                playerScores[player.color] = score;
                totalScore += score;
            });

            Object.values(players).forEach(player => {
                const score = playerScores[player.color];
                probabilities[player.color] = totalScore > 0 ? (score / totalScore) * 100 : 25;
            });

            const sum = Object.values(probabilities).reduce((a, b) => a + b, 0);
            if (sum > 0) {
                Object.keys(probabilities).forEach(key => {
                    probabilities[key] = (probabilities[key] / sum) * 100;
                });
            }

            return probabilities;
        }

        function checkCollision() {
            const playerPositions = Object.values(players).map(p => `${p.x},${p.y}`);
            const uniquePositions = new Set(playerPositions);
            if (uniquePositions.size < playerPositions.length) {
                shakeTime = Date.now();
                Object.values(players).forEach(player => {
                    const reverseDir = { dx: -player.lastDirection.dx, dy: -player.lastDirection.dy };
                    movePlayer(player, reverseDir.dx, reverseDir.dy);
                });
            }
        }

        function isPlayerTrapped(player) {
            const { x, y } = player;
            const playerColor = player.color;
            const directions = [
                { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
            ];
            return directions.every(({ dx, dy }) => {
                const newX = x + dx;
                const newY = y + dy;
                const key = `${newX},${newY}`;
                return !(newX >= 0 && newX < gridSize && newY >= 0 && newY < gridSize && (!walls.has(key) || walls.get(key).color === playerColor));
            });
        }

        function checkTripletRepetition(player) {
            const wallMoves = player.moveHistory.filter(move => move.onOwnWall);
            if (wallMoves.length < 3) return false;

            const triplets = [];
            for (let i = 0; i < wallMoves.length - 2; i++) {
                const triplet = [
                    `${wallMoves[i].x},${wallMoves[i].y}`,
                    `${wallMoves[i+1].x},${wallMoves[i+1].y}`,
                    `${wallMoves[i+2].x},${wallMoves[i+2].y}`
                ].join('|');
                triplets.push(triplet);
            }

            const tripletCounts = {};
            triplets.forEach(triplet => {
                tripletCounts[triplet] = (tripletCounts[triplet] || 0) + 1;
                if (tripletCounts[triplet] >= 3) {
                    return true;
                }
            });

            return false;
        }

        function checkNoMoreWalls() {
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    const key = `${x},${y}`;
                    if (!walls.has(key)) {
                        if (grid[x][y].visits.red < 5 || grid[x][y].visits.blue < 5 || 
                            (players.green && grid[x][y].visits.green < 5) || 
                            (players.yellow && grid[x][y].visits.yellow < 5) || 
                            (players.purple && grid[x][y].visits.purple < 5)) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function movePlayer(player, dx, dy) {
            const newX = player.x + dx;
            const newY = player.y + dy;
            const key = `${newX},${newY}`;
            const playerColor = player.color;
            if (newX >= 0 && newX < gridSize && newY >= 0 && newY < gridSize && (!walls.has(key) || walls.get(key).color === playerColor)) {
                const colorKey = player === players.red ? 'red' : 
                                player === players.blue ? 'blue' : 
                                player === players.green ? 'green' : 
                                player === players.yellow ? 'yellow' : 'purple';
                player.lastDirection = { dx, dy };
                player.x = newX;
                player.y = newY;
                player.targetPosition = grid[newX][newY].mesh.position.clone();
                player.targetPosition.y = hexHeight + 0.3;
                player.transitionStart = Date.now();
                grid[newX][newY].visits[colorKey]++;
                player.moves++;

                player.moveHistory.push({ x: newX, y: newY, onOwnWall: walls.has(key) && walls.get(key).color === playerColor });

                addTrail(newX, newY, player.color, grid[newX][newY].visits[colorKey]);
                if (grid[newX][newY].visits[colorKey] >= 5 && !walls.has(key)) {
                    createWall(newX, newY, player.color);
                } else if (walls.has(key) && walls.get(key).color === playerColor) {
                    increaseWallHeight(newX, newY, player.color);
                }
                checkCollision();

                if (walls.has(key) && walls.get(key).color === playerColor && checkTripletRepetition(player)) {
                    showGameOver(colorKey, 'repeated a move triplet 3 times');
                }
            }
        }

        function updatePlayerPosition(player) {
            if (player.targetPosition && player.transitionStart) {
                const elapsed = Date.now() - player.transitionStart;
                const t = Math.min(elapsed / player.transitionDuration, 1);
                const startPos = player.mesh.position.clone();
                const endPos = player.targetPosition;
                player.mesh.position.lerpVectors(startPos, endPos, t);
                if (t >= 1) {
                    player.targetPosition = null;
                    player.transitionStart = null;
                }
            }
        }

        function autoplayMove(player) {
            if (!autoplay || !gameStarted || gameOver) return;
            const directions = [
                { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
            ];
            const playerColor = player.color;
            const validDirections = directions.filter(({ dx, dy }) => {
                const newX = player.x + dx;
                const newY = player.y + dy;
                const key = `${newX},${newY}`;
                return newX >= 0 && newX < gridSize && newY >= 0 && newY < gridSize && !walls.has(key);
            });
            const chosenDirections = validDirections.length > 0 ? validDirections : directions;
            const { dx, dy } = chosenDirections[Math.floor(Math.random() * chosenDirections.length)];
            movePlayer(player, dx, dy);
        }

        const keys = {};
        document.addEventListener('keydown', (e) => { keys[e.key] = true; });
        document.addEventListener('keyup', (e) => { keys[e.key] = false; });

        let autoplay = true;
        const toggleButton = document.getElementById('toggleButton');
        toggleButton.addEventListener('click', () => {
            if (!gameStarted) return;
            autoplay = !autoplay;
            toggleButton.textContent = autoplay ? 'Toggle Autoplay (On)' : 'Toggle Autoplay (Off)';
        });

        const speedUpButton = document.getElementById('speedUpButton');
        speedUpButton.addEventListener('click', () => {
            if (!gameStarted) return;
            Object.values(players).forEach(player => {
                player.speed *= 1.2;
                player.transitionDuration *= 0.7;
            });
        });

        let level = 1;
        let lastLevelTime = Date.now();
        const levelDisplay = document.getElementById('levelDisplay');
        const gameOverDisplay = document.getElementById('gameOverDisplay');
        const statsDisplay = document.getElementById('statsDisplay');

        function showLevelFlash() {
            levelDisplay.textContent = `Level ${level}`;
            levelDisplay.style.display = 'block';
            setTimeout(() => {
                levelDisplay.style.display = 'none';
            }, 1000);
        }

        function showGameOver(triggerPlayer = null, reason = null) {
            gameOver = true;
            autoplay = false;
            toggleButton.textContent = 'Toggle Autoplay (Off)';

            let message = `Game Over - Level ${level}\n`;
            const probabilities = calculateWinProbabilities();
            let winner = null;
            let maxProb = -1;
            Object.entries(probabilities).forEach(([color, prob]) => {
                const playerKey = Object.keys(players).find(key => players[key].color === parseInt(color));
                if (prob > maxProb) {
                    maxProb = prob;
                    winner = playerKey;
                }
            });
            const winnerName = winner ? winner.charAt(0).toUpperCase() + winner.slice(1) : 'No one';

            if (reason === 'repeated a move triplet 3 times') {
                const playerName = triggerPlayer.charAt(0).toUpperCase() + triggerPlayer.slice(1);
                message += `${playerName} Loses! Repeated a move triplet 3 times`;
            } else if (reason === 'no more walls') {
                message += `${winnerName} Wins! No more walls can be created`;
            } else if (reason === 'time up') {
                message += `${winnerName} Wins! Time's up`;
            } else {
                const trappedPlayers = Object.keys(players).filter(key => isPlayerTrapped(players[key]));
                const trappedNames = trappedPlayers.map(key => key.charAt(0).toUpperCase() + key.slice(1));
                const reasonText = trappedNames.length > 0 ? `${trappedNames.join(' and ')} trapped` : 'All players trapped';
                message += `${winnerName} Wins! ${reasonText}`;
            }

            gameOverDisplay.textContent = message;
            gameOverDisplay.style.display = 'block';
        }

        function resetGame() {
            gameOver = false;
            gameStarted = false;
            gameOverDisplay.style.display = 'none';
            level = 1;
            lastLevelTime = Date.now();
            autoplay = true;
            toggleButton.textContent = 'Toggle Autoplay (On)';
            cameraView = 'full';
            cameraViewIndex = 0;
            camera.position.copy(startViewPosition);
            camera.lookAt(fullViewTarget);

            walls.forEach(wall => {
                scene.remove(wall.mesh);
                scene.remove(wall.border);
            });
            walls.clear();

            Object.values(trails).forEach(trailArray => {
                trailArray.forEach(trail => scene.remove(trail));
            });
            trails = {};

            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    grid[x][y].visits = { red: 0, blue: 0, green: 0, yellow: 0, purple: 0 };
                }
            }

            Object.values(players).forEach(player => {
                scene.remove(player.mesh);
            });
            players = {
                red: { 
                    x: 0, y: 0, 
                    color: 0xff0000, 
                    speed: 3.0,
                    mesh: new THREE.Mesh(playerGeometry, new THREE.MeshStandardMaterial(playerMaterialConfig(0xff0000))),
                    moves: 0,
                    wallsCreated: 0,
                    targetPosition: null,
                    transitionStart: null,
                    transitionDuration: 300,
                    lastDirection: { dx: 0, dy: 0 },
                    moveHistory: []
                },
                blue: { 
                    x: gridSize - 1, y: gridSize - 1,
                    color: 0x0000ff, 
                    speed: 3.0,
                    mesh: new THREE.Mesh(playerGeometry, new THREE.MeshStandardMaterial(playerMaterialConfig(0x0000ff))),
                    moves: 0,
                    wallsCreated: 0,
                    targetPosition: null,
                    transitionStart: null,
                    transitionDuration: 300,
                    lastDirection: { dx: 0, dy: 0 },
                    moveHistory: []
                }
            };
            Object.values(players).forEach(player => {
                const { x, y } = player;
                player.mesh.position.copy(grid[x][y].mesh.position);
                player.mesh.position.y = hexHeight + 0.3;
                player.mesh.castShadow = true;
                player.mesh.receiveShadow = true;
                scene.add(player.mesh);
            });

            nextPlayer = 'green';
            addPlayerButton.textContent = 'Add Green Player';
            addPlayerButton.disabled = false;
            cameraViews = ['full', 'red', 'blue', 'fly'];

            startCountdown();
        }

        function updateStats() {
            const probabilities = calculateWinProbabilities();
            statsDisplay.innerHTML = `Level: ${level}<br>` +
                `<span class="red-stat">Red Moves: ${players.red.moves}</span><br>` +
                `<span class="red-stat">Red Walls: ${players.red.wallsCreated}</span><br>` +
                `<span class="red-stat">Red Speed: ${players.red.speed.toFixed(1)}</span><br>` +
                `<span class="red-stat">Red Win: ${probabilities[0xff0000].toFixed(1)}%</span><br>` +
                `<span class="blue-stat">Blue Moves: ${players.blue.moves}</span><br>` +
                `<span class="blue-stat">Blue Walls: ${players.blue.wallsCreated}</span><br>` +
                `<span class="blue-stat">Blue Speed: ${players.blue.speed.toFixed(1)}</span><br>` +
                `<span class="blue-stat">Blue Win: ${probabilities[0x0000ff].toFixed(1)}%</span><br>` +
                (players.green ? `<span class="green-stat">Green Moves: ${players.green.moves}</span><br>` +
                `<span class="green-stat">Green Walls: ${players.green.wallsCreated}</span><br>` +
                `<span class="green-stat">Green Speed: ${players.green.speed.toFixed(1)}</span><br>` +
                `<span class="green-stat">Green Win: ${probabilities[0x00ff00].toFixed(1)}%</span><br>` : '') +
                (players.yellow ? `<span class="yellow-stat">Yellow Moves: ${players.yellow.moves}</span><br>` +
                `<span class="yellow-stat">Yellow Walls: ${players.yellow.wallsCreated}</span><br>` +
                `<span class="yellow-stat">Yellow Speed: ${players.yellow.speed.toFixed(1)}</span><br>` +
                `<span class="yellow-stat">Yellow Win: ${probabilities[0xffff00].toFixed(1)}%</span><br>` : '') +
                (players.purple ? `<span class="purple-stat">Purple Moves: ${players.purple.moves}</span><br>` +
                `<span class="purple-stat">Purple Walls: ${players.purple.wallsCreated}</span><br>` +
                `<span class="purple-stat">Purple Speed: ${players.purple.speed.toFixed(1)}</span><br>` +
                `<span class="purple-stat">Purple Win: ${probabilities[0x800080].toFixed(1)}%</span><br>` : '') +
                `<div class="progress-bar">` +
                `<div class="progress-bar-fill red-progress" style="width: ${probabilities[0xff0000]}%"></div>` +
                `<div class="progress-bar-fill blue-progress" style="width: ${probabilities[0x0000ff]}%"></div>` +
                (players.green ? `<div class="progress-bar-fill green-progress" style="width: ${probabilities[0x00ff00]}%"></div>` : '') +
                (players.yellow ? `<div class="progress-bar-fill yellow-progress" style="width: ${probabilities[0xffff00]}%"></div>` : '') +
                (players.purple ? `<div class="progress-bar-fill purple-progress" style="width: ${probabilities[0x800080]}%"></div>` : '') +
                `</div>`;
        }

        function updateLevel() {
            if (!gameStarted || gameOver) return;
            const now = Date.now();
            if (now - lastLevelTime > 10000) {
                level++;
                Object.values(players).forEach(player => {
                    player.speed *= 1.6;
                });
                lastLevelTime = now;
                showLevelFlash();
            }
        }

        function updateCamera() {
            if (!gameStarted) return;
            let camPos, camTarget;
            if (cameraView === 'full') {
                camPos = fullViewPosition;
                camTarget = fullViewTarget;
                camera.fov = 75;
                Object.values(spotlights).forEach(s => s.visible = false);
            } else if (cameraView === 'red') {
                const pos = players.red.mesh.position.clone();
                camPos = new THREE.Vector3(pos.x, pos.y + 5, pos.z + 5);
                camTarget = pos;
                camera.fov = 75;
                Object.keys(spotlights).forEach(key => spotlights[key].visible = key === 'red');
                spotlights.red.position.copy(camPos);
                spotlights.red.target.position.copy(pos);
            } else if (cameraView === 'blue') {
                const pos = players.blue.mesh.position.clone();
                camPos = new THREE.Vector3(pos.x, pos.y + 5, pos.z + 5);
                camTarget = pos;
                camera.fov = 75;
                Object.keys(spotlights).forEach(key => spotlights[key].visible = key === 'blue');
                spotlights.blue.position.copy(camPos);
                spotlights.blue.target.position.copy(pos);
            } else if (cameraView === 'green' && players.green) {
                const pos = players.green.mesh.position.clone();
                camPos = new THREE.Vector3(pos.x, pos.y + 5, pos.z + 5);
                camTarget = pos;
                camera.fov = 75;
                Object.keys(spotlights).forEach(key => spotlights[key].visible = key === 'green');
                spotlights.green.position.copy(camPos);
                spotlights.green.target.position.copy(pos);
            } else if (cameraView === 'yellow' && players.yellow) {
                const pos = players.yellow.mesh.position.clone();
                camPos = new THREE.Vector3(pos.x, pos.y + 5, pos.z + 5);
                camTarget = pos;
                camera.fov = 75;
                Object.keys(spotlights).forEach(key => spotlights[key].visible = key === 'yellow');
                spotlights.yellow.position.copy(camPos);
                spotlights.yellow.target.position.copy(pos);
            } else if (cameraView === 'purple' && players.purple) {
                const pos = players.purple.mesh.position.clone();
                camPos = new THREE.Vector3(pos.x, pos.y + 5, pos.z + 5);
                camTarget = pos;
                camera.fov = 75;
                Object.keys(spotlights).forEach(key => spotlights[key].visible = key === 'purple');
                spotlights.purple.position.copy(camPos);
                spotlights.purple.target.position.copy(pos);
            } else if (cameraView === 'fly') {
                flyAngle += 0.01;
                const zoomFactor = 0.8 + 0.4 * Math.sin(flyAngle * 0.5);
                const radius = maxDim * 0.8 * zoomFactor;
                camPos = new THREE.Vector3(
                    gridWidth / 2 + Math.cos(flyAngle) * radius,
                    maxDim * 0.8 * zoomFactor,
                    gridHeight / 2 + Math.sin(flyAngle) * radius
                );
                camTarget = fullViewTarget;
                camera.fov = 60 - 15 * (zoomFactor - 0.8);
                Object.keys(spotlights).forEach(key => spotlights[key].visible = key === 'fly');
                spotlights.fly.position.copy(camPos);
                spotlights.fly.target.position.copy(fullViewTarget);
            }

            if (shakeTime > 0) {
                const elapsed = Date.now() - shakeTime;
                if (elapsed < shakeDuration) {
                    const t = elapsed / shakeDuration;
                    const shake = shakeAmplitude * (1 - t) * (Math.random() - 0.5);
                    camPos.x += shake;
                    camPos.y += shake;
                    camPos.z += shake;
                } else {
                    shakeTime = 0;
                }
            }

            camera.position.copy(camPos);
            camera.lookAt(camTarget);
            camera.updateProjectionMatrix();
        }

        let lastAutoplayTime = Date.now();
        function animate() {
            if (gameOver) {
                renderer.render(scene, camera);
                return;
            }
            requestAnimationFrame(animate);

            if (gameStarted) {
                if (keys['ArrowUp']) movePlayer(players.blue, 0, -1);
                if (keys['ArrowDown']) movePlayer(players.blue, 0, 1);
                if (keys['ArrowLeft']) movePlayer(players.blue, -1, 0);
                if (keys['ArrowRight']) movePlayer(players.blue, 1, 0);
                if (keys['w']) movePlayer(players.red, 0, -1);
                if (keys['s']) movePlayer(players.red, 0, 1);
                if (keys['a']) movePlayer(players.red, -1, 0);
                if (keys['d']) movePlayer(players.red, 1, 0);
                if (players.green) {
                    if (keys['i']) movePlayer(players.green, 0, -1);
                    if (keys['k']) movePlayer(players.green, 0, 1);
                    if (keys['j']) movePlayer(players.green, -1, 0);
                    if (keys['l']) movePlayer(players.green, 1, 0);
                }
                if (players.yellow) {
                    if (keys['u']) movePlayer(players.yellow, 0, -1);
                    if (keys['h']) movePlayer(players.yellow, 0, 1);
                    if (keys['y']) movePlayer(players.yellow, -1, 0);
                    if (keys['n']) movePlayer(players.yellow, 1, 0);
                }
                if (players.purple) {
                    if (keys['p']) movePlayer(players.purple, 0, -1);
                    if (keys[';']) movePlayer(players.purple, 0, 1);
                    if (keys['o']) movePlayer(players.purple, -1, 0);
                    if (keys['g']) movePlayer(players.purple, 1, 0);
                }

                const now = Date.now();
                if (now - lastAutoplayTime > 150) {
                    Object.values(players).forEach(player => autoplayMove(player));
                    lastAutoplayTime = now;
                }

                if (Object.values(players).some(player => isPlayerTrapped(player))) {
                    showGameOver();
                }

                if (checkNoMoreWalls()) {
                    showGameOver(null, 'no more walls');
                }

                const remaining = updateTimer();
                if (remaining <= 0) {
                    showGameOver(null, 'time up');
                }

                Object.values(players).forEach(player => updatePlayerPosition(player));
                updateLevel();
                updateStats();
            }

            updateCamera();
            renderer.render(scene, camera);
        }

        startCountdown();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>