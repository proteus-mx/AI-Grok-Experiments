<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tronAIx Game - V0.8</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #ui { 
            position: absolute; 
            bottom: 10px; 
            width: 100%; 
            display: flex; 
            justify-content: space-between; 
            font-family: 'Arial', sans-serif; 
            padding: 0 10px; 
            box-sizing: border-box; 
        }
        #redStats, #blueStats { 
            background: rgba(0, 0, 0, 0.7); 
            padding: 10px; 
            border-radius: 5px; 
        }
        #redStats { color: #ff0000; }
        #blueStats { color: #00b7eb; }
        #redStats div, #blueStats div { font-size: 12px; }
        #redStats div:first-child, #blueStats div:first-child { font-size: 16px; }
        #speedStats { color: #00ff00; }
        #gameOver { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            font-family: 'Arial', sans-serif; 
            font-size: 18px;
            text-align: center; 
            display: none; 
            background: rgba(0, 0, 0, 0.7); 
            padding: 20px; 
            border: 2px solid #00ff00; 
            z-index: 5; 
        }
        #gameOver div { color: #ffffff; }
        #gameOverTitle {
            font-size: 36px;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }
        #winner, #loser { color: #ffffff; }
        .scoreValue {
            font-size: 14px;
        }
        #redScoreValue { color: #ff0000; }
        #blueScoreValue { color: #00b7eb; }
        #restartButton {
            font-size: 16px;
            padding: 8px 16px;
            margin-top: 15px;
            background: #00ff00;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-shadow: 0 0 5px #000;
            transition: background 0.3s;
        }
        #restartButton:hover {
            background: #00b7eb;
        }
        #bonusMessage { 
            position: absolute; 
            top: 110px; 
            left: 50%; 
            transform: translate(-50%, 0); 
            font-family: 'Arial', sans-serif; 
            font-size: 32px; 
            color: #ffffff; 
            text-align: center; 
            display: none; 
            text-shadow: 0 0 10px #00ff00; 
        }
        #countdownDisplay { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            font-family: 'Arial', sans-serif; 
            font-size: 144px; /* Increased size */
            color: #00ff00; 
            text-align: center; 
            display: none; 
            text-shadow: 0 0 15px #00ff00; 
            background: transparent; 
            z-index: 5; 
        }
        #fadeOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            opacity: 1;
            z-index: 4;
            pointer-events: none;
            transition: opacity 4s ease-out;
        }
        #welcomeScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 255, 0, 0.2));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Arial', sans-serif;
            color: #00ff00;
            text-align: center;
            z-index: 15;
        }
        #welcomeScreen h1 {
            font-size: 64px;
            text-shadow: 0 0 15px #00ff00, 0 0 30px #00b7eb;
            z-index: 17;
            opacity: 0;
            animation: fadeIn 1s ease-in forwards;
        }
        #welcomeScreen p {
            font-size: 18px;
            max-width: 700px;
            margin: 20px 0;
            text-shadow: 0 0 10px #00ff00;
            z-index: 17;
            opacity: 0;
            animation: fadeIn 1s ease-in 0.3s forwards;
        }
        #welcomeScreen button {
            font-size: 20px;
            padding: 12px 24px;
            margin: 10px;
            background: #00ff00;
            color: #ffffff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 10px #00ff00;
            text-shadow: 0 0 5px #000;
            transition: transform 0.2s, box-shadow 0.2s;
            z-index: 17;
            opacity: 0;
            animation: fadeIn 1s ease-in 0.6s forwards;
        }
        #start1Player {
            margin-top: 20px; /* Added space above Human button */
            animation: throb 0.5s ease-in-out infinite; /* Throbbing effect */
        }
        #welcomeScreen button:hover {
            background: #00b7eb;
            box-shadow: 0 0 15px #00b7eb;
            transform: scale(1.05);
        }
        #gameModeLabel, #gridSizeLabel {
            font-size: 20px;
            margin: 10px 0;
            text-shadow: 0 0 10px #00ff00;
            z-index: 17;
            opacity: 0;
            animation: fadeIn 1s ease-in 0.9s forwards;
        }
        #gameModeLabel {
            margin-top: 20px; /* Added space above Game Mode */
        }
        #gameModeButtons {
            display: flex;
            gap: 10px;
            z-index: 17;
        }
        #gridSizeButtons {
            display: flex;
            gap: 10px;
            z-index: 17;
        }
        #gridSizeButtons button {
            font-size: 16px;
            padding: 8px 16px;
            background: #00ff00;
            color: #ffffff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            box-shadow: 0 0 8px #00ff00;
            text-shadow: 0 0 5px #000;
            transition: transform 0.2s, box-shadow 0.2s, background 0.2s;
            opacity: 0;
            animation: fadeIn 1s ease-in 1.2s forwards;
        }
        #gridSizeButtons button:hover {
            background: #00b7eb;
            box-shadow: 0 0 12px #00b7eb;
            transform: scale(1.05);
        }
        #gridSizeButtons button.selected {
            background: #00b7eb;
            box-shadow: 0 0 12px #00b7eb;
        }
        #starField {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 16;
            overflow: hidden;
        }
        .star {
            position: absolute;
            background: #fff;
            border-radius: 50%;
            opacity: 0;
            animation: twinkle 3s infinite;
        }
        @keyframes twinkle {
            0% { opacity: 0; }
            50% { opacity: 0.8; }
            100% { opacity: 0; }
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        @keyframes throb {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        .throbbing {
            animation: throb 0.5s ease-in-out infinite;
        }
        #titleBar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Arial', sans-serif;
            text-align: center;
            color: #00ff00;
        }
        #titleBar h1 {
            font-size: 36px;
            margin: 0;
            text-shadow: 0 0 10px #00ff00;
        }
        #titleBar #speedStats {
            font-size: 16px;
        }
        #cameraButton {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            padding: 8px 16px;
            background: #00ff00;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 6;
            transition: background 0.3s;
        }
        #cameraButton:hover {
            background: #00b7eb;
        }
        #gameRestartButton {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 16px;
            padding: 8px 16px;
            background: #ff0000;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 6;
            transition: background 0.3s;
        }
        #gameRestartButton:hover {
            background: #cc0000;
        }
        #welcomeScreen:not([style*="display: none"]) ~ #cameraButton,
        #welcomeScreen:not([style*="display: none"]) ~ #gameRestartButton {
            display: none;
        }
        #redPlayerBlock, #bluePlayerBlock {
            position: absolute;
            width: 50px;
            height: 50px;
            z-index: 17;
            border: 2px solid #ffffff;
            box-shadow: 0 0 10px #ffffff;
            transition: left 0.1s linear;
        }
        #redPlayerBlock {
            top: 20px;
            left: 20px;
            background: #ff0000;
            box-shadow: 0 0 15px #ff0000;
        }
        #bluePlayerBlock {
            top: 20px;
            right: 20px;
            background: #00b7eb;
            box-shadow: 0 0 15px #00b7eb;
        }
        #redPlayerBlock::after, #bluePlayerBlock::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: inherit;
            opacity: 0.5;
            z-index: -1;
            transition: opacity 0.5s;
        }
        #redPlayerBlock.moving-right::after, #bluePlayerBlock.moving-left::after {
            opacity: 0;
        }
        #miniGrid {
            position: relative;
            width: 200px;
            height: 200px;
            background: #111111;
            border: 2px solid #00ff00;
            box-shadow: 0 0 10px #00ff00;
            z-index: 17;
            margin-top: 20px;
            display: grid;
            grid-template: repeat(10, 1fr) / repeat(10, 1fr);
        }
        .miniGridCell {
            position: relative;
            border: 1px solid #00ff00;
            box-sizing: border-box;
        }
        .miniGridPlayer {
            position: absolute;
            width: 80%;
            height: 80%;
            top: 10%;
            left: 10%;
            border: 1px solid #ffffff;
            box-shadow: 0 0 5px #ffffff;
            transition: all 0.2s;
        }
        #miniRedPlayer {
            background: #ff0000;
            box-shadow: 0 0 8px #ff0000;
        }
        #miniBluePlayer {
            background: #00b7eb;
            box-shadow: 0 0 8px #00b7eb;
        }
        .miniGridTrail {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0.5;
        }
        .miniGridWall {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0.9;
        }
        @media (max-width: 600px) {
            #welcomeScreen h1 {
                font-size: 48px;
            }
            #welcomeScreen p {
                font-size: 16px;
                max-width: 90%;
            }
            #welcomeScreen button {
                font-size: 16px;
                padding: 10px 20px;
            }
            #redPlayerBlock, #bluePlayerBlock {
                width: 30px;
                height: 30px;
            }
            #miniGrid {
                width: 150px;
                height: 150px;
            }
            #gameOverTitle {
                font-size: 24px;
            }
            #gameModeLabel, #gridSizeLabel {
                font-size: 16px;
            }
            #gameModeButtons button, #gridSizeButtons button {
                font-size: 12px;
                padding: 6px 12px;
            }
        }
    </style>
</head>
<body>
    <div id="welcomeScreen">
        <div id="starField"></div>
        <div id="redPlayerBlock"></div>
        <div id="bluePlayerBlock"></div>
        <h1>tronAIx</h1>
        <p>Navigate the neon grid, outmaneuver your opponent, and claim territory by creating walls. Survive longer and cover more ground to win!</p>
        <div id="miniGrid"></div>
        <div id="gameModeLabel">Game Mode</div>
        <div id="gameModeButtons">
            <button id="start1Player">Human</button>
            <button id="startAIMode">AI</button>
        </div>
        <div id="gridSizeLabel">Grid Size</div>
        <div id="gridSizeButtons">
            <button id="gridSmall">Small</button>
            <button id="gridMedium" class="selected">Medium</button>
            <button id="gridLarge">Large</button>
            <button id="gridLudicrous">Ludicrous</button>
        </div>
    </div>
    <div id="fadeOverlay"></div>
    <div id="titleBar">
        <h1>tronAIx</h1>
        <div id="speedStats">
            Time: <span id="timer">0</span>s<br>
            Speed: <span id="speed">1</span> (Next in <span id="countdown">5</span>s)
        </div>
    </div>
    <button id="cameraButton">Cycle Camera</button>
    <button id="gameRestartButton">Restart</button>
    <div id="ui">
        <div id="redStats">
            <div>Score: <span id="redScore">0</span></div>
            <div>Distance: <span id="redDistance">0</span></div>
            <div>Grid Covered: <span id="redGrid">0</span></div>
            <div>Walls Made: <span id="redWalls">0</span></div>
        </div>
        <div id="blueStats">
            <div>Score: <span id="blueScore">0</span></div>
            <div>Distance: <span id="blueDistance">0</span></div>
            <div>Grid Covered: <span id="blueGrid">0</span></div>
            <div>Walls Made: <span id="blueWalls">0</span></div>
        </div>
    </div>
    <div id="gameOver">
        <div id="gameOverTitle">Game Over!</div>
        <div>Winner: <span id="winner"></span></div>
        <div>Loser: <span id="loser"></span> (Player Trapped)</div>
        <div>Distance Traveled: <span id="winnerDistance"></span></div>
        <div>Area Covered: <span id="winnerGrid"></span></div>
        <div>Walls Made: <span id="winnerWalls"></span></div>
        <div>Red Score: <span id="redScoreValue" class="scoreValue"></span></div>
        <div>Blue Score: <span id="blueScoreValue" class="scoreValue"></span></div>
        <button id="restartButton">Restart</button>
    </div>
    <div id="bonusMessage"></div>
    <div id="countdownDisplay"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Star field for welcome screen
        const starField = document.getElementById('starField');
        for (let i = 0; i < 200; i++) {
            const star = document.createElement('div');
            star.className = 'star';
            const size = Math.random() * 3 + 1;
            star.style.width = `${size}px`;
            star.style.height = `${size}px`;
            star.style.left = `${Math.random() * 100}%`;
            star.style.top = `${Math.random() * 100}%`;
            star.style.animationDelay = `${Math.random() * 3}s`;
            starField.appendChild(star);
        }

        // Mini grid setup
        const miniGridSize = 10;
        const miniGrid = [];
        const miniGridDiv = document.getElementById('miniGrid');
        for (let x = 0; x < miniGridSize; x++) {
            miniGrid[x] = [];
            for (let y = 0; y < miniGridSize; y++) {
                const cell = document.createElement('div');
                cell.className = 'miniGridCell';
                miniGridDiv.appendChild(cell);
                miniGrid[x][y] = { element: cell, visits: 0, owner: null, isWall: false };
            }
        }

        // Mini grid players
        const miniRedPlayer = document.createElement('div');
        miniRedPlayer.id = 'miniRedPlayer';
        miniRedPlayer.className = 'miniGridPlayer';
        miniGrid[2][2].element.appendChild(miniRedPlayer);

        const miniBluePlayer = document.createElement('div');
        miniBluePlayer.id = 'miniBluePlayer';
        miniBluePlayer.className = 'miniGridPlayer';
        miniGrid[7][7].element.appendChild(miniBluePlayer);

        const miniPlayer1 = { x: 2, y: 2, color: '#ff0000', direction: 'right', element: miniRedPlayer };
        const miniPlayer2 = { x: 7, y: 7, color: '#00b7eb', direction: 'left', element: miniBluePlayer };

        function resetMiniGrid() {
            // Clear trails and walls
            for (let x = 0; x < miniGridSize; x++) {
                for (let y = 0; y < miniGridSize; y++) {
                    const cell = miniGrid[x][y];
                    cell.visits = 0;
                    cell.owner = null;
                    cell.isWall = false;
                    const trail = cell.element.querySelector('.miniGridTrail');
                    if (trail) trail.remove();
                    const wall = cell.element.querySelector('.miniGridWall');
                    if (wall) wall.remove();
                }
            }
            // Reset player positions
            miniPlayer1.x = 2;
            miniPlayer1.y = 2;
            miniPlayer1.direction = 'right';
            miniPlayer1.element.remove();
            miniGrid[2][2].element.appendChild(miniPlayer1.element);

            miniPlayer2.x = 7;
            miniPlayer2.y = 7;
            miniPlayer2.direction = 'left';
            miniPlayer2.element.remove();
            miniGrid[7][7].element.appendChild(miniPlayer2.element);
        }

        function getMiniRandomDirection(currentDirection) {
            const directions = ['up', 'down', 'left', 'right'];
            const opposites = { 'up': 'down', 'down': 'up', 'left': 'right', 'right': 'left' };
            const validDirections = directions.filter(dir => dir !== opposites[currentDirection]);
            return validDirections[Math.floor(Math.random() * validDirections.length)];
        }

        function moveMiniPlayer(player, otherPlayer) {
            let newX = player.x;
            let newY = player.y;

            if (player.direction === 'up') newY--;
            if (player.direction === 'down') newY++;
            if (player.direction === 'left') newX--;
            if (player.direction === 'right') newX++;

            if (newX === otherPlayer.x && newY === otherPlayer.y) {
                player.direction = getMiniRandomDirection(player.direction);
                return;
            }

            if (newX >= 0 && newX < miniGridSize && newY >= 0 && newY < miniGridSize && !miniGrid[newX][newY].isWall) {
                player.element.remove();
                player.x = newX;
                player.y = newY;
                miniGrid[player.x][player.y].element.appendChild(player.element);

                const cell = miniGrid[player.x][player.y];
                cell.visits++;
                if (cell.owner !== player) {
                    if (cell.owner && cell.element.querySelector('.miniGridTrail')) {
                        cell.element.querySelector('.miniGridTrail').remove();
                    }
                    cell.owner = player;
                    const trail = document.createElement('div');
                    trail.className = 'miniGridTrail';
                    trail.style.background = player.color;
                    cell.element.appendChild(trail);
                }
                if (cell.visits >= 3) {
                    cell.isWall = true;
                    if (cell.element.querySelector('.miniGridTrail')) {
                        cell.element.querySelector('.miniGridTrail').remove();
                    }
                    const wall = document.createElement('div');
                    wall.className = 'miniGridWall';
                    wall.style.background = player.color;
                    cell.element.appendChild(wall);
                }
            } else {
                player.direction = getMiniRandomDirection(player.direction);
            }
        }

        function animateMiniGrid() {
            if (document.getElementById('welcomeScreen').style.display === 'none') return;
            if (Math.random() < 0.3) {
                miniPlayer1.direction = getMiniRandomDirection(miniPlayer1.direction);
            }
            if (Math.random() < 0.3) {
                miniPlayer2.direction = getMiniRandomDirection(miniPlayer2.direction);
            }
            moveMiniPlayer(miniPlayer1, miniPlayer2);
            moveMiniPlayer(miniPlayer2, miniPlayer1);
            setTimeout(animateMiniGrid, 200);
        }
        animateMiniGrid();

        // Red and Blue block animation
        const redBlock = document.getElementById('redPlayerBlock');
        const blueBlock = document.getElementById('bluePlayerBlock');
        let redPos = 20;
        let bluePos = window.innerWidth - 70; // 20px from right edge (50px width + 20px margin)
        let redSpeed = 2;
        let blueSpeed = -2;

        function animateBlocks() {
            if (document.getElementById('welcomeScreen').style.display === 'none') return;

            redPos += redSpeed;
            bluePos += blueSpeed;

            // Keep blocks within screen bounds
            if (redPos < 20) {
                redPos = 20;
                redSpeed = -redSpeed;
                redBlock.classList.remove('moving-right');
                redBlock.classList.add('moving-left');
            } else if (redPos > window.innerWidth - 70) {
                redPos = window.innerWidth - 70;
                redSpeed = -redSpeed;
                redBlock.classList.remove('moving-left');
                redBlock.classList.add('moving-right');
            } else {
                redBlock.classList.add(redSpeed > 0 ? 'moving-right' : 'moving-left');
            }

            if (bluePos < 20) {
                bluePos = 20;
                blueSpeed = -blueSpeed;
                blueBlock.classList.remove('moving-left');
                blueBlock.classList.add('moving-right');
            } else if (bluePos > window.innerWidth - 70) {
                bluePos = window.innerWidth - 70;
                blueSpeed = -blueSpeed;
                blueBlock.classList.remove('moving-right');
                blueBlock.classList.add('moving-left');
            } else {
                blueBlock.classList.add(blueSpeed > 0 ? 'moving-right' : 'moving-left');
            }

            // Check for collision
            const redRight = redPos + 50;
            const blueLeft = bluePos;
            if (redRight >= blueLeft && redPos <= bluePos + 50) {
                redSpeed = -redSpeed;
                blueSpeed = -blueSpeed;
                redBlock.classList.toggle('moving-right', redSpeed > 0);
                redBlock.classList.toggle('moving-left', redSpeed < 0);
                blueBlock.classList.toggle('moving-right', blueSpeed > 0);
                blueBlock.classList.toggle('moving-left', blueSpeed < 0);
            }

            redBlock.style.left = `${redPos}px`;
            blueBlock.style.right = `${window.innerWidth - bluePos - 50}px`;

            requestAnimationFrame(animateBlocks);
        }
        animateBlocks();

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Star field setup
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 1000;
        const starPositions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount * 3; i += 3) {
            starPositions[i] = (Math.random() - 0.5) * 2000; // x
            starPositions[i + 1] = (Math.random() - 0.5) * 2000; // y
            starPositions[i + 2] = (Math.random() - 0.5) * 2000; // z
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({ 
            color: 0xffffff, 
            size: 2, 
            sizeAttenuation: true 
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Lighting for neon effect
        const ambientLight = new THREE.AmbientLight(0x202020);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
        directionalLight.position.set(0, 10, 10);
        scene.add(directionalLight);

        // Grid size selection
        let gridSize = 30; // Default to Medium (30x30)
        const gridSizeButtons = document.querySelectorAll('#gridSizeButtons button');
        gridSizeButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                gridSizeButtons.forEach(btn => btn.classList.remove('selected'));
                e.target.classList.add('selected');
                if (e.target.id === 'gridSmall') gridSize = 20;
                if (e.target.id === 'gridMedium') gridSize = 30;
                if (e.target.id === 'gridLarge') gridSize = 40;
                if (e.target.id === 'gridLudicrous') gridSize = 60;
            });
        });

        // Grid setup
        let grid = [];
        function setupGrid() {
            // Clear existing grid
            grid.forEach(row => row.forEach(cell => scene.remove(cell.mesh)));
            grid = [];

            // Create new grid
            for (let x = 0; x < gridSize; x++) {
                grid[x] = [];
                for (let z = 0; z < gridSize; z++) {
                    const geometry = new THREE.PlaneGeometry(1, 1);
                    const material = new THREE.MeshStandardMaterial({ 
                        color: 0x111111, 
                        side: THREE.DoubleSide, 
                        transparent: true, 
                        opacity: 0, // Start invisible
                        emissive: 0x111111,
                        emissiveIntensity: 0.5
                    });
                    const plane = new THREE.Mesh(geometry, material);
                    plane.position.set(x - gridSize / 2, 0, z - gridSize / 2);
                    plane.rotation.x = Math.PI / 2;
                    scene.add(plane);
                    grid[x][z] = { mesh: plane, color: 0x111111, visits: 0, owner: null, isWall: false };
                }
            }

            // Update grid lines
            scene.remove(gridLines);
            const gridLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ff00, 
                emissive: 0x00ff00, 
                emissiveIntensity: 1, 
                transparent: true, 
                opacity: 0, // Start invisible
                linewidth: 2
            });
            gridLines = new THREE.Group();
            for (let i = 0; i <= gridSize; i++) {
                const pointsH = [
                    new THREE.Vector3(i - gridSize / 2, 0.01, -gridSize / 2),
                    new THREE.Vector3(i - gridSize / 2, 0.01, gridSize / 2)
                ];
                const pointsV = [
                    new THREE.Vector3(-gridSize / 2, 0.01, i - gridSize / 2),
                    new THREE.Vector3(gridSize / 2, 0.01, i - gridSize / 2)
                ];
                const geometryH = new THREE.BufferGeometry().setFromPoints(pointsH);
                const geometryV = new THREE.BufferGeometry().setFromPoints(pointsV);
                const lineH = new THREE.Line(geometryH, gridLineMaterial);
                const lineV = new THREE.Line(geometryV, gridLineMaterial);
                gridLines.add(lineH, lineV);
            }
            scene.add(gridLines);
        }
        let gridLines = new THREE.Group();
        setupGrid();

        // Players setup
        const player1 = { 
            x: Math.floor(gridSize / 4), 
            z: Math.floor(gridSize / 4), 
            color: 0xff0000, 
            direction: 'right', 
            distance: 0, 
            lastPos: { x: Math.floor(gridSize / 4), z: Math.floor(gridSize / 4) }, 
            gridCovered: 0, 
            wallsMade: 0, 
            score: 0,
            lastMoveTime: performance.now(),
            isThrobbing: false
        };
        const player2 = { 
            x: Math.floor(3 * gridSize / 4), 
            z: Math.floor(3 * gridSize / 4), 
            color: 0x00b7eb, 
            direction: 'left', 
            distance: 0, 
            lastPos: { x: Math.floor(3 * gridSize / 4), z: Math.floor(3 * gridSize / 4) }, 
            gridCovered: 0, 
            wallsMade: 0, 
            score: 0,
            lastMoveTime: performance.now(),
            isThrobbing: false
        };

        const player1Geometry = new THREE.BoxGeometry(0.8, 0.2, 0.8);
        const player1Material = new THREE.MeshStandardMaterial({ 
            color: player1.color, 
            emissive: player1.color, 
            emissiveIntensity: 0.8, 
            metalness: 0.2, 
            roughness: 0.8,
            transparent: true,
            opacity: 0 // Start invisible
        });
        const player1Mesh = new THREE.Mesh(player1Geometry, player1Material);
        player1Mesh.position.set(player1.x - gridSize / 2, 0.1, player1.z - gridSize / 2);
        scene.add(player1Mesh);

        const player1BorderGeometry = new THREE.EdgesGeometry(player1Geometry);
        const player1BorderMaterial = new THREE.LineBasicMaterial({ 
            color: 0xffffff, 
            emissive: 0xffffff, 
            emissiveIntensity: 1,
            transparent: true,
            opacity: 0 // Start invisible
        });
        const player1Border = new THREE.LineSegments(player1BorderGeometry, player1BorderMaterial);
        player1Mesh.add(player1Border);

        const player2Geometry = new THREE.BoxGeometry(0.8, 0.2, 0.8);
        const player2Material = new THREE.MeshStandardMaterial({ 
            color: player2.color, 
            emissive: player2.color, 
            emissiveIntensity: 0.8, 
            metalness: 0.2, 
            roughness: 0.8,
            transparent: true,
            opacity: 0 // Start invisible
        });
        const player2Mesh = new THREE.Mesh(player2Geometry, player2Material);
        player2Mesh.position.set(player2.x - gridSize / 2, 0.1, player2.z - gridSize / 2);
        scene.add(player2Mesh);

        const player2BorderGeometry = new THREE.EdgesGeometry(player2Geometry);
        const player2BorderMaterial = new THREE.LineBasicMaterial({ 
            color: 0xffffff, 
            emissive: 0xffffff, 
            emissiveIntensity: 1,
            transparent: true,
            opacity: 0 // Start invisible
        });
        const player2Border = new THREE.LineSegments(player2BorderGeometry, player2BorderMaterial);
        player2Mesh.add(player2Border);

        // Camera position and modes
        let cameraMode = 'grid';
        const cameraModes = ['grid', 'followPlayer1', 'followPlayer2', 'birdsEye', 'flyAround'];
        let flyAngle = 0;

        function updateCamera() {
            const gridViewPos = new THREE.Vector3(0, gridSize * 0.75, gridSize * 0.5);
            const gridViewTarget = new THREE.Vector3(0, 0, 0);
            const birdsEyePos = new THREE.Vector3(0, gridSize * 1.25, 0);
            const birdsEyeTarget = new THREE.Vector3(0, 0, 0);

            if (cameraMode === 'grid') {
                camera.position.copy(gridViewPos);
                camera.lookAt(gridViewTarget);
            } else if (cameraMode === 'followPlayer1') {
                camera.position.set(
                    player1Mesh.position.x - gridSize * 0.1,
                    player1Mesh.position.y + gridSize * 0.05,
                    player1Mesh.position.z + gridSize * 0.1
                );
                camera.lookAt(player1Mesh.position);
            } else if (cameraMode === 'followPlayer2') {
                camera.position.set(
                    player2Mesh.position.x - gridSize * 0.1,
                    player2Mesh.position.y + gridSize * 0.05,
                    player2Mesh.position.z + gridSize * 0.1
                );
                camera.lookAt(player2Mesh.position);
            } else if (cameraMode === 'birdsEye') {
                camera.position.copy(birdsEyePos);
                camera.lookAt(birdsEyeTarget);
            } else if (cameraMode === 'flyAround') {
                flyAngle += 0.01; // Adjust speed of rotation
                const radius = gridSize * 0.75;
                const height = gridSize * 0.5 + Math.sin(flyAngle * 0.5) * (gridSize * 0.125); // Scaled oscillation
                camera.position.set(
                    Math.cos(flyAngle) * radius,
                    height,
                    Math.sin(flyAngle) * radius
                );
                camera.lookAt(gridViewTarget);
            }
        }

        // Game mode
        let is1PlayerMode = false;

        // Handle input for red player direction in 1 Player Mode
        function handleInput(event) {
            if (document.getElementById('welcomeScreen').style.display !== 'none' || !is1PlayerMode) return;

            // Prevent interaction with UI elements
            if (event.target.tagName === 'BUTTON' || event.target.closest('#ui')) return;

            const clientX = event.type === 'click' ? event.clientX : event.touches[0].clientX;
            const clientY = event.type === 'click' ? event.clientY : event.touches[0].clientY;
            const screenCenterX = window.innerWidth / 2;
            const screenCenterY = window.innerHeight / 2;
            const deltaX = clientX - screenCenterX;
            const deltaY = clientY - screenCenterY;

            // Determine direction based on input position
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                player1.direction = deltaX > 0 ? 'right' : 'left';
            } else {
                player1.direction = deltaY > 0 ? 'down' : 'up';
            }
        }

        // Camera toggle and speed boost
        let lastTap = 0;
        document.addEventListener('touchstart', (e) => {
            if (document.getElementById('welcomeScreen').style.display !== 'none') return;
            const now = performance.now();
            if (now - lastTap < 300) {
                updateInterval = baseUpdateInterval / (speedMultiplier * 2);
                setTimeout(() => { updateInterval = baseUpdateInterval / speedMultiplier; }, 5000);
            } else if (!is1PlayerMode) {
                const currentIndex = cameraModes.indexOf(cameraMode);
                cameraMode = cameraModes[(currentIndex + 1) % cameraModes.length];
                updateCamera();
            }
            handleInput(e);
            lastTap = now;
        });

        document.addEventListener('click', (e) => {
            if (document.getElementById('welcomeScreen').style.display !== 'none') return;
            handleInput(e);
        });

        // Camera cycle button
        document.getElementById('cameraButton').addEventListener('click', () => {
            const currentIndex = cameraModes.indexOf(cameraMode);
            cameraMode = cameraModes[(currentIndex + 1) % cameraModes.length];
            console.log('Camera mode changed to:', cameraMode); // Debug log
            updateCamera();
        });

        // Initial camera position
        updateCamera();

        // Random direction change
        function getRandomDirection(currentDirection) {
            const directions = ['up', 'down', 'left', 'right'];
            const opposites = { 'up': 'down', 'down': 'up', 'left': 'right', 'right': 'left' };
            const validDirections = directions.filter(dir => dir !== opposites[currentDirection]);
            return validDirections[Math.floor(Math.random() * validDirections.length)];
        }

        // Check if player is trapped
        function isTrapped(player) {
            const directions = [
                { dir: 'up', x: player.x, z: player.z - 1 },
                { dir: 'down', x: player.x, z: player.z + 1 },
                { dir: 'left', x: player.x - 1, z: player.z },
                { dir: 'right', x: player.x + 1, z: player.z }
            ];
            return directions.every(({ x, z }) => 
                x < 0 || x >= gridSize || z < 0 || z >= gridSize || grid[x][z].isWall
            );
        }

        // Check for adjacent walls
        function hasAdjacentWall(x, z) {
            const neighbors = [
                { x: x, z: z - 1 },
                { x: x, z: z + 1 },
                { x: x - 1, z: z },
                { x: x + 1, z: z }
            ];
            return neighbors.some(({ x, z }) => 
                x >= 0 && x < gridSize && z >= 0 && z < gridSize && grid[x][z].isWall
            );
        }

        // Display bonus message
        function showBonusMessage(message, color) {
            const bonusDiv = document.getElementById('bonusMessage');
            bonusDiv.textContent = message;
            bonusDiv.style.color = color;
            bonusDiv.style.display = 'block';
            setTimeout(() => { bonusDiv.style.display = 'none'; }, 1000);
        }

        // Reset game state
        function resetGame() {
            // Reset player positions and stats
            player1.x = Math.floor(gridSize / 4);
            player1.z = Math.floor(gridSize / 4);
            player1.direction = 'right';
            player1.distance = 0;
            player1.lastPos = { x: Math.floor(gridSize / 4), z: Math.floor(gridSize / 4) };
            player1.gridCovered = 0;
            player1.wallsMade = 0;
            player1.score = 0;
            player1.lastMoveTime = performance.now();
            player1.isThrobbing = false;
            player1Mesh.position.set(player1.x - gridSize / 2, 0.1, player1.z - gridSize / 2);
            player1Mesh.className = '';

            player2.x = Math.floor(3 * gridSize / 4);
            player2.z = Math.floor(3 * gridSize / 4);
            player2.direction = 'left';
            player2.distance = 0;
            player2.lastPos = { x: Math.floor(3 * gridSize / 4), z: Math.floor(3 * gridSize / 4) };
            player2.gridCovered = 0;
            player2.wallsMade = 0;
            player2.score = 0;
            player2.lastMoveTime = performance.now();
            player2.isThrobbing = false;
            player2Mesh.position.set(player2.x - gridSize / 2, 0.1, player2.z - gridSize / 2);
            player2Mesh.className = '';

            // Reset grid
            setupGrid();
            grid.forEach(row => row.forEach(cell => {
                cell.mesh.material.color.setHex(0x111111);
                cell.mesh.material.opacity = 0;
                cell.mesh.material.emissive.setHex(0x111111);
                cell.mesh.position.y = 0;
                cell.color = 0x111111;
                cell.visits = 0;
                cell.owner = null;
                cell.isWall = false;
            }));

            // Reset grid lines and players opacity
            gridLines.children.forEach(line => {
                line.material.opacity = 0;
            });
            player1Mesh.material.opacity = 0;
            player1Border.material.opacity = 0;
            player2Mesh.material.opacity = 0;
            player2Border.material.opacity = 0;

            // Reset mini grid
            resetMiniGrid();

            // Reset game state
            gameOver = false;
            gameStarted = false;
            speedMultiplier = 1;
            updateInterval = baseUpdateInterval;
            lastSpeedIncrease = performance.now();

            // Hide game over and show welcome screen
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('welcomeScreen').style.display = 'flex';
            document.getElementById('fadeOverlay').style.display = 'block';
            document.getElementById('fadeOverlay').style.opacity = '1';
        }

        // End game
        let gameOver = false;
        function endGame(winner, loser) {
            gameOver = true;
            cameraMode = 'flyAround'; // Switch to flyAround camera
            const gameOverDiv = document.getElementById('gameOver');
            gameOverDiv.style.display = 'block';
            document.getElementById('winner').textContent = winner === player1 ? 'Red' : 'Blue';
            document.getElementById('winner').style.color = winner === player1 ? '#ff0000' : '#00b7eb';
            document.getElementById('loser').textContent = loser === player1 ? 'Red' : 'Blue';
            document.getElementById('loser').style.color = loser === player1 ? '#ff0000' : '#00b7eb';
            document.getElementById('winnerDistance').textContent = winner.distance;
            document.getElementById('winnerGrid').textContent = winner.gridCovered;
            document.getElementById('winnerWalls').textContent = winner.wallsMade;
            document.getElementById('redScoreValue').textContent = player1.score;
            document.getElementById('blueScoreValue').textContent = player2.score;
        }

        // Restart button handler for game over
        document.getElementById('restartButton').addEventListener('click', (e) => {
            e.stopPropagation();
            resetGame();
        });

        // In-game restart button handler
        document.getElementById('gameRestartButton').addEventListener('click', (e) => {
            e.stopPropagation();
            // End game with no winner/loser (manual restart)
            gameOver = true;
            cameraMode = 'flyAround'; // Switch to flyAround camera
            const gameOverDiv = document.getElementById('gameOver');
            gameOverDiv.style.display = 'block';
            document.getElementById('winner').textContent = 'None';
            document.getElementById('winner').style.color = '#ffffff';
            document.getElementById('loser').textContent = 'None';
            document.getElementById('loser').style.color = '#ffffff';
            document.getElementById('winnerDistance').textContent = 'N/A';
            document.getElementById('winnerGrid').textContent = 'N/A';
            document.getElementById('winnerWalls').textContent = 'N/A';
            document.getElementById('redScoreValue').textContent = player1.score;
            document.getElementById('blueScoreValue').textContent = player2.score;
        });

        // Speed control
        let baseUpdateInterval = 100;
        let updateInterval = baseUpdateInterval;
        let speedMultiplier = 1;
        let lastSpeedIncrease = performance.now();

        // Timer and UI
        let startTime = performance.now();
        function updateUI() {
            const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
            const timeToNextIncrease = (5 - ((performance.now() - lastSpeedIncrease) / 1000)).toFixed(1);
            document.getElementById('timer').textContent = elapsed;
            document.getElementById('redScore').textContent = player1.score;
            document.getElementById('redDistance').textContent = player1.distance;
            document.getElementById('redGrid').textContent = player1.gridCovered;
            document.getElementById('redWalls').textContent = player1.wallsMade;
            document.getElementById('blueScore').textContent = player2.score;
            document.getElementById('blueDistance').textContent = player2.distance;
            document.getElementById('blueGrid').textContent = player2.gridCovered;
            document.getElementById('blueWalls').textContent = player2.wallsMade;
            document.getElementById('speed').textContent = speedMultiplier.toFixed(1);
            document.getElementById('countdown').textContent = timeToNextIncrease > 0 ? timeToNextIncrease : 0;
        }

        // Fade-in grid
        function fadeInGrid(duration) {
            const startTime = performance.now();
            function animateFade() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const gridOpacity = progress * 0.5; // Target opacity for grid
                const lineOpacity = progress * 0.5; // Target opacity for lines
                const playerOpacity = progress; // Target opacity for players

                // Update grid opacity
                for (let x = 0; x < gridSize; x++) {
                    for (let z = 0; z < gridSize; z++) {
                        grid[x][z].mesh.material.opacity = gridOpacity;
                    }
                }

                // Update grid lines opacity
                gridLines.children.forEach(line => {
                    line.material.opacity = lineOpacity;
                });

                // Update player opacity
                player1Mesh.material.opacity = playerOpacity;
                player1Border.material.opacity = playerOpacity;
                player2Mesh.material.opacity = playerOpacity;
                player2Border.material.opacity = playerOpacity;

                if (progress < 1) {
                    requestAnimationFrame(animateFade);
                }
            }
            requestAnimationFrame(animateFade);
        }

        // Render loop for countdown
        function renderDuringCountdown() {
            if (document.getElementById('countdownDisplay').style.display === 'block') {
                updateCamera();
                renderer.render(scene, camera);
                requestAnimationFrame(renderDuringCountdown);
            }
        }

        // Render loop for game over
        function renderGameOver() {
            if (document.getElementById('gameOver').style.display === 'block') {
                updateCamera();
                renderer.render(scene, camera);
                requestAnimationFrame(renderGameOver);
            }
        }

        // Countdown setup
        let gameStarted = false;
        function startCountdown() {
            const countdownDiv = document.getElementById('countdownDisplay');
            const fadeOverlay = document.getElementById('fadeOverlay');
            countdownDiv.style.display = 'block';
            fadeOverlay.style.opacity = '1'; // Ensure overlay is visible
            let countdown = 3;
            countdownDiv.textContent = countdown;

            // Start fading in grid and fading out overlay
            fadeInGrid(4000); // 4-second fade-in
            setTimeout(() => {
                fadeOverlay.style.opacity = '0';
            }, 0);

            // Start rendering the scene
            renderDuringCountdown();

            const countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownDiv.textContent = countdown;
                } else {
                    countdownDiv.textContent = 'Go!';
                    setTimeout(() => {
                        countdownDiv.style.display = 'none';
                        fadeOverlay.style.display = 'none'; // Remove overlay after countdown
                        gameStarted = true;
                        startTime = performance.now();
                        animate();
                    }, 1000);
                    clearInterval(countdownInterval);
                }
            }, 1000);
        }

        // Game loop
        let lastUpdate = performance.now();
        function animate() {
            if (!gameStarted || gameOver) {
                if (gameOver) renderGameOver(); // Continue rendering for game over
                return;
            }
            requestAnimationFrame(animate);
            const now = performance.now();

            if (now - lastSpeedIncrease >= 5000) {
                speedMultiplier += 0.5;
                updateInterval = baseUpdateInterval / speedMultiplier;
                lastSpeedIncrease = now;
            }

            if (now - lastUpdate >= updateInterval) {
                // Update directions for both players in AI Mode (random)
                if (!is1PlayerMode) {
                    if (Math.random() < 0.3) {
                        player1.direction = getRandomDirection(player1.direction);
                    }
                }
                if (Math.random() < 0.3) {
                    player2.direction = getRandomDirection(player2.direction);
                }

                function movePlayer(player, mesh, otherPlayer) {
                    let newX = player.x;
                    let newZ = player.z;

                    if (player.direction === 'up') newZ--;
                    if (player.direction === 'down') newZ++;
                    if (player.direction === 'left') newX--;
                    if (player.direction === 'right') newX++;

                    if (newX === otherPlayer.x && newZ === otherPlayer.z) {
                        if (!is1PlayerMode || player !== player1) {
                            player.direction = getRandomDirection(player.direction);
                        }
                        return;
                    }

                    if (newX >= 0 && newX < gridSize && newZ >= 0 && newZ < gridSize && !grid[newX][newZ].isWall) {
                        player.x = newX;
                        player.z = newZ;

                        if (player.x !== player.lastPos.x || player.z !== player.lastPos.z) {
                            player.distance++;
                            player.score += 1;
                            player.lastPos = { x: player.x, z: player.z };
                            player.lastMoveTime = now; // Update move time
                            player.isThrobbing = false;
                            mesh.className = ''; // Remove throbbing
                        }

                        const cell = grid[player.x][player.z];
                        cell.visits++;
                        if (cell.owner !== player) {
                            if (cell.owner === player1) player1.gridCovered--;
                            if (cell.owner === player2) player2.gridCovered--;
                            cell.owner = player;
                            player.gridCovered++;
                        }
                        if (cell.visits >= 5) {
                            cell.isWall = true;
                            cell.mesh.position.y = 0.02;
                            cell.mesh.material.opacity = 0.9;
                            cell.mesh.material.emissive.setHex(player.color);
                            cell.mesh.material.emissiveIntensity = 0.8;
                            player.wallsMade++;
                            player.score += 10;
                            showBonusMessage('+10 Wall Bonus!', player === player1 ? '#ff0000' : '#00b7eb');
                            if (hasAdjacentWall(player.x, player.z)) {
                                player.score += 50;
                                showBonusMessage('+50 Adjacent Wall Bonus!', player === player1 ? '#ff0000' : '#00b7eb');
                            }
                        }
                        const intensity = Math.min(cell.visits * 0.4, 1);
                        const r = Math.floor((player.color >> 16) * intensity);
                        const g = Math.floor(((player.color >> 8) & 0xff) * intensity);
                        const b = Math.floor((player.color & 0xff) * intensity);
                        const newColor = (r << 16) | (g << 8) | b;
                        cell.mesh.material.color.setHex(newColor);
                        cell.mesh.material.opacity = cell.isWall ? 0.9 : 0.5 + intensity * 0.4;
                        cell.color = newColor;

                        const targetPos = new THREE.Vector3(player.x - gridSize / 2, 0.1, player.z - gridSize / 2);
                        mesh.position.lerp(targetPos, 0.9);
                    } else {
                        // Only change direction on collision if not in 1 Player Mode for player1
                        if (!is1PlayerMode || player !== player1) {
                            player.direction = getRandomDirection(player.direction);
                        }
                    }

                    // Check for throbbing
                    if (now - player.lastMoveTime >= 2000 && !player.isThrobbing) {
                        player.isThrobbing = true;
                        mesh.className = 'throbbing';
                    }

                    if (isTrapped(player)) {
                        endGame(otherPlayer, player);
                    }
                }

                movePlayer(player1, player1Mesh, player2);
                movePlayer(player2, player2Mesh, player1);

                lastUpdate = now;
            }

            updateCamera();
            updateUI();
            renderer.render(scene, camera);
        }

        // Welcome screen button handlers
        document.getElementById('start1Player').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('welcomeScreen').style.display = 'none';
            is1PlayerMode = true;
            setupGrid(); // Ensure grid is set up with selected size
            startCountdown();
        });

        document.getElementById('startAIMode').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('welcomeScreen').style.display = 'none';
            is1PlayerMode = false;
            setupGrid(); // Ensure grid is set up with selected size
            startCountdown();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Adjust blue block position on resize
            bluePos = Math.min(bluePos, window.innerWidth - 70);
            blueBlock.style.right = `${window.innerWidth - bluePos - 50}px`;
        });
    </script>
</body>
</html>
