<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tronAIx Game - V0.3</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #ui { 
            position: absolute; 
            bottom: 10px; 
            width: 100%; 
            display: flex; 
            justify-content: space-between; 
            font-family: 'Arial', sans-serif; 
            padding: 0 10px; 
            box-sizing: border-box; 
        }
        #redStats, #blueStats { 
            background: rgba(0, 0, 0, 0.7); 
            padding: 10px; 
            border-radius: 5px; 
        }
        #redStats { color: #ff0000; }
        #blueStats { color: #00b7eb; }
        #redStats div, #blueStats div { font-size: 12px; }
        #redStats div:first-child, #blueStats div:first-child { font-size: 16px; }
        #speedStats { color: #00ff00; }
        #gameOver { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            font-family: 'Arial', sans-serif; 
            font-size: 18px;
            text-align: center; 
            display: none; 
            background: rgba(0, 0, 0, 0.7); 
            padding: 20px; 
            border: 2px solid #00ff00; 
            z-index: 5; 
        }
        #gameOver div { color: #ffffff; }
        #winner, #loser { color: #ffffff; }
        #restartButton {
            font-size: 16px;
            padding: 8px 16px;
            margin-top: 15px;
            background: #00ff00;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-shadow: 0 0 5px #000;
            transition: background 0.3s;
        }
        #restartButton:hover {
            background: #00b7eb;
        }
        #bonusMessage { 
            position: absolute; 
            top: 110px; 
            left: 50%; 
            transform: translate(-50%, 0); 
            font-family: 'Arial', sans-serif; 
            font-size: 32px; 
            color: #ffffff; 
            text-align: center; 
            display: none; 
            text-shadow: 0 0 10px #00ff00; 
        }
        #countdownDisplay { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            font-family: 'Arial', sans-serif; 
            font-size: 96px; 
            color: #00ff00; 
            text-align: center; 
            display: none; 
            text-shadow: 0 0 15px #00ff00; 
            background: transparent; 
            z-index: 5; 
        }
        #fadeOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            opacity: 1;
            z-index: 4;
            pointer-events: none;
            transition: opacity 4s ease-out;
        }
        #welcomeScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 255, 0, 0.2));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Arial', sans-serif;
            color: #00ff00;
            text-align: center;
            z-index: 10;
        }
        #welcomeScreen h1 {
            font-size: 64px;
            text-shadow: 0 0 15px #00ff00, 0 0 30px #00b7eb;
            z-index: 12;
            opacity: 0;
            animation: fadeIn 1s ease-in forwards;
        }
        #welcomeScreen p {
            font-size: 24px;
            max-width: 700px;
            margin: 20px 0;
            text-shadow: 0 0 10px #00ff00;
            z-index: 12;
            opacity: 0;
            animation: fadeIn 1s ease-in 0.3s forwards;
        }
        #welcomeScreen button {
            font-size: 20px;
            padding: 12px 24px;
            margin: 10px;
            background: #00ff00;
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 10px #00ff00;
            text-shadow: 0 0 5px #000;
            transition: transform 0.2s, box-shadow 0.2s;
            z-index: 12;
            opacity: 0;
            animation: fadeIn 1s ease-in 0.6s forwards;
        }
        #welcomeScreen button:hover {
            background: #00b7eb;
            box-shadow: 0 0 15px #00b7eb;
            transform: scale(1.05);
        }
        #starField {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 11;
            overflow: hidden;
        }
        .star {
            position: absolute;
            background: #fff;
            border-radius: 50%;
            opacity: 0;
            animation: twinkle 3s infinite;
        }
        @keyframes twinkle {
            0% { opacity: 0; }
            50% { opacity: 0.8; }
            100% { opacity: 0; }
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        #titleBar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Arial', sans-serif;
            text-align: center;
            color: #00ff00;
        }
        #titleBar h1 {
            font-size: 36px;
            margin: 0;
            text-shadow: 0 0 10px #00ff00;
        }
        #titleBar #speedStats {
            font-size: 16px;
        }
        #cameraButton {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            padding: 8px 16px;
            background: #00ff00;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 6;
            transition: background 0.3s;
        }
        #cameraButton:hover {
            background: #00b7eb;
        }
        #gameRestartButton {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 16px;
            padding: 8px 16px;
            background: #ff0000;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 6;
            transition: background 0.3s;
        }
        #gameRestartButton:hover {
            background: #cc0000;
        }
        @media (max-width: 600px) {
            #welcomeScreen h1 {
                font-size: 48px;
            }
            #welcomeScreen p {
                font-size: 18px;
                max-width: 90%;
            }
            #welcomeScreen button {
                font-size: 16px;
                padding: 10px 20px;
            }
        }
    </style>
</head>
<body>
    <div id="welcomeScreen">
        <div id="starField"></div>
        <h1>tronAIx</h1>
        <p>Navigate the neon grid, outmaneuver your opponent, and claim territory by creating walls. Survive longer and cover more ground to win!</p>
        <button id="start1Player">Start 1 Player</button>
        <button id="startAIMode">AI Mode</button>
    </div>
    <div id="fadeOverlay"></div>
    <div id="titleBar">
        <h1>tronAIx</h1>
        <div id="speedStats">
            Time: <span id="timer">0</span>s<br>
            Speed: <span id="speed">1</span> (Next in <span id="countdown">5</span>s)
        </div>
    </div>
    <button id="cameraButton">Cycle Camera</button>
    <button id="gameRestartButton">Restart</button>
    <div id="ui">
        <div id="redStats">
            <div>Score: <span id="redScore">0</span></div>
            <div>Distance: <span id="redDistance">0</span></div>
            <div>Grid Covered: <span id="redGrid">0</span></div>
            <div>Walls Made: <span id="redWalls">0</span></div>
        </div>
        <div id="blueStats">
            <div>Score: <span id="blueScore">0</span></div>
            <div>Distance: <span id="blueDistance">0</span></div>
            <div>Grid Covered: <span id="blueGrid">0</span></div>
            <div>Walls Made: <span id="blueWalls">0</span></div>
        </div>
    </div>
    <div id="gameOver">
        <div>Game Over!</div>
        <div>Winner: <span id="winner"></span></div>
        <div>Loser: <span id="loser"></span> (Player Trapped)</div>
        <div>Distance Traveled: <span id="winnerDistance"></span></div>
        <div>Area Covered: <span id="winnerGrid"></span></div>
        <div>Walls Made: <span id="winnerWalls"></span></div>
        <button id="restartButton">Restart</button>
    </div>
    <div id="bonusMessage"></div>
    <div id="countdownDisplay"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Star field for welcome screen
        const starField = document.getElementById('starField');
        for (let i = 0; i < 200; i++) {
            const star = document.createElement('div');
            star.className = 'star';
            const size = Math.random() * 3 + 1;
            star.style.width = `${size}px`;
            star.style.height = `${size}px`;
            star.style.left = `${Math.random() * 100}%`;
            star.style.top = `${Math.random() * 100}%`;
            star.style.animationDelay = `${Math.random() * 3}s`;
            starField.appendChild(star);
        }

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Star field setup
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 1000;
        const starPositions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount * 3; i += 3) {
            starPositions[i] = (Math.random() - 0.5) * 2000; // x
            starPositions[i + 1] = (Math.random() - 0.5) * 2000; // y
            starPositions[i + 2] = (Math.random() - 0.5) * 2000; // z
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({ 
            color: 0xffffff, 
            size: 2, 
            sizeAttenuation: true 
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Lighting for neon effect
        const ambientLight = new THREE.AmbientLight(0x202020);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
        directionalLight.position.set(0, 10, 10);
        scene.add(directionalLight);

        // Grid setup (40x40)
        const gridSize = 40;
        const grid = [];
        for (let x = 0; x < gridSize; x++) {
            grid[x] = [];
            for (let z = 0; z < gridSize; z++) {
                const geometry = new THREE.PlaneGeometry(1, 1);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0x111111, 
                    side: THREE.DoubleSide, 
                    transparent: true, 
                    opacity: 0, // Start invisible
                    emissive: 0x111111,
                    emissiveIntensity: 0.5
                });
                const plane = new THREE.Mesh(geometry, material);
                plane.position.set(x - gridSize / 2, 0, z - gridSize / 2);
                plane.rotation.x = Math.PI / 2;
                scene.add(plane);
                grid[x][z] = { mesh: plane, color: 0x111111, visits: 0, owner: null, isWall: false };
            }
        }

        // Neon green grid lines with antialiasing
        const gridLineMaterial = new THREE.LineBasicMaterial({ 
            color: 0x00ff00, 
            emissive: 0x00ff00, 
            emissiveIntensity: 1, 
            transparent: true, 
            opacity: 0, // Start invisible
            linewidth: 2
        });
        const gridLines = new THREE.Group();
        for (let i = 0; i <= gridSize; i++) {
            const pointsH = [
                new THREE.Vector3(i - gridSize / 2, 0.01, -gridSize / 2),
                new THREE.Vector3(i - gridSize / 2, 0.01, gridSize / 2)
            ];
            const pointsV = [
                new THREE.Vector3(-gridSize / 2, 0.01, i - gridSize / 2),
                new THREE.Vector3(gridSize / 2, 0.01, i - gridSize / 2)
            ];
            const geometryH = new THREE.BufferGeometry().setFromPoints(pointsH);
            const geometryV = new THREE.BufferGeometry().setFromPoints(pointsV);
            const lineH = new THREE.Line(geometryH, gridLineMaterial);
            const lineV = new THREE.Line(geometryV, gridLineMaterial);
            gridLines.add(lineH, lineV);
        }
        scene.add(gridLines);

        // Players setup
        const player1 = { x: 10, z: 10, color: 0xff0000, direction: 'right', distance: 0, lastPos: { x: 10, z: 10 }, gridCovered: 0, wallsMade: 0, score: 0 };
        const player2 = { x: 30, z: 30, color: 0x00b7eb, direction: 'left', distance: 0, lastPos: { x: 30, z: 30 }, gridCovered: 0, wallsMade: 0, score: 0 };

        const player1Geometry = new THREE.BoxGeometry(0.8, 0.2, 0.8);
        const player1Material = new THREE.MeshStandardMaterial({ 
            color: player1.color, 
            emissive: player1.color, 
            emissiveIntensity: 0.8, 
            metalness: 0.2, 
            roughness: 0.8,
            transparent: true,
            opacity: 0 // Start invisible
        });
        const player1Mesh = new THREE.Mesh(player1Geometry, player1Material);
        player1Mesh.position.set(player1.x - gridSize / 2, 0.1, player1.z - gridSize / 2);
        scene.add(player1Mesh);

        const player1BorderGeometry = new THREE.EdgesGeometry(player1Geometry);
        const player1BorderMaterial = new THREE.LineBasicMaterial({ 
            color: 0xffffff, 
            emissive: 0xffffff, 
            emissiveIntensity: 1,
            transparent: true,
            opacity: 0 // Start invisible
        });
        const player1Border = new THREE.LineSegments(player1BorderGeometry, player1BorderMaterial);
        player1Mesh.add(player1Border);

        const player2Geometry = new THREE.BoxGeometry(0.8, 0.2, 0.8);
        const player2Material = new THREE.MeshStandardMaterial({ 
            color: player2.color, 
            emissive: player2.color, 
            emissiveIntensity: 0.8, 
            metalness: 0.2, 
            roughness: 0.8,
            transparent: true,
            opacity: 0 // Start invisible
        });
        const player2Mesh = new THREE.Mesh(player2Geometry, player2Material);
        player2Mesh.position.set(player2.x - gridSize / 2, 0.1, player2.z - gridSize / 2);
        scene.add(player2Mesh);

        const player2BorderGeometry = new THREE.EdgesGeometry(player2Geometry);
        const player2BorderMaterial = new THREE.LineBasicMaterial({ 
            color: 0xffffff, 
            emissive: 0xffffff, 
            emissiveIntensity: 1,
            transparent: true,
            opacity: 0 // Start invisible
        });
        const player2Border = new THREE.LineSegments(player2BorderGeometry, player2BorderMaterial);
        player2Mesh.add(player2Border);

        // Camera position and modes
        let cameraMode = 'grid';
        const cameraModes = ['grid', 'followPlayer1', 'followPlayer2', 'birdsEye', 'flyAround'];
        const gridViewPos = new THREE.Vector3(0, 30, 20);
        const gridViewTarget = new THREE.Vector3(0, 0, 0);
        const birdsEyePos = new THREE.Vector3(0, 50, 0);
        const birdsEyeTarget = new THREE.Vector3(0, 0, 0);
        let flyAngle = 0;

        function updateCamera() {
            if (cameraMode === 'grid') {
                camera.position.copy(gridViewPos);
                camera.lookAt(gridViewTarget);
            } else if (cameraMode === 'followPlayer1') {
                camera.position.set(
                    player1Mesh.position.x - 5,
                    player1Mesh.position.y + 3,
                    player1Mesh.position.z + 5
                );
                camera.lookAt(player1Mesh.position);
            } else if (cameraMode === 'followPlayer2') {
                camera.position.set(
                    player2Mesh.position.x - 5,
                    player1Mesh.position.y + 3,
                    player2Mesh.position.z + 5
                );
                camera.lookAt(player2Mesh.position);
            } else if (cameraMode === 'birdsEye') {
                camera.position.copy(birdsEyePos);
                camera.lookAt(birdsEyeTarget);
            } else if (cameraMode === 'flyAround') {
                flyAngle += 0.01; // Adjust speed of rotation
                const radius = 30;
                const height = 20 + Math.sin(flyAngle * 0.5) * 5; // Slight vertical oscillation
                camera.position.set(
                    Math.cos(flyAngle) * radius,
                    height,
                    Math.sin(flyAngle) * radius
                );
                camera.lookAt(gridViewTarget);
            }
        }

        // Game mode
        let is1PlayerMode = false;

        // Handle input for red player direction in 1 Player Mode
        function handleInput(event) {
            if (document.getElementById('welcomeScreen').style.display !== 'none' || !is1PlayerMode) return;

            // Prevent interaction with UI elements
            if (event.target.tagName === 'BUTTON' || event.target.closest('#ui')) return;

            const clientX = event.type === 'click' ? event.clientX : event.touches[0].clientX;
            const clientY = event.type === 'click' ? event.clientY : event.touches[0].clientY;
            const screenCenterX = window.innerWidth / 2;
            const screenCenterY = window.innerHeight / 2;
            const deltaX = clientX - screenCenterX;
            const deltaY = clientY - screenCenterY;

            // Determine direction based on input position
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                player1.direction = deltaX > 0 ? 'right' : 'left';
            } else {
                player1.direction = deltaY > 0 ? 'down' : 'up';
            }
        }

        // Camera toggle and speed boost
        let lastTap = 0;
        document.addEventListener('touchstart', (e) => {
            if (document.getElementById('welcomeScreen').style.display !== 'none') return;
            const now = performance.now();
            if (now - lastTap < 300) {
                updateInterval = baseUpdateInterval / (speedMultiplier * 2);
                setTimeout(() => { updateInterval = baseUpdateInterval / speedMultiplier; }, 5000);
            } else if (!is1PlayerMode) {
                const currentIndex = cameraModes.indexOf(cameraMode);
                cameraMode = cameraModes[(currentIndex + 1) % cameraModes.length];
                updateCamera();
            }
            handleInput(e);
            lastTap = now;
        });

        document.addEventListener('click', (e) => {
            if (document.getElementById('welcomeScreen').style.display !== 'none') return;
            handleInput(e);
        });

        // Camera cycle button
        document.getElementById('cameraButton').addEventListener('click', () => {
            const currentIndex = cameraModes.indexOf(cameraMode);
            cameraMode = cameraModes[(currentIndex + 1) % cameraModes.length];
            console.log('Camera mode changed to:', cameraMode); // Debug log
            updateCamera();
        });

        // Initial camera position
        updateCamera();

        // Random direction change
        function getRandomDirection(currentDirection) {
            const directions = ['up', 'down', 'left', 'right'];
            const opposites = { 'up': 'down', 'down': 'up', 'left': 'right', 'right': 'left' };
            const validDirections = directions.filter(dir => dir !== opposites[currentDirection]);
            return validDirections[Math.floor(Math.random() * validDirections.length)];
        }

        // Check if player is trapped
        function isTrapped(player) {
            const directions = [
                { dir: 'up', x: player.x, z: player.z - 1 },
                { dir: 'down', x: player.x, z: player.z + 1 },
                { dir: 'left', x: player.x - 1, z: player.z },
                { dir: 'right', x: player.x + 1, z: player.z }
            ];
            return directions.every(({ x, z }) => 
                x < 0 || x >= gridSize || z < 0 || z >= gridSize || grid[x][z].isWall
            );
        }

        // Check for adjacent walls
        function hasAdjacentWall(x, z) {
            const neighbors = [
                { x: x, z: z - 1 },
                { x: x, z: z + 1 },
                { x: x - 1, z: z },
                { x: x + 1, z: z }
            ];
            return neighbors.some(({ x, z }) => 
                x >= 0 && x < gridSize && z >= 0 && z < gridSize && grid[x][z].isWall
            );
        }

        // Display bonus message
        function showBonusMessage(message, color) {
            const bonusDiv = document.getElementById('bonusMessage');
            bonusDiv.textContent = message;
            bonusDiv.style.color = color;
            bonusDiv.style.display = 'block';
            setTimeout(() => { bonusDiv.style.display = 'none'; }, 1000);
        }

        // Reset game state
        function resetGame() {
            // Reset player positions and stats
            player1.x = 10;
            player1.z = 10;
            player1.direction = 'right';
            player1.distance = 0;
            player1.lastPos = { x: 10, z: 10 };
            player1.gridCovered = 0;
            player1.wallsMade = 0;
            player1.score = 0;
            player1Mesh.position.set(player1.x - gridSize / 2, 0.1, player1.z - gridSize / 2);

            player2.x = 30;
            player2.z = 30;
            player2.direction = 'left';
            player2.distance = 0;
            player2.lastPos = { x: 30, z: 30 };
            player2.gridCovered = 0;
            player2.wallsMade = 0;
            player2.score = 0;
            player2Mesh.position.set(player2.x - gridSize / 2, 0.1, player2.z - gridSize / 2);

            // Reset grid
            for (let x = 0; x < gridSize; x++) {
                for (let z = 0; z < gridSize; z++) {
                    grid[x][z].mesh.material.color.setHex(0x111111);
                    grid[x][z].mesh.material.opacity = 0;
                    grid[x][z].mesh.material.emissive.setHex(0x111111);
                    grid[x][z].mesh.position.y = 0;
                    grid[x][z].color = 0x111111;
                    grid[x][z].visits = 0;
                    grid[x][z].owner = null;
                    grid[x][z].isWall = false;
                }
            }

            // Reset grid lines and players opacity
            gridLines.children.forEach(line => {
                line.material.opacity = 0;
            });
            player1Mesh.material.opacity = 0;
            player1Border.material.opacity = 0;
            player2Mesh.material.opacity = 0;
            player2Border.material.opacity = 0;

            // Reset game state
            gameOver = false;
            gameStarted = false;
            speedMultiplier = 1;
            updateInterval = baseUpdateInterval;
            lastSpeedIncrease = performance.now();

            // Hide game over and show welcome screen
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('welcomeScreen').style.display = 'flex';
            document.getElementById('fadeOverlay').style.display = 'block';
            document.getElementById('fadeOverlay').style.opacity = '1';
        }

        // End game
        let gameOver = false;
        function endGame(winner, loser) {
            gameOver = true;
            cameraMode = 'flyAround'; // Switch to flyAround camera
            const gameOverDiv = document.getElementById('gameOver');
            gameOverDiv.style.display = 'block';
            document.getElementById('winner').textContent = winner === player1 ? 'Red' : 'Blue';
            document.getElementById('winner').style.color = winner === player1 ? '#ff0000' : '#00b7eb';
            document.getElementById('loser').textContent = loser === player1 ? 'Red' : 'Blue';
            document.getElementById('loser').style.color = loser === player1 ? '#ff0000' : '#00b7eb';
            document.getElementById('winnerDistance').textContent = winner.distance;
            document.getElementById('winnerGrid').textContent = winner.gridCovered;
            document.getElementById('winnerWalls').textContent = winner.wallsMade;
        }

        // Restart button handler for game over
        document.getElementById('restartButton').addEventListener('click', (e) => {
            e.stopPropagation();
            resetGame();
        });

        // In-game restart button handler
        document.getElementById('gameRestartButton').addEventListener('click', (e) => {
            e.stopPropagation();
            // End game with no winner/loser (manual restart)
            gameOver = true;
            cameraMode = 'flyAround'; // Switch to flyAround camera
            const gameOverDiv = document.getElementById('gameOver');
            gameOverDiv.style.display = 'block';
            document.getElementById('winner').textContent = 'None';
            document.getElementById('winner').style.color = '#ffffff';
            document.getElementById('loser').textContent = 'None';
            document.getElementById('loser').style.color = '#ffffff';
            document.getElementById('winnerDistance').textContent = 'N/A';
            document.getElementById('winnerGrid').textContent = 'N/A';
            document.getElementById('winnerWalls').textContent = 'N/A';
        });

        // Speed control
        let baseUpdateInterval = 100;
        let updateInterval = baseUpdateInterval;
        let speedMultiplier = 1;
        let lastSpeedIncrease = performance.now();

        // Timer and UI
        let startTime = performance.now();
        function updateUI() {
            const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
            const timeToNextIncrease = (5 - ((performance.now() - lastSpeedIncrease) / 1000)).toFixed(1);
            document.getElementById('timer').textContent = elapsed;
            document.getElementById('redScore').textContent = player1.score;
            document.getElementById('redDistance').textContent = player1.distance;
            document.getElementById('redGrid').textContent = player1.gridCovered;
            document.getElementById('redWalls').textContent = player1.wallsMade;
            document.getElementById('blueScore').textContent = player2.score;
            document.getElementById('blueDistance').textContent = player2.distance;
            document.getElementById('blueGrid').textContent = player2.gridCovered;
            document.getElementById('blueWalls').textContent = player2.wallsMade;
            document.getElementById('speed').textContent = speedMultiplier.toFixed(1);
            document.getElementById('countdown').textContent = timeToNextIncrease > 0 ? timeToNextIncrease : 0;
        }

        // Fade-in grid
        function fadeInGrid(duration) {
            const startTime = performance.now();
            function animateFade() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const gridOpacity = progress * 0.5; // Target opacity for grid
                const lineOpacity = progress * 0.5; // Target opacity for lines
                const playerOpacity = progress; // Target opacity for players

                // Update grid opacity
                for (let x = 0; x < gridSize; x++) {
                    for (let z = 0; z < gridSize; z++) {
                        grid[x][z].mesh.material.opacity = gridOpacity;
                    }
                }

                // Update grid lines opacity
                gridLines.children.forEach(line => {
                    line.material.opacity = lineOpacity;
                });

                // Update player opacity
                player1Mesh.material.opacity = playerOpacity;
                player1Border.material.opacity = playerOpacity;
                player2Mesh.material.opacity = playerOpacity;
                player2Border.material.opacity = playerOpacity;

                if (progress < 1) {
                    requestAnimationFrame(animateFade);
                }
            }
            requestAnimationFrame(animateFade);
        }

        // Render loop for countdown
        function renderDuringCountdown() {
            if (document.getElementById('countdownDisplay').style.display === 'block') {
                updateCamera();
                renderer.render(scene, camera);
                requestAnimationFrame(renderDuringCountdown);
            }
        }

        // Render loop for game over
        function renderGameOver() {
            if (document.getElementById('gameOver').style.display === 'block') {
                updateCamera();
                renderer.render(scene, camera);
                requestAnimationFrame(renderGameOver);
            }
        }

        // Countdown setup
        let gameStarted = false;
        function startCountdown() {
            const countdownDiv = document.getElementById('countdownDisplay');
            const fadeOverlay = document.getElementById('fadeOverlay');
            countdownDiv.style.display = 'block';
            fadeOverlay.style.opacity = '1'; // Ensure overlay is visible
            let countdown = 3;
            countdownDiv.textContent = countdown;

            // Start fading in grid and fading out overlay
            fadeInGrid(4000); // 4-second fade-in
            setTimeout(() => {
                fadeOverlay.style.opacity = '0';
            }, 0);

            // Start rendering the scene
            renderDuringCountdown();

            const countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownDiv.textContent = countdown;
                } else {
                    countdownDiv.textContent = 'Go!';
                    setTimeout(() => {
                        countdownDiv.style.display = 'none';
                        fadeOverlay.style.display = 'none'; // Remove overlay after countdown
                        gameStarted = true;
                        startTime = performance.now();
                        animate();
                    }, 1000);
                    clearInterval(countdownInterval);
                }
            }, 1000);
        }

        // Game loop
        let lastUpdate = performance.now();
        function animate() {
            if (!gameStarted || gameOver) {
                if (gameOver) renderGameOver(); // Continue rendering for game over
                return;
            }
            requestAnimationFrame(animate);
            const now = performance.now();

            if (now - lastSpeedIncrease >= 5000) {
                speedMultiplier += 0.5;
                updateInterval = baseUpdateInterval / speedMultiplier;
                lastSpeedIncrease = now;
            }

            if (now - lastUpdate >= updateInterval) {
                // Update directions for both players in AI Mode (random)
                if (!is1PlayerMode) {
                    if (Math.random() < 0.3) {
                        player1.direction = getRandomDirection(player1.direction);
                    }
                }
                if (Math.random() < 0.3) {
                    player2.direction = getRandomDirection(player2.direction);
                }

                function movePlayer(player, mesh, otherPlayer) {
                    let newX = player.x;
                    let newZ = player.z;

                    if (player.direction === 'up') newZ--;
                    if (player.direction === 'down') newZ++;
                    if (player.direction === 'left') newX--;
                    if (player.direction === 'right') newX++;

                    if (newX === otherPlayer.x && newZ === otherPlayer.z) {
                        if (!is1PlayerMode || player !== player1) {
                            player.direction = getRandomDirection(player.direction);
                        }
                        return;
                    }

                    if (newX >= 0 && newX < gridSize && newZ >= 0 && newZ < gridSize && !grid[newX][newZ].isWall) {
                        player.x = newX;
                        player.z = newZ;

                        if (player.x !== player.lastPos.x || player.z !== player.lastPos.z) {
                            player.distance++;
                            player.score += 1;
                            player.lastPos = { x: player.x, z: player.z };
                        }

                        const cell = grid[player.x][player.z];
                        cell.visits++;
                        if (cell.owner !== player) {
                            if (cell.owner === player1) player1.gridCovered--;
                            if (cell.owner === player2) player2.gridCovered--;
                            cell.owner = player;
                            player.gridCovered++;
                        }
                        if (cell.visits >= 5) {
                            cell.isWall = true;
                            cell.mesh.position.y = 0.02;
                            cell.mesh.material.opacity = 0.9;
                            cell.mesh.material.emissive.setHex(player.color);
                            cell.mesh.material.emissiveIntensity = 0.8;
                            player.wallsMade++;
                            player.score += 10;
                            showBonusMessage('+10 Wall Bonus!', player === player1 ? '#ff0000' : '#00b7eb');
                            if (hasAdjacentWall(player.x, player.z)) {
                                player.score += 50;
                                showBonusMessage('+50 Adjacent Wall Bonus!', player === player1 ? '#ff0000' : '#00b7eb');
                            }
                        }
                        const intensity = Math.min(cell.visits * 0.4, 1);
                        const r = Math.floor((player.color >> 16) * intensity);
                        const g = Math.floor(((player.color >> 8) & 0xff) * intensity);
                        const b = Math.floor((player.color & 0xff) * intensity);
                        const newColor = (r << 16) | (g << 8) | b;
                        cell.mesh.material.color.setHex(newColor);
                        cell.mesh.material.opacity = cell.isWall ? 0.9 : 0.5 + intensity * 0.4;
                        cell.color = newColor;

                        const targetPos = new THREE.Vector3(player.x - gridSize / 2, 0.1, player.z - gridSize / 2);
                        mesh.position.lerp(targetPos, 0.9);
                    } else {
                        // Only change direction on collision if not in 1 Player Mode for player1
                        if (!is1PlayerMode || player !== player1) {
                            player.direction = getRandomDirection(player.direction);
                        }
                    }

                    if (isTrapped(player)) {
                        endGame(otherPlayer, player);
                    }
                }

                movePlayer(player1, player1Mesh, player2);
                movePlayer(player2, player2Mesh, player1);

                lastUpdate = now;
            }

            updateCamera();
            updateUI();
            renderer.render(scene, camera);
        }

        // Welcome screen button handlers
        document.getElementById('start1Player').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('welcomeScreen').style.display = 'none';
            is1PlayerMode = true;
            startCountdown();
        });

        document.getElementById('startAIMode').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('welcomeScreen').style.display = 'none';
            is1PlayerMode = false;
            startCountdown();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
