<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Donkey Wrong</title>
    <style>
        canvas {
            border: 8px solid #1a1a1a;
            display: block;
            margin: 30px auto;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            background: #2a1a0e;
        }
        #ui {
            text-align: center;
            font-family: 'Press Start 2P', monospace;
            color: #ffd700;
            background: linear-gradient(180deg, #3a1f12, #6b3e26);
            padding: 30px;
            border-radius: 15px;
            width: 800px;
            margin: 0 auto;
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.6);
            border: 2px solid #ffd700;
        }
        body {
            background: radial-gradient(circle, #8b4513, #4a2c1b);
        }
        h1 {
            text-shadow: 3px 3px #000, 5px 5px rgba(0, 0, 0, 0.5);
            font-size: 36px;
        }
        p {
            font-size: 20px;
            text-shadow: 2px 2px #000;
        }
        #aiButton, #skipButton {
            font-family: 'Press Start 2P', monospace;
            font-size: 16px;
            color: #ffd700;
            background: #5c4033;
            border: 3px solid #ffd700;
            border-radius: 10px;
            padding: 10px 20px;
            cursor: pointer;
            margin: 10px;
            text-shadow: 2px 2px #000;
            transition: background 0.2s;
        }
        #aiButton:hover, #skipButton:hover {
            background: #8b4513;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <div id="ui">
        <h1>Donkey Wrong</h1>
        <p>Score: <span id="score">0</span> | Time: <span id="time">90</span> | Level: <span id="level">1</span></p>
        <button id="aiButton">AI Mode: OFF</button>
        <button id="skipButton">Skip Level</button>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const timeDisplay = document.getElementById('time');
        const levelDisplay = document.getElementById('level');
        const aiButton = document.getElementById('aiButton');
        const skipButton = document.getElementById('skipButton');

        let score = 0;
        let time = 90;
        let level = 1;
        let gameState = 'playing';
        let lastTime = performance.now();
        let gameOverTime = 0;
        let aiMode = false;

        // Player
        const player = {
            x: 50,
            y: 500,
            width: 40,
            height: 40,
            speed: 300,
            aiSpeed: 150,
            jumping: false,
            jumpPower: 600,
            vx: 0,
            vy: 0,
            direction: 0,
            vertical: 0,
            vineLockTime: 0,
            vineLockDirection: 0,
            vineTime: 0,
            lastY: 500,
            lastX: 50,
            waitTime: 0,
            stuckTime: 0,
            lastTargets: [],
            path: [],
            pathUpdateTime: 0
        };

        // Level configurations
        const levels = {
            1: {
                platforms: [
                    { x: 0, y: 550, width: 800, height: 50 },
                    { x: 80, y: 400, width: 240, height: 20 },
                    { x: 480, y: 400, width: 240, height: 20 },
                    { x: 180, y: 250, width: 240, height: 20 },
                    { x: 580, y: 250, width: 240, height: 20 }
                ],
                vines: [
                    { x: 350, y: 250, height: 150 },
                    { x: 450, y: 250, height: 150 }
                ],
                enemies: [
                    { x: 150, y: 380, width: 30, height: 30, speed: 80 },
                    { x: 550, y: 380, width: 30, height: 30, speed: -80 }
                ],
                key: { x: 700, y: 230, width: 20, height: 20 }
            },
            2: {
                platforms: [
                    { x: 0, y: 550, width: 800, height: 50 },
                    { x: 50, y: 450, width: 200, height: 20 },
                    { x: 550, y: 450, width: 200, height: 20 },
                    { x: 300, y: 300, width: 200, height: 20, moving: true, speed: 100, minX: 200, maxX: 400, startX: 300 },
                    { x: 600, y: 200, width: 200, height: 20 }
                ],
                vines: [
                    { x: 150, y: 200, height: 250 },
                    { x: 250, y: 200, height: 250 },
                    { x: 650, y: 100, height: 100 }
                ],
                enemies: [
                    { x: 100, y: 430, width: 30, height: 30, speed: 80 },
                    { x: 600, y: 430, width: 30, height: 30, speed: -80 },
                    { x: 150, y: 200, width: 30, height: 30, speed: 0, vine: 0, vineSpeed: 50 },
                    { x: 250, y: 300, width: 30, height: 30, speed: 0, vine: 1, vineSpeed: -50 }
                ],
                key: { x: 700, y: 180, width: 20, height: 20 }
            },
            3: {
                platforms: [
                    { x: 0, y: 550, width: 800, height: 50 },
                    { x: 100, y: 400, width: 200, height: 20 },
                    { x: 500, y: 400, width: 200, height: 20 },
                    { x: 150, y: 300, width: 150, height: 20 },
                    { x: 550, y: 300, width: 150, height: 20 }
                ],
                vines: [
                    { x: 200, y: 200, height: 200 },
                    { x: 600, y: 200, height: 200 },
                    { x: 400, y: 100, height: 100 }
                ],
                enemies: [
                    { x: 150, y: 380, width: 30, height: 30, speed: 100 },
                    { x: 550, y: 380, width: 30, height: 30, speed: -100 },
                    { x: 200, y: 250, width: 30, height: 30, speed: 0, vine: 0, vineSpeed: 60 }
                ],
                key: { x: 400, y: 80, width: 20, height: 20 }
            },
            4: {
                platforms: [
                    { x: 0, y: 550, width: 800, height: 50 },
                    { x: 50, y: 450, width: 250, height: 20 },
                    { x: 450, y: 350, width: 250, height: 20 },
                    { x: 200, y: 250, width: 200, height: 20, moving: true, speed: 120, minX: 100, maxX: 500, startX: 200 }
                ],
                vines: [
                    { x: 300, y: 250, height: 200 },
                    { x: 500, y: 150, height: 200 }
                ],
                enemies: [
                    { x: 100, y: 430, width: 30, height: 30, speed: 90 },
                    { x: 600, y: 330, width: 30, height: 30, speed: -90 },
                    { x: 300, y: 300, width: 30, height: 30, speed: 0, vine: 0, vineSpeed: -70 }
                ],
                key: { x: 650, y: 130, width: 20, height: 20 }
            },
            5: {
                platforms: [
                    { x: 0, y: 550, width: 800, height: 50 },
                    { x: 100, y: 400, width: 200, height: 20 },
                    { x: 500, y: 400, width: 200, height: 20 },
                    { x: 250, y: 300, width: 300, height: 20 }
                ],
                vines: [
                    { x: 150, y: 200, height: 200 },
                    { x: 350, y: 100, height: 200 },
                    { x: 550, y: 200, height: 200 }
                ],
                enemies: [
                    { x: 150, y: 380, width: 30, height: 30, speed: 100 },
                    { x: 550, y: 380, width: 30, height: 30, speed: -100 },
                    { x: 150, y: 250, width: 30, height: 30, speed: 0, vine: 0, vineSpeed: 60 },
                    { x: 350, y: 150, width: 30, height: 30, speed: 0, vine: 1, vineSpeed: -60 }
                ],
                key: { x: 350, y: 80, width: 20, height: 20 }
            },
            6: {
                platforms: [
                    { x: 0, y: 550, width: 800, height: 50 },
                    { x: 50, y: 450, width: 200, height: 20 },
                    { x: 550, y: 450, width: 200, height: 20 },
                    { x: 200, y: 300, width: 200, height: 20, moving: true, speed: 110, minX: 100, maxX: 400, startX: 200 },
                    { x: 450, y: 200, width: 200, height: 20 }
                ],
                vines: [
                    { x: 250, y: 200, height: 250 },
                    { x: 550, y: 100, height: 100 }
                ],
                enemies: [
                    { x: 100, y: 430, width: 30, height: 30, speed: 100 },
                    { x: 600, y: 430, width: 30, height: 30, speed: -100 },
                    { x: 250, y: 300, width: 30, height: 30, speed: 0, vine: 0, vineSpeed: 70 },
                    { x: 550, y: 150, width: 30, height: 30, speed: 0, vine: 1, vineSpeed: -70 }
                ],
                key: { x: 600, y: 180, width: 20, height: 20 }
            },
            7: {
                platforms: [
                    { x: 0, y: 550, width: 800, height: 50 },
                    { x: 100, y: 400, width: 200, height: 20 },
                    { x: 500, y: 400, width: 200, height: 20 },
                    { x: 300, y: 300, width: 200, height: 20 }
                ],
                vines: [
                    { x: 200, y: 200, height: 200 },
                    { x: 400, y: 100, height: 200 },
                    { x: 600, y: 200, height: 200 }
                ],
                enemies: [
                    { x: 150, y: 380, width: 30, height: 30, speed: 110 },
                    { x: 550, y: 380, width: 30, height: 30, speed: -110 },
                    { x: 200, y: 250, width: 30, height: 30, speed: 0, vine: 0, vineSpeed: 80 },
                    { x: 400, y: 150, width: 30, height: 30, speed: 0, vine: 1, vineSpeed: -80 },
                    { x: 600, y: 250, width: 30, height: 30, speed: 0, vine: 2, vineSpeed: 80 }
                ],
                key: { x: 400, y: 80, width: 20, height: 20 }
            },
            8: {
                platforms: [
                    { x: 0, y: 550, width: 800, height: 50 },
                    { x: 50, y: 450, width: 200, height: 20 },
                    { x: 550, y: 450, width: 200, height: 20 },
                    { x: 200, y: 300, width: 200, height: 20, moving: true, speed: 130, minX: 100, maxX: 500, startX: 200 },
                    { x: 450, y: 200, width: 200, height: 20 }
                ],
                vines: [
                    { x: 300, y: 200, height: 250 },
                    { x: 600, y: 100, height: 100 }
                ],
                enemies: [
                    { x: 100, y: 430, width: 30, height: 30, speed: 120 },
                    { x: 600, y: 430, width: 30, height: 30, speed: -120 },
                    { x: 300, y: 300, width: 30, height: 30, speed: 0, vine: 0, vineSpeed: 90 },
                    { x: 600, y: 150, width: 30, height: 30, speed: 0, vine: 1, vineSpeed: -90 }
                ],
                key: { x: 600, y: 80, width: 20, height: 20 }
            },
            9: {
                platforms: [
                    { x: 0, y: 550, width: 800, height: 50 },
                    { x: 100, y: 400, width: 200, height: 20 },
                    { x: 500, y: 400, width: 200, height: 20 },
                    { x: 250, y: 300, width: 300, height: 20, moving: true, speed: 140, minX: 150, maxX: 450, startX: 250 }
                ],
                vines: [
                    { x: 150, y: 200, height: 200 },
                    { x: 350, y: 100, height: 200 },
                    { x: 550, y: 200, height: 200 }
                ],
                enemies: [
                    { x: 150, y: 380, width: 30, height: 30, speed: 130 },
                    { x: 550, y: 380, width: 30, height: 30, speed: -130 },
                    { x: 150, y: 250, width: 30, height: 30, speed: 0, vine: 0, vineSpeed: 100 },
                    { x: 350, y: 150, width: 30, height: 30, speed: 0, vine: 1, vineSpeed: -100 },
                    { x: 550, y: 250, width: 30, height: 30, speed: 0, vine: 2, vineSpeed: 100 }
                ],
                key: { x: 350, y: 80, width: 20, height: 20 }
            }
        };

        let currentLevel = levels[1];
        let platforms = currentLevel.platforms;
        let vines = currentLevel.vines;
        let enemies = currentLevel.enemies;
        let key = currentLevel.key;

        // AI Mode toggle
        aiButton.addEventListener('click', () => {
            aiMode = !aiMode;
            aiButton.textContent = `AI Mode: ${aiMode ? 'ON' : 'OFF'}`;
        });

        // Skip Level button
        skipButton.addEventListener('click', () => {
            score += 100;
            level = level < 9 ? level + 1 : 1;
            resetLevel();
        });

        // Touch controls
        let lastTap = 0;
        let touchActive = false;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchCurrentX = 0;
        let touchCurrentY = 0;
        let tapTimeout;

        function handleTouchStart(e) {
            if (aiMode) return;
            e.preventDefault();
            const currentTime = Date.now();
            touchStartX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
            touchStartY = e.touches[0].clientY - canvas.getBoundingClientRect().top;
            touchCurrentX = touchStartX;
            touchCurrentY = touchStartY;
            touchActive = true;

            tapTimeout = setTimeout(() => {
                if (!touchActive) return;
                player.direction = touchStartX < canvas.width / 2 ? -1 : 1;
            }, 300);

            if (touchStartY < canvas.height * 0.25) {
                player.vertical = -1;
            } else if (touchStartY > canvas.height * 0.75) {
                player.vertical = 1;
            }
        }

        function handleTouchMove(e) {
            if (aiMode) return;
            e.preventDefault();
            touchCurrentX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
            touchCurrentY = e.touches[0].clientY - canvas.getBoundingClientRect().top;

            clearTimeout(tapTimeout);

            if (touchCurrentY < canvas.height * 0.25) {
                player.vertical = -1;
            } else if (touchCurrentY > canvas.height * 0.75) {
                player.vertical = 1;
            } else {
                player.vertical = 0;
            }
        }

        function handleTouchEnd(e) {
            if (aiMode) return;
            e.preventDefault();
            if (touchActive) {
                const dx = touchCurrentX - touchStartX;
                const dy = touchCurrentY - touchStartY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 20 && !player.jumping) {
                    for (let platform of platforms) {
                        if (player.x + player.width > platform.x && player.x < platform.x + platform.width &&
                            player.y + player.height >= platform.y && player.y + player.height <= platform.y + 10) {
                            const jumpScale = Math.min(distance / 100, 1);
                            player.vx = (dx / distance) * player.speed * jumpScale;
                            player.vy = (dy / distance) * player.jumpPower * jumpScale;
                            if (player.vy > 0) player.vy = -player.jumpPower * jumpScale;
                            player.jumping = true;
                            break;
                        }
                    }
                }
            }
            touchActive = false;
            player.direction = 0;
            player.vertical = 0;
            clearTimeout(tapTimeout);
        }

        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', handleTouchEnd);

        function resetLevel() {
            player.x = 50;
            player.y = 500;
            player.vx = 0;
            player.vy = 0;
            player.jumping = false;
            player.direction = 0;
            player.vertical = 0;
            player.vineLockTime = 0;
            player.vineLockDirection = 0;
            player.vineTime = 0;
            player.lastY = 500;
            player.lastX = 50;
            player.waitTime = 0;
            player.stuckTime = 0;
            player.lastTargets = [];
            player.path = [];
            player.pathUpdateTime = 0;
            time = 90;
            currentLevel = levels[level];
            platforms = currentLevel.platforms.map(p => ({ ...p, x: p.startX || p.x }));
            vines = currentLevel.vines;
            enemies = currentLevel.enemies.map(e => ({ ...e }));
            key = { ...currentLevel.key };
            enemies.forEach(enemy => {
                if (enemy.vine !== undefined) {
                    enemy.y = vines[enemy.vine].y + Math.random() * vines[enemy.vine].height;
                    enemy.x = vines[enemy.vine].x;
                } else {
                    enemy.x = 150 + Math.random() * 400;
                }
                enemy.speed = (Math.random() > 0.5 ? 1 : -1) * (80 + level * 16);
            });
            scoreDisplay.textContent = score;
            timeDisplay.textContent = Math.floor(time);
            levelDisplay.textContent = level;
        }

        // A* Pathfinding
        function findPath() {
            const nodes = [
                ...platforms.map(p => ({ type: 'platform', x: p.x + p.width / 2, y: p.y, width: p.width, height: p.height })),
                ...vines.map(v => ({ type: 'vine', x: v.x + 10, y: v.y + v.height / 2, height: v.height })),
                { type: 'key', x: key.x + key.width / 2, y: key.y + key.height / 2 }
            ];
            const start = { type: 'player', x: player.x + player.width / 2, y: player.y + player.height / 2 };
            const goal = nodes.find(n => n.type === 'key');

            const openSet = [{ node: start, g: 0, h: heuristic(start, goal), f: heuristic(start, goal), parent: null }];
            const closedSet = [];

            while (openSet.length > 0) {
                openSet.sort((a, b) => a.f - b.f);
                const current = openSet.shift();

                if (current.node === goal) {
                    const path = [];
                    let temp = current;
                    while (temp) {
                        if (temp.node !== start) path.unshift(temp.node);
                        temp = temp.parent;
                    }
                    return path;
                }

                closedSet.push(current.node);

                for (let neighbor of nodes) {
                    if (closedSet.includes(neighbor)) continue;

                    const dx = neighbor.x - current.node.x;
                    const dy = neighbor.y - current.node.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > 300 || Math.abs(dy) > 200) continue;

                    let safe = true;
                    let enemyCost = 0;
                    for (let enemy of enemies) {
                        const edx = enemy.x - neighbor.x;
                        const edy = enemy.y - neighbor.y;
                        if (Math.abs(edx) < 150 && Math.abs(edy) < 50) {
                            safe = false;
                            enemyCost += 500;
                            break;
                        }
                    }

                    const g = current.g + distance + enemyCost;
                    const h = heuristic(neighbor, goal);
                    const f = g + h;

                    let inOpen = openSet.find(n => n.node === neighbor);
                    if (!inOpen) {
                        openSet.push({ node: neighbor, g, h, f, parent: current });
                    } else if (g < inOpen.g) {
                        inOpen.g = g;
                        inOpen.f = f;
                        inOpen.parent = current;
                    }
                }
            }

            return [goal]; // Fallback to key if no path found
        }

        function heuristic(a, b) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function aiControl(dt) {
            player.direction = 0;
            player.vertical = 0;

            // Update timers
            player.vineLockTime = Math.max(0, player.vineLockTime - dt);
            player.waitTime = Math.max(0, player.waitTime - dt);
            player.pathUpdateTime = Math.max(0, player.pathUpdateTime - dt);

            // Check if stuck
            const moved = Math.abs(player.x - player.lastX) > 10 || Math.abs(player.y - player.lastY) > 10 || player.vx !== 0 || player.vy !== 0;
            if (!moved && player.waitTime <= 0) {
                player.stuckTime += dt;
            } else {
                player.stuckTime = 0;
            }
            player.lastX = player.x;
            player.lastY = player.y;

            // Update path if needed
            if (player.pathUpdateTime <= 0 || player.path.length === 0) {
                player.path = findPath();
                player.pathUpdateTime = 2;
            }

            // Check if on vine
            let onVine = false;
            let currentVine = null;
            let vineIndex = -1;
            for (let i = 0; i < vines.length; i++) {
                let vine = vines[i];
                if (player.x + player.width > vine.x && player.x < vine.x + 20 &&
                    player.y + player.height > vine.y && player.y < vine.y + vine.height) {
                    onVine = true;
                    currentVine = vine;
                    vineIndex = i;
                    player.vineTime += dt;
                    break;
                } else {
                    player.vineTime = 0;
                }
            }

            // Check for nearby enemies
            let avoidEnemy = null;
            for (let enemy of enemies) {
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                if (Math.abs(dx) < 300 && Math.abs(dy) < 50) {
                    avoidEnemy = enemy;
                    break;
                }
            }

            // Get next target from path
            let closestTarget = player.path[0];
            if (!closestTarget) return;

            // Check if reached target
            const dxToTarget = closestTarget.x - (player.x + player.width / 2);
            const dyToTarget = closestTarget.y - (player.y + player.height / 2);
            if (Math.abs(dxToTarget) < 20 && Math.abs(dyToTarget) < 20) {
                player.path.shift();
                player.lastTargets.push(closestTarget);
                if (player.lastTargets.length > 2) player.lastTargets.shift();
                closestTarget = player.path[0];
                if (!closestTarget) return;
            }

            // Check if path to target is clear
            let pathClear = true;
            for (let enemy of enemies) {
                const dx = enemy.x - closestTarget.x;
                const dy = enemy.y - closestTarget.y;
                const pathDx = enemy.x - (player.x + player.width / 2);
                const pathDy = enemy.y - (player.y + player.height / 2);
                if (Math.abs(dx) < 150 && Math.abs(dy) < 50 || Math.abs(pathDx) < 150 && Math.abs(pathDy) < 50) {
                    pathClear = false;
                    break;
                }
            }

            // Key within reach
            const keyDistance = Math.sqrt((key.x + key.width / 2 - (player.x + player.width / 2)) ** 2 + (key.y + key.height / 2 - (player.y + player.height / 2)) ** 2);
            if (keyDistance < 100 && pathClear) {
                closestTarget = { type: 'key', x: key.x + key.width / 2, y: key.y + key.height / 2 };
            }

            // Force movement if stuck for >2 seconds
            if (player.stuckTime > 2) {
                if (onVine) {
                    if (pathClear) {
                        // Jump off vine
                        const dx = closestTarget.x - (player.x + player.width / 2);
                        player.vx = (dx > 0 ? 1 : -1) * player.aiSpeed;
                        player.vy = -player.jumpPower * 0.5;
                        player.jumping = true;
                        player.direction = dx > 0 ? 1 : -1;
                        player.vineTime = 0;
                        player.vineLockTime = 0;
                        player.stuckTime = 0;
                        return;
                    } else {
                        // Move horizontally
                        const dx = avoidEnemy ? avoidEnemy.x - player.x : closestTarget.x - (player.x + player.width / 2);
                        player.direction = avoidEnemy ? (dx > 0 ? -1 : 1) : (dx > 0 ? 1 : -1);
                        player.stuckTime = 0;
                        return;
                    }
                } else if (pathClear) {
                    // Jump from platform/ground
                    for (let platform of platforms) {
                        if (player.x + player.width > platform.x && player.x < platform.x + platform.width &&
                            player.y + player.height >= platform.y && player.y + player.height <= platform.y + 10) {
                            const dx = closestTarget.x - (player.x + player.width / 2);
                            const dy = closestTarget.y - (player.y + player.height / 2);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const jumpScale = Math.min(distance / 100, 1);
                            player.vx = (dx / distance) * player.aiSpeed * jumpScale;
                            player.vy = -player.jumpPower * jumpScale;
                            player.jumping = true;
                            player.stuckTime = 0;
                            return;
                        }
                    }
                }
                // Move horizontally if can't jump
                const dx = avoidEnemy ? avoidEnemy.x - player.x : closestTarget.x - (player.x + player.width / 2);
                player.direction = avoidEnemy ? (dx > 0 ? -1 : 1) : (dx > 0 ? 1 : -1);
                player.stuckTime = 0;
                return;
            }

            if (onVine && currentVine) {
                // Check if stuck on vine
                const stuck = player.vineTime > 2 && Math.abs(player.y - player.lastY) < 20;
                const dx = closestTarget.x - (player.x + player.width / 2);
                const dy = closestTarget.y - (player.y + player.height / 2);

                if (stuck || Math.abs(dx) > 50 || Math.abs(dy) < 20) {
                    if (pathClear) {
                        // Jump off vine
                        player.vx = (dx > 0 ? 1 : -1) * player.aiSpeed;
                        player.vy = -player.jumpPower * 0.5;
                        player.jumping = true;
                        player.direction = dx > 0 ? 1 : -1;
                        player.vineTime = 0;
                        player.vineLockTime = 0;
                        return;
                    } else {
                        // Move horizontally
                        player.direction = dx > 0 ? 1 : -1;
                        player.waitTime = 1;
                    }
                } else {
                    // Climb toward target y-position
                    let vineEnemy = null;
                    for (let enemy of enemies) {
                        if (enemy.vine === vineIndex && Math.abs(enemy.y - player.y) < 100) {
                            vineEnemy = enemy;
                            break;
                        }
                    }
                    let desiredVertical = 0;
                    if (vineEnemy) {
                        desiredVertical = vineEnemy.y > player.y ? -1 : 1;
                    } else if (dy < -20) {
                        desiredVertical = -1;
                    } else if (dy > 20) {
                        desiredVertical = 1;
                    }
                    if (player.vineLockTime <= 0 || desiredVertical !== player.vineLockDirection) {
                        player.vineLockDirection = desiredVertical;
                        player.vineLockTime = 0.5;
                        player.vertical = desiredVertical;
                    } else {
                        player.vertical = player.vineLockDirection;
                    }
                }
            } else {
                // Avoid enemy or move toward target
                if (avoidEnemy && !player.jumping) {
                    const dx = avoidEnemy.x - player.x;
                    player.direction = dx > 0 ? -1 : 1;
                    if (!pathClear) {
                        player.waitTime = 1;
                    }
                } else {
                    // Move toward closest target
                    if (closestTarget.x < player.x + player.width / 2 - 10) {
                        player.direction = -1;
                    } else if (closestTarget.x > player.x + player.width / 2 + 10) {
                        player.direction = 1;
                    }

                    // Jump if needed and path is clear
                    if (!player.jumping && pathClear && (Math.abs(closestTarget.x - (player.x + player.width / 2)) > 50 || closestTarget.y < player.y - 50)) {
                        for (let platform of platforms) {
                            if (player.x + player.width > platform.x && player.x < platform.x + platform.width &&
                                player.y + player.height >= platform.y && player.y + player.height <= platform.y + 10) {
                                const dx = closestTarget.x - (player.x + player.width / 2);
                                const dy = closestTarget.y - (player.y + player.height / 2);
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                const jumpScale = Math.min(distance / 100, 1);
                                player.vx = (dx / distance) * player.aiSpeed * jumpScale;
                                player.vy = -player.jumpPower * jumpScale;
                                player.jumping = true;
                                break;
                            }
                        }
                    }
                }
            }
        }

        function update(dt) {
            if (gameState !== 'playing') return;

            if (aiMode) {
                aiControl(dt);
            }

            let dx = player.direction * (aiMode ? player.aiSpeed : player.speed);
            let onVine = false;

            if (player.jumping) {
                for (let vine of vines) {
                    if (Math.abs(player.x + player.width / 2 - vine.x - 10) < 30 &&
                        player.y + player.height > vine.y && player.y < vine.y + vine.height) {
                        player.x = vine.x + 10 - player.width / 2;
                        player.vx = 0;
                        player.vy = 0;
                        player.jumping = false;
                        onVine = true;
                        break;
                    }
                }
            }

            if (!onVine) {
                for (let vine of vines) {
                    if (player.x + player.width > vine.x && player.x < vine.x + 20 &&
                        player.y + player.height > vine.y && player.y < vine.y + vine.height) {
                        onVine = true;
                        player.vx = 0;
                        player.vy = 0;
                        if (player.vertical !== 0) {
                            player.y += player.vertical * (aiMode ? player.aiSpeed : player.speed) * dt;
                        }
                        break;
                    }
                }
            }

            if (!onVine) {
                player.vy += 1000 * dt;
            }

            player.x += (player.vx + dx) * dt;
            player.y += player.vy * dt;

            for (let platform of platforms) {
                if (player.x + player.width > platform.x && player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y && player.y < platform.y + platform.height &&
                    player.vy > 0) {
                    player.y = platform.y - player.height;
                    player.vy = 0;
                    player.vx = 0;
                    player.jumping = false;
                }
            }

            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            if (player.y + player.height > canvas.height) {
                player.y = canvas.height - player.height;
                player.vy = 0;
                player.vx = 0;
                player.jumping = false;
            }

            platforms.forEach(platform => {
                if (platform.moving) {
                    platform.x += platform.speed * dt;
                    if (platform.x < platform.minX || platform.x > platform.maxX) {
                        platform.speed = -platform.speed;
                    }
                    if (player.y + player.height === platform.y && player.x + player.width > platform.x && player.x < platform.x + platform.width) {
                        player.x += platform.speed * dt;
                    }
                }
            });

            for (let i = enemies.length - 1; i >= 0; i--) {
                let enemy = enemies[i];
                if (enemy.vine !== undefined) {
                    enemy.y += enemy.vineSpeed * dt;
                    const vine = vines[enemy.vine];
                    if (enemy.y < vine.y || enemy.y > vine.y + vine.height - enemy.height) {
                        enemy.vineSpeed = -enemy.vineSpeed;
                    }
                    enemy.x = vine.x;
                } else {
                    enemy.x += enemy.speed * dt;
                    if (enemy.x < 100 || enemy.x > 700) enemy.speed = -enemy.speed;
                }

                if (player.x + player.width > enemy.x && player.x < enemy.x + enemy.width &&
                    player.y + player.height > enemy.y && player.y + player.height < enemy.y + 10 &&
                    player.vy > 0) {
                    enemies.splice(i, 1);
                    score += 50;
                    player.vy = -200;
                    player.jumping = true;
                    continue;
                }

                // Only trigger gameover if not in AI Mode
                if (!aiMode && player.x + player.width > enemy.x && player.x < enemy.x + enemy.width &&
                    player.y + player.height > enemy.y && player.y < enemy.y + enemy.height) {
                    gameState = 'gameover';
                    gameOverTime = performance.now();
                }
            }

            if (player.x + player.width > key.x && player.x < key.x + key.width &&
                player.y + player.height > key.y && player.y < key.y + key.height) {
                score += 100;
                level = level < 9 ? level + 1 : 1;
                resetLevel();
            }

            time -= dt;
            if (time <= 0) {
                gameState = 'gameover';
                gameOverTime = performance.now();
            }

            scoreDisplay.textContent = score;
            timeDisplay.textContent = Math.floor(time);
            levelDisplay.textContent = level;
        }

        function draw() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#8b4513');
            gradient.addColorStop(1, '#4a2c1b');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
            for (let i = 0; i < 100; i++) {
                ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 2, 2);
            }

            for (let platform of platforms) {
                const grad = ctx.createLinearGradient(platform.x, platform.y, platform.x, platform.y + platform.height);
                grad.addColorStop(0, '#a0522d');
                grad.addColorStop(1, '#8b4513');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.roundRect(platform.x, platform.y, platform.width, platform.height, 6);
                ctx.fill();
                ctx.strokeStyle = '#5c4033';
                ctx.lineWidth = 5;
                ctx.stroke();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 1;
                for (let i = 0; i < platform.width; i += 10) {
                    ctx.beginPath();
                    ctx.moveTo(platform.x + i, platform.y);
                    ctx.lineTo(platform.x + i + 5, platform.y + platform.height);
                    ctx.stroke();
                }
            }

            for (let vine of vines) {
                const grad = ctx.createLinearGradient(vine.x, vine.y, vine.x + 20, vine.y);
                grad.addColorStop(0, '#228b22');
                grad.addColorStop(1, '#1a5f1a');
                ctx.fillStyle = grad;
                ctx.fillRect(vine.x, vine.y, 20, vine.height);
                ctx.strokeStyle = '#134413';
                ctx.lineWidth = 3;
                ctx.strokeRect(vine.x, vine.y, 20, vine.height);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                for (let i = 0; i < vine.height; i += 8) {
                    ctx.fillRect(vine.x + 2, vine.y + i, 16, 4);
                }
                ctx.fillStyle = '#32cd32';
                for (let i = 0; i < vine.height; i += 20) {
                    ctx.beginPath();
                    ctx.arc(vine.x + 10, vine.y + i, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw player as enhanced monkey
            const playerGrad = ctx.createRadialGradient(player.x + player.width / 2, player.y + player.height / 2, 5, player.x + player.width / 2, player.y + player.height / 2, player.width / 2);
            playerGrad.addColorStop(0, '#5c4033');
            playerGrad.addColorStop(1, '#3c2f2f');
            ctx.fillStyle = playerGrad;
            ctx.fillRect(player.x + 5, player.y + 10, 30, 20); // Body
            ctx.fillStyle = '#d2b48c';
            ctx.fillRect(player.x + 10, player.y + 5, 20, 15); // Face
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(player.x + 15, player.y + 10, 3, 0, Math.PI * 2); // Left eye
            ctx.arc(player.x + 25, player.y + 10, 3, 0, Math.PI * 2); // Right eye
            ctx.fillRect(player.x + 18, player.y + 15, 4, 2); // Nose
            ctx.fill();
            ctx.beginPath();
            ctx.arc(player.x + 20, player.y + 18, 4, Math.PI * 0.2, Math.PI * 0.8); // Mouth
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = playerGrad;
            ctx.beginPath();
            ctx.arc(player.x + 5, player.y + 5, 5, 0, Math.PI * 2); // Left ear
            ctx.arc(player.x + 35, player.y + 5, 5, 0, Math.PI * 2); // Right ear
            ctx.fill();
            // Arms and legs (animated based on movement)
            ctx.fillStyle = playerGrad;
            if (player.jumping) {
                ctx.fillRect(player.x, player.y + 10, 5, 15); // Left arm up
                ctx.fillRect(player.x + 35, player.y + 10, 5, 15); // Right arm up
                ctx.fillRect(player.x + 5, player.y + 30, 10, 10); // Left leg bent
                ctx.fillRect(player.x + 25, player.y + 30, 10, 10); // Right leg bent
            } else {
                ctx.fillRect(player.x, player.y + 15, 5, 20); // Left arm down
                ctx.fillRect(player.x + 35, player.y + 15, 5, 20); // Right arm down
                ctx.fillRect(player.x + 5, player.y + 30, 10, 10); // Left leg
                ctx.fillRect(player.x + 25, player.y + 30, 10, 10); // Right leg
            }
            // Curved tail
            ctx.beginPath();
            ctx.moveTo(player.x + 10, player.y + player.height);
            ctx.quadraticCurveTo(player.x, player.y + player.height + 10, player.x - 5, player.y + player.height + 15);
            ctx.strokeStyle = '#3c2f2f';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Draw enhanced enemies
            for (let enemy of enemies) {
                const grad = ctx.createRadialGradient(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 5, enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, enemy.width / 2);
                grad.addColorStop(0, '#ff4500');
                grad.addColorStop(1, '#8b0000');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.ellipse(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, enemy.width / 2, enemy.height / 3, 0, 0, Math.PI * 2); // Oval body
                ctx.fill();
                ctx.strokeStyle = '#4b0000';
                ctx.lineWidth = 3;
                ctx.stroke();
                // Spikes
                ctx.fillStyle = '#8b0000';
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(enemy.x + enemy.width * (0.3 + i * 0.2), enemy.y);
                    ctx.lineTo(enemy.x + enemy.width * (0.3 + i * 0.2) - 3, enemy.y - 5);
                    ctx.lineTo(enemy.x + enemy.width * (0.3 + i * 0.2) + 3, enemy.y - 5);
                    ctx.fill();
                }
                // Jaw
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(enemy.x + enemy.width / 2, enemy.y - 5);
                ctx.lineTo(enemy.x + enemy.width / 4, enemy.y - 10);
                ctx.lineTo(enemy.x + 3 * enemy.width / 4, enemy.y - 10);
                ctx.closePath();
                ctx.fill();
                // Teeth
                ctx.fillStyle = '#ccc';
                ctx.beginPath();
                ctx.moveTo(enemy.x + enemy.width / 2 - 3, enemy.y - 5);
                ctx.lineTo(enemy.x + enemy.width / 2 - 5, enemy.y - 8);
                ctx.lineTo(enemy.x + enemy.width / 2 - 1, enemy.y - 8);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(enemy.x + enemy.width / 2 + 3, enemy.y - 5);
                ctx.lineTo(enemy.x + enemy.width / 2 + 1, enemy.y - 8);
                ctx.lineTo(enemy.x + enemy.width / 2 + 5, enemy.y - 8);
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(enemy.x + enemy.width * 0.3, enemy.y + enemy.height * 0.3, 4, 0, Math.PI * 2);
                ctx.arc(enemy.x + enemy.width * 0.7, enemy.y + enemy.height * 0.3, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(enemy.x + enemy.width * 0.3, enemy.y + enemy.height * 0.3, 1, 0, Math.PI * 2);
                ctx.arc(enemy.x + enemy.width * 0.7, enemy.y + enemy.height * 0.3, 1, 0, Math.PI * 2);
                ctx.fill();
                // Animated legs
                ctx.fillStyle = grad;
                const legOffset = Math.sin(Date.now() / 100) * 2;
                ctx.fillRect(enemy.x + 5, enemy.y + enemy.height, 5, 5 + legOffset);
                ctx.fillRect(enemy.x + 20, enemy.y + enemy.height, 5, 5 - legOffset);
            }

            // Draw key
            const gradKey = ctx.createRadialGradient(key.x + key.width / 2, key.y + key.height / 2, 5, key.x + key.width / 2, key.y + key.height / 2, key.width);
            gradKey.addColorStop(0, '#fffacd');
            gradKey.addColorStop(1, '#d4a017');
            ctx.fillStyle = gradKey;
            ctx.beginPath();
            // Cloverleaf bow
            ctx.arc(key.x + 5, key.y + 5, 3, 0, Math.PI * 2); // Top lobe
            ctx.arc(key.x + 2, key.y + 8, 3, 0, Math.PI * 2); // Left lobe
            ctx.arc(key.x + 8, key.y + 8, 3, 0, Math.PI * 2); // Right lobe
            ctx.fill();
            ctx.fillRect(key.x + 5, key.y + 8, 8, 8); // Shaft
            // Spiral texture
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(key.x + 6, key.y + 9);
            ctx.lineTo(key.x + 8, key.y + 15);
            ctx.moveTo(key.x + 8, key.y + 9);
            ctx.lineTo(key.x + 10, key.y + 15);
            ctx.stroke();
            ctx.fillStyle = gradKey;
            ctx.fillRect(key.x + 10, key.y + 10, 5, 4); // Large tooth
            ctx.fillRect(key.x + 10, key.y + 14, 3, 2); // Small tooth
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.strokeRect(key.x + 5, key.y + 8, 8, 8);
            ctx.strokeRect(key.x + 10, key.y + 10, 5, 4);
            ctx.strokeRect(key.x + 10, key.y + 14, 3, 2);
            // Glow
            ctx.fillStyle = `rgba(255, 255, 0, ${0.5 + Math.sin(Date.now() / 200) * 0.3})`;
            ctx.beginPath();
            ctx.arc(key.x + key.width / 2, key.y + key.height / 2, key.width * 2, 0, Math.PI * 2);
            ctx.fill();
            // Sparkle
            ctx.fillStyle = '#fff';
            ctx.globalAlpha = Math.abs(Math.sin(Date.now() / 300));
            ctx.beginPath();
            ctx.moveTo(key.x + 5, key.y + 5);
            ctx.lineTo(key.x + 7, key.y + 3);
            ctx.lineTo(key.x + 9, key.y + 5);
            ctx.lineTo(key.x + 7, key.y + 7);
            ctx.fill();
            ctx.globalAlpha = 1;

            if (gameState === 'gameover') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffd700';
                ctx.font = '48px Press Start 2P';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2);
                ctx.font = '24px Press Start 2P';
                ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 70);
                ctx.fillText(`Restarting in ${(2 - (performance.now() - gameOverTime) / 1000).toFixed(1)}s`, canvas.width / 2, canvas.height / 2 + 110);
                ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 2, 150, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function gameLoop(currentTime) {
            const dt = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            if (gameState === 'gameover' && currentTime - gameOverTime > 2000) {
                resetLevel();
                gameState = 'playing';
            }

            update(dt);
            draw();

            requestAnimationFrame(gameLoop);
        }

        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>