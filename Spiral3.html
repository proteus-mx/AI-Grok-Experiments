<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Improved 3D Spiral Starfield</title>
  <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dat.gui"></script>

  <script>
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 5000);
    let renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    camera.position.z = 800;

    const starLayers = [];

    function createLogSpiralLayer(count, color, armCount, spin, zRange) {
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];

      for (let i = 0; i < count; i++) {
        const arm = i % armCount;
        const t = i / count * Math.PI * 10;
        const radius = 50 + 300 * Math.exp(0.05 * t);
        const angle = t + (arm * 2 * Math.PI / armCount);
        const x = Math.cos(angle * spin) * radius;
        const y = Math.sin(angle * spin) * radius;
        const z = (Math.random() - 0.5) * zRange;

        positions.push(x, y, z);

        const c = new THREE.Color(color);
        colors.push(c.r, c.g, c.b);
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      const material = new THREE.PointsMaterial({ size: 1.2, vertexColors: true });
      const points = new THREE.Points(geometry, material);
      scene.add(points);
      starLayers.push({ points, speed: 0.001 + Math.random() * 0.002 });
    }

    // Create layers with more realistic variation
    createLogSpiralLayer(4000, 0xffcc88, 4, 1.0, 500);
    createLogSpiralLayer(3000, 0x88ccff, 5, 1.2, 800);
    createLogSpiralLayer(2000, 0xcc88ff, 6, 0.9, 300);

    // GUI for hue shift
    const gui = new dat.GUI();
    const settings = { hueShift: 0 };

    gui.add(settings, 'hueShift', 0, 1).step(0.01).onChange(val => {
      starLayers.forEach(layer => {
        const colors = layer.points.geometry.attributes.color;
        for (let i = 0; i < colors.count; i++) {
          const c = new THREE.Color().setHSL((val + i / colors.count) % 1, 1.0, 0.5);
          colors.setXYZ(i, c.r, c.g, c.b);
        }
        colors.needsUpdate = true;
      });
    });

    // Tilt-based camera zoom
    let tiltZoom = 0;

    window.addEventListener('deviceorientation', (e) => {
      const gamma = e.gamma || 0; // side tilt
      const beta = e.beta || 0;   // forward/back tilt

      camera.rotation.y = THREE.MathUtils.degToRad(gamma / 2);
      camera.rotation.x = THREE.MathUtils.degToRad(beta / 4);

      // Forward tilt = zoom in, Backward tilt = zoom out
      tiltZoom = THREE.MathUtils.clamp(-beta, -60, 60); // limit range
    });

    function animate() {
      requestAnimationFrame(animate);

      // Slowly interpolate zoom for smoothness
      const targetZ = 800 + tiltZoom * 10;
      camera.position.z += (targetZ - camera.position.z) * 0.05;

      starLayers.forEach(layer => {
        layer.points.rotation.z += layer.speed;
      });

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
